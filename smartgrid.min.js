var smartGrid = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // core/EventEmitter.js
  var EventEmitter;
  var init_EventEmitter = __esm({
    "core/EventEmitter.js"() {
      EventEmitter = class {
        constructor() {
          __publicField(this, "events", /* @__PURE__ */ new Map());
          __publicField(this, "maxListeners", 10);
        }
        /**
         * 이벤트 리스너 등록
         * @param {string} eventName - 이벤트 이름
         * @param {Function} listener - 리스너 함수
         * @returns {Function} 리스너 제거 함수
         */
        on(eventName, listener) {
          if (typeof listener !== "function") {
            throw new TypeError("Listener must be a function");
          }
          if (!this.events.has(eventName)) {
            this.events.set(eventName, []);
          }
          const listeners = this.events.get(eventName);
          if (listeners.length >= this.maxListeners) {
            console.warn(`Possible EventEmitter memory leak detected. ${listeners.length + 1} ${eventName} listeners added. Use setMaxListeners() to increase limit`);
          }
          listeners.push(listener);
          return () => this.off(eventName, listener);
        }
        /**
         * 일회성 이벤트 리스너 등록
         * @param {string} eventName - 이벤트 이름
         * @param {Function} listener - 리스너 함수
         * @returns {Function} 리스너 제거 함수
         */
        once(eventName, listener) {
          const wrapper = (...args) => {
            listener(...args);
            this.off(eventName, wrapper);
          };
          wrapper.listener = listener;
          return this.on(eventName, wrapper);
        }
        /**
         * 이벤트 리스너 제거
         * @param {string} eventName - 이벤트 이름
         * @param {Function} listener - 제거할 리스너 함수
         * @returns {boolean} 제거 성공 여부
         */
        off(eventName, listener) {
          if (!this.events.has(eventName)) return false;
          const listeners = this.events.get(eventName);
          const index = listeners.findIndex((l) => l === listener || l.listener === listener);
          if (index !== -1) {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              this.events.delete(eventName);
            }
            return true;
          }
          return false;
        }
        /**
         * 이벤트 발생
         * @param {string} eventName - 이벤트 이름
         * @param {...any} args - 리스너에 전달할 인자
         * @returns {boolean} 리스너 호출 여부
         */
        emit(eventName, ...args) {
          if (!this.events.has(eventName)) return false;
          const listeners = [...this.events.get(eventName)];
          for (const listener of listeners) {
            try {
              listener(...args);
            } catch (error) {
              console.error(`Error in event listener for "${eventName}":`, error);
              this.emit("error", { eventName, error, listener });
            }
          }
          return true;
        }
        /**
         * 모든 이벤트 리스너 제거
         * @param {string} [eventName] - 특정 이벤트 이름 (선택사항)
         * @returns {boolean} 제거 성공 여부
         */
        removeAllListeners(eventName) {
          if (eventName) {
            return this.events.delete(eventName);
          }
          this.events.clear();
          return true;
        }
        /**
         * 이벤트 리스너 개수 반환
         * @param {string} eventName - 이벤트 이름
         * @returns {number} 리스너 개수
         */
        listenerCount(eventName) {
          return this.events.get(eventName)?.length ?? 0;
        }
        /**
         * 등록된 모든 이벤트 이름 반환
         * @returns {string[]} 이벤트 이름 배열
         */
        eventNames() {
          return Array.from(this.events.keys());
        }
        /**
         * 최대 리스너 개수 설정
         * @param {number} n - 최대 개수
         * @returns {EventEmitter} 체이닝을 위한 this 반환
         */
        setMaxListeners(n) {
          this.maxListeners = n;
          return this;
        }
        /**
         * 최대 리스너 개수 반환
         * @returns {number} 최대 리스너 개수
         */
        getMaxListeners() {
          return this.maxListeners;
        }
      };
    }
  });

  // core/SmartGridError.js
  var SmartGridError;
  var init_SmartGridError = __esm({
    "core/SmartGridError.js"() {
      SmartGridError = class extends Error {
        /**
         * SmartGridError 생성자
         * @param {string} message - 에러 메시지
         * @param {string} code - 에러 코드
         * @param {string} instanceId - 그리드 인스턴스 ID
         * @param {Object} details - 추가 상세 정보
         */
        constructor(message, code, instanceId, details = {}) {
          super(message);
          this.name = "SmartGridError";
          this.code = code;
          this.instanceId = instanceId;
          this.details = details;
          this.timestamp = (/* @__PURE__ */ new Date()).toISOString();
        }
      };
    }
  });

  // core/utils.js
  function formatNumber(value, decimalPlaces = 0) {
    if (value === null || value === void 0 || value === "") return "";
    const number = parseFloat(value);
    if (isNaN(number)) return String(value);
    return number.toLocaleString("ko-KR", {
      minimumFractionDigits: decimalPlaces,
      maximumFractionDigits: decimalPlaces
    });
  }
  function stripHtml(html) {
    const div = document.createElement("div");
    div.innerHTML = html;
    return div.textContent || div.innerText || "";
  }
  function getCurrentDateTime() {
    return (/* @__PURE__ */ new Date()).toLocaleDateString("ko-KR", { year: "numeric", month: "2-digit", day: "2-digit" }).replace(/\. /g, "-").replace(".", "");
  }
  function createSvgUse(iconId) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "16");
    svg.setAttribute("height", "16");
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", iconId);
    svg.appendChild(use);
    return svg.outerHTML;
  }
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function deepClone(obj) {
    return structuredClone(obj);
  }
  function isEmpty(obj) {
    return Object.keys(obj).length === 0;
  }
  var init_utils = __esm({
    "core/utils.js"() {
    }
  });

  // core/DataHandler.js
  var DataHandler, ClientSideHandler, ServerSideHandler;
  var init_DataHandler = __esm({
    "core/DataHandler.js"() {
      init_SmartGridError();
      init_utils();
      DataHandler = class _DataHandler {
        constructor(grid) {
          if (this.constructor === _DataHandler) {
            throw new TypeError('Abstract class "DataHandler" cannot be instantiated directly.');
          }
          this.grid = grid;
        }
        async load(dataOrParams) {
          throw new Error('Method "load" must be implemented.');
        }
        async page() {
          throw new Error('Method "page" must be implemented.');
        }
        async sort() {
          throw new Error('Method "sort" must be implemented.');
        }
        async add() {
          throw new Error('Method "add" must be implemented.');
        }
        async save() {
          throw new Error('Method "save" must be implemented.');
        }
        async reject() {
          throw new Error('Method "reject" must be implemented.');
        }
        async delete() {
          throw new Error('Method "delete" must be implemented.');
        }
        getSortedData() {
          throw new Error('Method "getSortedData" must be implemented.');
        }
        updateTotalRowsInfo() {
          throw new Error('Method "updateTotalRowsInfo" must be implemented.');
        }
      };
      ClientSideHandler = class extends DataHandler {
        constructor(grid) {
          super(grid);
          __publicField(this, "sortedDataCache", null);
          __publicField(this, "sortCacheKey", null);
          this.grid.pagingMode = "client";
        }
        async load(data) {
          const { grid } = this;
          try {
            if (!Array.isArray(data)) {
              throw new SmartGridError("\uB370\uC774\uD130\uB294 \uBC30\uC5F4 \uD615\uC2DD\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.", "INVALID_DATA", grid.instanceId, { dataType: typeof data });
            }
            grid.info("\uB370\uC774\uD130 \uB85C\uB4DC \uC2DC\uC791", { rowCount: data.length });
            if (data.length > 1e4) {
              grid.warn("LARGE_DATASET", `\uB300\uC6A9\uB7C9 \uB370\uC774\uD130(${data.length}\uD589)\uAC00 \uB85C\uB4DC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
            }
            let processedData = deepClone(data);
            if (grid.options.loadFilter) {
              processedData = grid.options.loadFilter(processedData);
            }
            processedData.forEach((row) => grid.applyFormula(row));
            grid.originalData = processedData;
            grid.originalDataBackup = deepClone(grid.originalData);
            grid.totalRows = grid.originalData.length;
            grid.currentPage = 1;
            this.sortedDataCache = null;
            this.sortCacheKey = null;
            if (grid.options.isEditMode) {
              grid.isEditMode = true;
            }
            this.page();
            grid.emit("afterLoad", { data: grid.originalData, totalRows: grid.totalRows });
            grid.options.onLoadSuccess?.(grid.originalData, grid.totalRows, grid);
            return grid.originalData;
          } catch (error) {
            grid.handleError(error, "loadData");
            grid.emit("loadError", { error });
            grid.options.onLoadError?.(error, grid);
            grid.originalData = [];
            grid.totalRows = 0;
            this.sortedDataCache = null;
            this.sortCacheKey = null;
            this.page();
            throw error;
          }
        }
        page() {
          const { grid } = this;
          const sortedData = this.getSortedData();
          grid.totalRows = sortedData.length;
          const startIndex = (grid.currentPage - 1) * grid.pageSize;
          const endIndex = startIndex + grid.pageSize;
          grid.currentPageData = sortedData.slice(startIndex, endIndex);
          if (grid.currentPageData.length === 0 && grid.totalRows > 0) {
            grid.currentPage = Math.ceil(grid.totalRows / grid.pageSize) || 1;
            return this.page();
          }
          grid.renderGrid();
          grid.columns.forEach((col) => grid.updateSortIndicator(col.field));
          grid.renderPagination();
          this.updateTotalRowsInfo();
        }
        sort() {
          this.invalidateSortCache();
          this.grid.currentPage = 1;
          this.page();
          this.grid.columns.forEach((col) => this.grid.updateSortIndicator(col.field));
        }
        add() {
          const { grid } = this;
          if (grid.isEditMode) {
            grid.showToast("\uC218\uC815 \uBAA8\uB4DC\uC5D0\uC11C\uB294 \uD589\uC744 \uCD94\uAC00\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uBA3C\uC800 \uC800\uC7A5\uD558\uAC70\uB098 \uCDE8\uC18C\uD574\uC8FC\uC138\uC694.", "warning");
            return;
          }
          if (grid.changedRows.newRows.length > 0) {
            grid.showToast("\uBA3C\uC800 \uCD94\uAC00\uB41C \uD589\uC744 \uC800\uC7A5\uD574\uC8FC\uC138\uC694.", "warning");
            return;
          }
          grid.emit("beforeRowAdd", { cancelled: false });
          if (!grid.originalDataBackup || grid.originalDataBackup.length === 0) {
            grid.originalDataBackup = deepClone(grid.originalData);
          }
          const newRow = grid.columns.reduce(
            (acc, col, index) => {
              if (col.formula) {
                acc[col.field] = grid.evaluateFormula(col.formula, acc, index);
              } else {
                const rawDefaultVal = col.editor?.defaultVal;
                let defaultValue;
                if (typeof rawDefaultVal === "function") {
                  try {
                    defaultValue = rawDefaultVal(col, grid);
                  } catch (e) {
                    console.error(`defaultVal \uD568\uC218 \uC2E4\uD589 \uC911 \uC624\uB958 (\uD544\uB4DC: ${col.field}):`, e);
                    defaultValue = void 0;
                  }
                }
                if (defaultValue === void 0 && (col.editor?.type === "selectbox" || col.editor?.type === "radiobutton") && Array.isArray(col.editor.options) && col.editor.options.length > 0) {
                  defaultValue = col.editor.options[0].val;
                }
                acc[col.field] = defaultValue ?? "";
              }
              return acc;
            },
            { [grid.idField]: `new_${Date.now()}` }
          );
          grid.originalData.unshift(newRow);
          grid.changedRows.newRows.push(newRow);
          this.invalidateSortCache();
          grid.currentPage = 1;
          this.page();
          grid.emit("afterRowAdd", { row: newRow });
          grid.showToast("\uC0C8 \uD589\uC774 \uCD94\uAC00\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "success");
        }
        async save() {
          const { grid } = this;
          if (!grid.validateChanges()) return;
          const { newRows, updatedRows, deletedRows } = grid.changedRows;
          if (newRows.length === 0 && updatedRows.length === 0 && deletedRows.length === 0) {
            grid.showToast("\uBCC0\uACBD\uB41C \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.", "info");
            return;
          }
          const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
          grid.emit("beforeSave", beforeEvent);
          if (beforeEvent.cancelled) return;
          try {
            grid.showToast(`\uCD1D ${newRows.length}\uAC1C \uCD94\uAC00, ${updatedRows.length}\uAC1C \uC218\uC815, ${deletedRows.length}\uAC1C \uC0AD\uC81C \uC644\uB8CC`, "success");
            grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
            grid.originalDataBackup = [];
            grid.emit("afterSave", { changes: beforeEvent.changes });
            if (grid.isEditMode) {
              grid.setEditMode(false);
            } else {
              grid.renderGrid();
            }
          } catch (error) {
            grid.emit("saveError", { error, changes: grid.changedRows });
            grid.showToast("\uC800\uC7A5\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.", "error");
          }
        }
        async reject() {
          const { grid } = this;
          grid.showConfirmModal("\uBAA8\uB4E0 \uBCC0\uACBD \uC0AC\uD56D\uC744 \uCDE8\uC18C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?", (confirmed) => {
            if (confirmed) {
              const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
              grid.emit("beforeCancel", beforeEvent);
              if (beforeEvent.cancelled) return;
              if (grid.originalDataBackup && grid.originalDataBackup.length > 0) {
                grid.originalData = deepClone(grid.originalDataBackup);
              }
              grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
              grid.originalDataBackup = [];
              if (grid.isEditMode) {
                grid.isEditMode = false;
              }
              this.invalidateSortCache();
              this.page();
              grid.emit("afterCancel", {});
              grid.showToast("\uBAA8\uB4E0 \uBCC0\uACBD \uC0AC\uD56D\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "info");
            }
          });
        }
        async delete() {
          const { grid } = this;
          const selectedRows = grid.currentPageData.filter((row) => row.checked);
          if (selectedRows.length === 0) {
            grid.showToast("\uC0AD\uC81C\uD560 \uD589\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.", "warning");
            return;
          }
          grid.showConfirmModal(`\uC120\uD0DD\uB41C ${selectedRows.length}\uAC1C\uC758 \uD589\uC744 \uC989\uC2DC \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C? (\uC774 \uC791\uC5C5\uC740 \uB418\uB3CC\uB9B4 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4)`, (confirmed) => {
            if (confirmed) {
              const beforeEvent = { rows: [...selectedRows], cancelled: false };
              grid.emit("beforeRowDelete", beforeEvent);
              if (beforeEvent.cancelled) return;
              const selectedIds = new Set(selectedRows.map((row) => row[grid.idField]));
              grid.changedRows.newRows = grid.changedRows.newRows.filter((r) => !selectedIds.has(r[grid.idField]));
              grid.changedRows.updatedRows = grid.changedRows.updatedRows.filter((r) => !selectedIds.has(r[grid.idField]));
              grid.originalData = grid.originalData.filter((r) => !selectedIds.has(r[grid.idField]));
              this.invalidateSortCache();
              this.page();
              grid.emit("afterRowDelete", { rows: selectedRows });
              grid.showToast(`${selectedRows.length}\uAC1C\uC758 \uD589\uC774 \uC0AD\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`, "success");
            }
          });
        }
        getSortedData() {
          const { grid } = this;
          const sortKey = JSON.stringify(grid.sortOrders);
          const cacheKey = sortKey;
          if (this.sortCacheKey === cacheKey && this.sortedDataCache) {
            return [...this.sortedDataCache];
          }
          let dataToProcess = [...grid.originalData];
          if (grid.sortOrders.length > 0) {
            dataToProcess.sort(grid.compareRowsForSort.bind(grid));
          }
          this.sortedDataCache = dataToProcess;
          this.sortCacheKey = cacheKey;
          return [...dataToProcess];
        }
        updateTotalRowsInfo() {
          const { grid } = this;
          if (!grid.options.enableTotalRows || !grid.totalRowsElement) return;
          const totalCount = grid.originalData.length;
          grid.totalRowsElement.textContent = `\uC804\uCCB4 \uB370\uC774\uD130: ${totalCount}\uAC1C`;
        }
        invalidateSortCache() {
          this.sortedDataCache = null;
          this.sortCacheKey = null;
        }
      };
      ServerSideHandler = class extends DataHandler {
        constructor(grid) {
          super(grid);
          this.grid.pagingMode = "server";
          if (!this.grid.options.url) {
            throw new SmartGridError("\uC11C\uBC84 URL\uC774 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.", "INVALID_DATA", this.grid.instanceId);
          }
        }
        async load() {
          const { grid } = this;
          grid.showLoading();
          try {
            const beforeEvent = { params: grid.lastParams, cancelled: false };
            grid.emit("beforeLoad", beforeEvent);
            if (beforeEvent.cancelled) return;
            const requestParams = {
              // 1. 정적 쿼리 파라미터 (search_status: '대기' 등의 기본값 설정)
              ...grid.options.queryParams,
              // 2. 현재 그리드 상태 (페이징/정렬. queryParams의 page/pageSize/sortOrders를 덮어씀)
              page: grid.currentPage,
              pageSize: grid.pageSize,
              sortOrders: grid.sortOrders,
              // 3. 동적 파라미터 (툴바 필터 또는 fetchData 인자. 1, 2를 모두 덮어쓰며 가장 높은 우선순위를 가짐)
              ...grid.lastParams
            };
            const response = await fetch(grid.options.url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(requestParams)
            });
            if (!response.ok) {
              throw new SmartGridError(`\uC11C\uBC84 \uC751\uB2F5 \uC624\uB958: ${response.status} ${response.statusText}`, "INVALID_DATA", grid.instanceId);
            }
            const result = await response.json();
            if (!result.success) {
              throw new SmartGridError(result.error || "\uC11C\uBC84 \uCC98\uB9AC \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.", "INVALID_DATA", grid.instanceId);
            }
            const processedData = grid.options.loadFilter ? grid.options.loadFilter(result) : result;
            const rows = processedData.rows ?? processedData.data ?? (Array.isArray(processedData) ? processedData : []);
            const total = processedData.total ?? processedData.count ?? rows.length;
            rows.forEach((row) => grid.applyFormula(row));
            grid.originalData = rows;
            grid.totalRows = total;
            grid.currentPageData = rows;
            grid.renderGrid();
            grid.renderPagination();
            this.updateTotalRowsInfo();
            grid.columns.forEach((col) => grid.updateSortIndicator(col.field));
            grid.emit("afterLoad", { data: rows, totalRows: total });
            grid.options.onLoadSuccess?.(rows, total, grid);
            return rows;
          } catch (error) {
            grid.handleError(error, "fetchData");
            grid.emit("loadError", { error });
            grid.options.onLoadError?.(error, grid);
            grid.renderGrid();
            throw error;
          } finally {
            await new Promise((resolve) => setTimeout(resolve, 300));
            grid.hideLoading();
          }
        }
        async page() {
          await this.load();
        }
        async add() {
          const { grid } = this;
          if (grid.isEditMode) {
            grid.showToast("\uC218\uC815 \uBAA8\uB4DC\uC5D0\uC11C\uB294 \uD589\uC744 \uCD94\uAC00\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uBA3C\uC800 \uC800\uC7A5\uD558\uAC70\uB098 \uCDE8\uC18C\uD574\uC8FC\uC138\uC694.", "warning");
            return;
          }
          if (grid.changedRows.newRows.length > 0) {
            grid.showToast("\uBA3C\uC800 \uCD94\uAC00\uB41C \uD589\uC744 \uC800\uC7A5\uD574\uC8FC\uC138\uC694.", "warning");
            return;
          }
          const beforeEvent = { cancelled: false };
          grid.emit("beforeRowAdd", beforeEvent);
          if (beforeEvent.cancelled) return;
          const newRow = grid.columns.reduce(
            (acc, col) => {
              if (col.formula) {
                acc[col.field] = grid.evaluateFormula(col.formula, acc, col);
              } else {
                const rawDefaultVal = col.editor?.defaultVal;
                let defaultValue;
                if (typeof rawDefaultVal === "function") {
                  try {
                    defaultValue = rawDefaultVal(col, this.grid);
                  } catch (e) {
                    console.error(`defaultVal \uD568\uC218 \uC2E4\uD589 \uC911 \uC624\uB958 (\uD544\uB4DC: ${col.field}):`, e);
                    defaultValue = void 0;
                  }
                }
                if (defaultValue === void 0 && (col.editor?.type === "selectbox" || col.editor?.type === "radiobutton") && Array.isArray(col.editor.options) && col.editor.options.length > 0) {
                  defaultValue = col.editor.options[0].val;
                }
                acc[col.field] = defaultValue ?? "";
              }
              return acc;
            },
            { [grid.idField]: `new_${Date.now()}` }
          );
          grid.currentPageData.unshift(newRow);
          grid.changedRows.newRows.push(newRow);
          grid.renderGrid();
          grid.emit("afterRowAdd", { row: newRow });
          grid.showToast("\uC0C8 \uD589\uC774 \uCD94\uAC00\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uC800\uC7A5 \uC2DC \uC11C\uBC84\uC5D0 \uBC18\uC601\uB429\uB2C8\uB2E4.", "success");
        }
        async sort() {
          this.grid.currentPage = 1;
          await this.load();
        }
        async save() {
          const { grid } = this;
          const context = "saveToServer";
          try {
            const { newRows, updatedRows, deletedRows } = grid.changedRows;
            if (newRows.length === 0 && updatedRows.length === 0 && deletedRows.length === 0) {
              grid.showToast("\uBCC0\uACBD\uB41C \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.", "info");
              return;
            }
            if (!grid.validateChanges()) return;
            const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
            grid.emit("beforeSave", beforeEvent);
            if (beforeEvent.cancelled) return;
            grid.showLoading();
            const results = { inserted: 0, updated: 0, deleted: 0, errors: [] };
            const { writeUrl, updateUrl, deleteUrl } = grid.options;
            if (newRows.length > 0 && writeUrl) {
              try {
                const res = await this.sendRequest(writeUrl, newRows);
                results.inserted = res.inserted ?? newRows.length;
              } catch (error) {
                results.errors.push({ type: "insert", error: error.message });
              }
            }
            if (updatedRows.length > 0 && updateUrl) {
              try {
                const res = await this.sendRequest(updateUrl, updatedRows);
                results.updated = res.updated ?? updatedRows.length;
                grid.isEditMode = false;
              } catch (error) {
                results.errors.push({ type: "update", error: error.message });
              }
            }
            if (deletedRows.length > 0 && deleteUrl) {
              try {
                const ids = deletedRows.map((row) => row[grid.idField]);
                const res = await this.sendRequest(deleteUrl, ids);
                results.deleted = res.deleted ?? deletedRows.length;
              } catch (error) {
                results.errors.push({ type: "delete", error: error.message });
              }
            }
            grid.hideLoading();
            if (results.errors.length > 0) {
              const errorMessages = results.errors.map((e) => `${e.type}: ${e.error}`).join("\n");
              grid.showToast(`\uC77C\uBD80 \uC791\uC5C5\uC774 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.
${errorMessages}`, "error");
              grid.emit("saveError", { results });
            } else {
              grid.showToast(`\uCD1D ${results.inserted}\uAC1C \uCD94\uAC00, ${results.updated}\uAC1C \uC218\uC815, ${results.deleted}\uAC1C \uC0AD\uC81C \uC644\uB8CC`, "success");
              grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
              grid.originalDataBackup = [];
              grid.emit("afterSave", { results });
              await this.load();
            }
          } catch (error) {
            grid.handleError(error, context);
            grid.emit("saveError", { error });
            grid.showToast("\uC800\uC7A5\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.", "error");
          }
        }
        async sendRequest(url, body) {
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
          });
          if (!response.ok) throw new Error(`Request failed with status ${response.status}`);
          const result = await response.json();
          if (!result.success) throw new Error(result.error || "Request failed");
          return result;
        }
        async reject() {
          const { grid } = this;
          grid.showConfirmModal("\uBAA8\uB4E0 \uBCC0\uACBD \uC0AC\uD56D\uC744 \uCDE8\uC18C\uD558\uACE0 \uC11C\uBC84\uC5D0\uC11C \uB370\uC774\uD130\uB97C \uB2E4\uC2DC \uBD88\uB7EC\uC624\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?", (confirmed) => {
            if (confirmed) {
              const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
              grid.emit("beforeCancel", beforeEvent);
              if (beforeEvent.cancelled) return;
              grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
              grid.originalDataBackup = [];
              if (grid.isEditMode) {
                grid.isEditMode = false;
              }
              this.load();
              grid.emit("afterCancel", {});
              grid.showToast("\uBAA8\uB4E0 \uBCC0\uACBD \uC0AC\uD56D\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "info");
            }
          });
        }
        async delete() {
          const { grid } = this;
          const selectedRows = grid.currentPageData.filter((row) => row.checked);
          if (selectedRows.length === 0) {
            grid.showToast("\uC0AD\uC81C\uD560 \uD589\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.", "warning");
            return;
          }
          grid.showConfirmModal(`\uC120\uD0DD\uB41C ${selectedRows.length}\uAC1C\uC758 \uD589\uC744 \uC11C\uBC84\uC5D0\uC11C \uC989\uC2DC \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C? (\uC774 \uC791\uC5C5\uC740 \uB418\uB3CC\uB9B4 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4)`, async (confirmed) => {
            if (confirmed) {
              const beforeEvent = { rows: [...selectedRows], cancelled: false };
              grid.emit("beforeRowDelete", beforeEvent);
              if (beforeEvent.cancelled) return;
              const idsToDelete = selectedRows.map((row) => row[grid.idField]);
              if (!grid.options.deleteUrl) {
                grid.showToast("\uC0AD\uC81C\uB97C \uCC98\uB9AC\uD560 \uC11C\uBC84 URL\uC774 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.", "error");
                return;
              }
              grid.showLoading();
              try {
                const response = await fetch(grid.options.deleteUrl, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ ids: idsToDelete })
                });
                if (!response.ok) {
                  throw new Error(`\uC11C\uBC84 \uC751\uB2F5 \uC624\uB958: ${response.status}`);
                }
                const result = await response.json();
                if (result.success) {
                  grid.showToast(`${result.deleted}\uAC1C\uC758 \uD589\uC774 \uC131\uACF5\uC801\uC73C\uB85C \uC0AD\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`, "success");
                  grid.emit("afterRowDelete", { rows: selectedRows, result });
                  await this.load();
                } else {
                  throw new Error(result.error || "\uC11C\uBC84\uC5D0\uC11C \uC0AD\uC81C \uCC98\uB9AC\uB97C \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.");
                }
              } catch (error) {
                grid.handleError(error, "immediateDelete");
                grid.showToast("\uC0AD\uC81C \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.", "error");
              } finally {
                grid.hideLoading();
              }
            }
          });
        }
        getSortedData() {
          return [...this.grid.currentPageData];
        }
        updateTotalRowsInfo() {
          const { grid } = this;
          if (!grid.options.enableTotalRows || !grid.totalRowsElement) return;
          grid.totalRowsElement.textContent = `\uC804\uCCB4 \uB370\uC774\uD130: ${grid.totalRows}\uAC1C`;
        }
      };
    }
  });

  // core/InputFactory.js
  var InputFactory;
  var init_InputFactory = __esm({
    "core/InputFactory.js"() {
      InputFactory = class {
        constructor(grid) {
          this.grid = grid;
          this.selectOptionCache = /* @__PURE__ */ new Map();
          this.inputConfigs = {
            textbox: { type: "text", class: "smartgrid-input smartgrid-input-text" },
            email: { type: "email", class: "smartgrid-input smartgrid-input-email" },
            // password: { type: 'password', class: 'smartgrid-input smartgrid-input-password' },
            // tel: { type: 'tel', class: 'smartgrid-input smartgrid-input-tel' },
            // url: { type: 'url', class: 'smartgrid-input smartgrid-input-url' },
            // 'datetime-local': { type: 'datetime-local', class: 'smartgrid-input smartgrid-input-datetime' },
            // month: { type: 'month', class: 'smartgrid-input smartgrid-input-month' },
            // week: { type: 'week', class: 'smartgrid-input smartgrid-input-week' },
            // time: { type: 'time', class: 'smartgrid-input smartgrid-input-time' },
            datebox: { type: "date", class: "smartgrid-input smartgrid-input-date" }
            // color: { type: 'color', class: 'smartgrid-input smartgrid-input-color' },
          };
          this.creators = {
            numberbox: this.createNumberInput.bind(this),
            checkbox: this.createCheckboxInput.bind(this),
            selectbox: this.createSelectInput.bind(this),
            radiobutton: this.createRadioInput.bind(this)
            // textarea: this.createTextareaInput.bind(this),
            // range: this.createRangeInput.bind(this),
          };
          Object.keys(this.inputConfigs).forEach((type) => {
            this.creators[type] = (col, row, val) => this.createStandardInput(type, col, row, val);
          });
        }
        /**
         * 입력 요소 생성
         * @param {Object} column - 컬럼 정의
         * @param {Object} rowData - 행 데이터
         * @param {any} value - 값
         * @returns {HTMLElement} 생성된 입력 요소
         */
        create(column, rowData, value) {
          const editorType = column.editor.type || "textbox";
          const creator = this.creators[editorType];
          if (!creator) {
            console.warn(`'${editorType}' \uD0C0\uC785\uC758 \uC5D0\uB514\uD130\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC5B4 textbox\uB85C \uB300\uCCB4\uD569\uB2C8\uB2E4.`);
            return this.createStandardInput("textbox", column, rowData, value);
          }
          return creator(column, rowData, value);
        }
        /**
         * 공통 속성 적용
         * @param {HTMLElement} input - 입력 요소
         * @param {Object} column - 컬럼 정의
         */
        CommonAttributes(input, column) {
          const { editor } = column;
          if (editor.placeholder) input.placeholder = editor.placeholder;
          if (editor.required) input.required = editor.required;
          if (editor.multiple) input.multiple = editor.multiple;
          if (editor.disabled) input.disabled = editor.disabled;
          if (editor.readonly) input.readOnly = editor.readonly;
        }
        // ... (InputFactory 클래스 내부)
        getDefault(column, rowData, value) {
          const ed = column.editor;
          let def = "";
          if (typeof ed.defaultVal === "function") {
            def = ed.defaultVal(column, this.grid) ?? "";
          } else if (ed.defaultVal !== void 0 && ed.defaultVal !== null) {
            def = ed.defaultVal;
          }
          let finalValue = value !== null && value !== void 0 && value !== "" ? value : def;
          if (column.formula && (finalValue === null || finalValue === void 0 || finalValue === isNaN)) {
            if (ed.type === "numberbox" || typeof column.formula === "function") {
              finalValue = 0;
            } else {
              finalValue = "";
            }
          }
          return finalValue;
        }
        // ... (이하 동일)
        /**
         * 표준 입력 요소 생성
         * @param {string} editorType - 에디터 타입
         * @param {Object} column - 컬럼 정의
         * @param {Object} rowData - 행 데이터
         * @param {any} value - 값
         * @returns {HTMLElement} 생성된 입력 요소
         */
        createStandardInput(editorType, column, rowData, value) {
          const config = this.inputConfigs[editorType];
          const input = document.createElement("input");
          input.type = config.type;
          input.value = value ?? "";
          input.className = config.class;
          input.setAttribute("data-editor-type", editorType);
          this.CommonAttributes(input, column);
          const v = this.getDefault(column, rowData, value);
          input.value = v;
          rowData[column.field] = v;
          return input;
        }
        /**
         * 숫자 입력 요소 생성
         */
        createNumberInput(column, rowData, value) {
          const input = document.createElement("input");
          input.type = "number";
          input.step = "any";
          const decimalPlaces = column.editor.decimalPlaces ?? 0;
          const formattedValue = value !== null && value !== void 0 && value !== "" ? Number(value).toFixed(decimalPlaces) : 0;
          input.value = formattedValue;
          input.className = "smartgrid-input smartgrid-input-number";
          if (column.editor.min !== void 0) input.min = column.editor.min;
          if (column.editor.max !== void 0) input.max = column.editor.max;
          if (column.editor.step !== void 0) input.step = column.editor.step;
          input.setAttribute("data-editor-type", "numberbox");
          this.CommonAttributes(input, column);
          const v = this.getDefault(column, rowData, value);
          input.value = v !== "" ? Number(v) : "";
          rowData[column.field] = input.value;
          return input;
        }
        /**
         * 체크박스 입력 요소 생성
         */
        createCheckboxInput(column, rowData, value) {
          const container = document.createElement("div");
          container.className = "smartgrid-d-flex smartgrid-justify-content-center smartgrid-align-items-center";
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "smartgrid-input-checkbox";
          checkbox.setAttribute("data-editor-type", "checkbox");
          this.CommonAttributes(checkbox, column);
          const v = this.getDefault(column, rowData, value);
          checkbox.checked = !!v;
          rowData[column.field] = checkbox.checked ? 1 : 0;
          container.appendChild(checkbox);
          return container;
        }
        /**
         * 셀렉트 박스 생성
         * [변경] editor.valueField, editor.textField를 지원하도록 수정
         */
        createSelectInput(column, rowData, value) {
          const select = document.createElement("select");
          select.className = "smartgrid-input-select";
          select.setAttribute("data-editor-type", "selectbox");
          this.CommonAttributes(select, column);
          const editorConfig = column.editor;
          const valueField = editorConfig.valueField || "value";
          const textField = editorConfig.textField || "text";
          const url = editorConfig.url;
          let def = "";
          if (typeof editorConfig.defaultVal === "function") {
            def = editorConfig.defaultVal(column, this.grid) ?? "";
          } else if (editorConfig.defaultVal !== void 0 && editorConfig.defaultVal !== null) {
            def = editorConfig.defaultVal;
          }
          const applyFinalValue = (optList) => {
            const firstVal = optList.length > 0 ? optList[0][valueField] : "";
            const final = value !== null && value !== void 0 && value !== "" ? value : def !== "" ? def : firstVal;
            select.value = final;
            rowData[column.field] = select.value;
          };
          const createOptions = (data) => {
            select.innerHTML = "";
            if (!Array.isArray(data)) throw new Error(`URL(${url})\uC740 \uBC30\uC5F4\uC744 \uBC18\uD658\uD574\uC57C \uD569\uB2C8\uB2E4.`);
            data.forEach((item) => {
              const opt = document.createElement("option");
              opt.value = item[valueField];
              opt.textContent = item[textField];
              select.appendChild(opt);
            });
            return data;
          };
          if (url && typeof url === "string") {
            select.disabled = true;
            select.innerHTML = "<option>\uB85C\uB529 \uC911...</option>";
            let fetchPromise = this.selectOptionCache.get(url);
            if (!fetchPromise) {
              fetchPromise = fetch(url).then((res) => {
                if (!res.ok) throw new Error(`Selectbox \uC635\uC158 \uB85C\uB4DC \uC2E4\uD328: ${res.status}`);
                return res.json();
              }).catch((err) => {
                this.selectOptionCache.delete(url);
                throw err;
              });
              this.selectOptionCache.set(url, fetchPromise);
            }
            fetchPromise.then(createOptions).then((data) => {
              applyFinalValue(data);
              select.disabled = false;
            }).catch((err) => {
              this.grid?.handleError?.(err, `createSelectInput.fetch(${url})`);
              select.innerHTML = "<option>\uB85C\uB4DC \uC2E4\uD328</option>";
            });
            return select;
          }
          if (Array.isArray(editorConfig.options)) {
            const opts = editorConfig.options;
            opts.forEach((option) => {
              const opt = document.createElement("option");
              opt.value = option[valueField];
              opt.textContent = option[textField];
              select.appendChild(opt);
            });
            applyFinalValue(opts);
            return select;
          }
          select.innerHTML = "<option>\uC635\uC158 \uC5C6\uC74C</option>";
          return select;
        }
        /* ... InputFactory 클래스의 다른 메서드들 ... */
        /**
         * 라디오 버튼 생성
         */
        createRadioInput(column, rowData, value) {
          const container = document.createElement("div");
          container.className = "smartgrid-d-flex smartgrid-align-items-center";
          container.style.cssText = "height: 100%; justify-content: flex-start; padding: 0 8px; flex-wrap: wrap;";
          const name = `radio_${column.field}_${rowData[this.grid.idField]}`;
          (column.editor.options || []).forEach((option) => {
            const radioId = `${name}_${option.val}`;
            const radioDiv = document.createElement("div");
            radioDiv.style.cssText = "display: inline-flex; align-items: center; margin-right: 12px; margin: 0;";
            const radio = document.createElement("input");
            radio.type = "radio";
            radio.id = radioId;
            radio.name = name;
            radio.value = option.val;
            radio.className = "smartgrid-input-radio";
            radio.checked = String(option.val) === String(value);
            radio.setAttribute("data-editor-type", "radiobutton");
            this.CommonAttributes(radio, column);
            const label = document.createElement("label");
            label.className = "smartgrid-input-radio-label";
            label.setAttribute("for", radioId);
            label.textContent = option.text;
            radioDiv.appendChild(radio);
            radioDiv.appendChild(label);
            container.appendChild(radioDiv);
          });
          return container;
        }
        /**
         * 텍스트 영역 생성
         */
        createTextareaInput(column, rowData, value) {
          const textarea = document.createElement("textarea");
          textarea.value = value ?? "";
          textarea.className = "smartgrid-input-textarea";
          textarea.style.cssText = "width: 100%; box-sizing: border-box; resize: none;";
          textarea.style.height = `calc(var(--row-height, 30px) - 8px)`;
          textarea.setAttribute("data-editor-type", "textarea");
          this.CommonAttributes(textarea, column);
          const v = this.getDefault(column, rowData, value);
          textarea.value = v;
          rowData[column.field] = v;
          textarea.addEventListener("input", () => {
            rowData[column.field] = textarea.value;
          });
          return textarea;
        }
        /**
         * 범위 입력 요소 생성
         */
        createRangeInput(column, rowData, value) {
          const input = document.createElement("input");
          input.type = "range";
          input.value = value ?? "0";
          input.className = "smartgrid-input-range";
          input.style.width = "100%";
          if (column.editor.min !== void 0) input.min = column.editor.min;
          if (column.editor.max !== void 0) input.max = column.editor.max;
          if (column.editor.step !== void 0) input.step = column.editor.step;
          input.setAttribute("data-editor-type", "range");
          this.CommonAttributes(input, column);
          return input;
        }
      };
    }
  });

  // core/UIComponents.js
  var UIComponents;
  var init_UIComponents = __esm({
    "core/UIComponents.js"() {
      init_utils();
      UIComponents = class {
        constructor(grid) {
          this.grid = grid;
          this.toastElement = null;
          this.modalElement = null;
          this.contextMenuElement = null;
          this.columnPanelElement = null;
          this.loaderElement = null;
          this.paginationElement = null;
        }
        /**
         * 모든 UI 컴포넌트 생성
         */
        createAll() {
          this.createToast();
          this.createModal();
          this.createContextMenu();
          this.createLoader();
          this.createColumnPanel();
          if (this.grid.options.enablePagination) {
            this.createPagination();
          }
        }
        // ========== Toast ==========
        createToast() {
          const toast = document.createElement("div");
          toast.id = `${this.grid.instanceId}_toast`;
          toast.className = "smartgrid-toast";
          toast.setAttribute("data-instance", this.grid.instanceId);
          toast.innerHTML = `
      <div class="smartgrid-toast-header" data-instance="${this.grid.instanceId}">
        <div class="smartgrid-toast-icon" id="${this.grid.instanceId}_toastIcon"></div>
        <div class="smartgrid-toast-title" id="${this.grid.instanceId}_toastTitle">\uC54C\uB9BC</div>
        <button class="smartgrid-toast-close" data-instance="${this.grid.instanceId}">&times;</button>
      </div>
      <div class="smartgrid-toast-body" id="${this.grid.instanceId}_toastBody"></div>
    `;
          document.body.appendChild(toast);
          this.toastElement = toast;
          this.toastTimer = null;
        }
        showToast(message, type = "info") {
          const toastElement = this.toastElement;
          if (!toastElement) return;
          const icon = toastElement.querySelector(`#${this.grid.instanceId}_toastIcon`);
          const title = toastElement.querySelector(`#${this.grid.instanceId}_toastTitle`);
          const body = toastElement.querySelector(`#${this.grid.instanceId}_toastBody`);
          const closeBtn = toastElement.querySelector(`.smartgrid-toast-close[data-instance="${this.grid.instanceId}"]`);
          const allTypes = ["info", "success", "error", "warning"];
          toastElement.classList.remove(...allTypes);
          toastElement.classList.add(type);
          icon.className = `smartgrid-toast-icon ${type}`;
          title.textContent = type.charAt(0).toUpperCase() + type.slice(1);
          body.textContent = message;
          if (this.toastTimer) {
            clearTimeout(this.toastTimer);
          }
          toastElement.classList.add("show");
          const handleClose = () => {
            toastElement.classList.remove("show");
            closeBtn.removeEventListener("click", handleClose);
            this.toastTimer = null;
            setTimeout(() => toastElement.classList.remove(type), 300);
          };
          closeBtn.addEventListener("click", handleClose);
          this.toastTimer = setTimeout(handleClose, 3e3);
        }
        // ========== Modal ==========
        createModal() {
          const modal = document.createElement("div");
          modal.id = `${this.grid.instanceId}_modal`;
          modal.className = "smartgrid-modal";
          modal.setAttribute("data-instance", this.grid.instanceId);
          modal.innerHTML = `
      <div class="smartgrid-modal-backdrop" data-instance="${this.grid.instanceId}"></div>
      <div class="smartgrid-modal-content" data-instance="${this.grid.instanceId}">
        <div class="smartgrid-modal-header">
          <h5 class="smartgrid-modal-title">\uD655\uC778</h5>
          <button class="smartgrid-modal-close" data-instance="${this.grid.instanceId}">&times;</button>
        </div>
        <div class="smartgrid-modal-body">
          <p id="${this.grid.instanceId}_modalText"></p>
        </div>
        <div class="smartgrid-modal-footer">
          <button class="smartgrid-btn smartgrid-btn-secondary" data-dismiss="modal" data-instance="${this.grid.instanceId}">\uCDE8\uC18C</button>
          <button class="smartgrid-btn smartgrid-btn-primary" id="${this.grid.instanceId}_modalConfirm" data-instance="${this.grid.instanceId}">\uD655\uC778</button>
        </div>
      </div>
    `;
          document.body.appendChild(modal);
          this.modalElement = modal;
        }
        showConfirmModal(message, callback) {
          const modalElement = this.modalElement;
          if (!modalElement) return;
          const modalText = modalElement.querySelector(`#${this.grid.instanceId}_modalText`);
          const confirmBtn = modalElement.querySelector(`#${this.grid.instanceId}_modalConfirm`);
          const cancelBtns = modalElement.querySelectorAll(`[data-dismiss="modal"][data-instance="${this.grid.instanceId}"]`);
          const closeBtn = modalElement.querySelector(`.smartgrid-modal-close[data-instance="${this.grid.instanceId}"]`);
          const backdrop = modalElement.querySelector(`.smartgrid-modal-backdrop[data-instance="${this.grid.instanceId}"]`);
          modalText.textContent = message;
          modalElement.classList.add("show");
          const handleConfirm = () => {
            callback(true);
            modalElement.classList.remove("show");
            cleanup();
          };
          const handleCancel = () => {
            callback(false);
            modalElement.classList.remove("show");
            cleanup();
          };
          const cleanup = () => {
            confirmBtn.removeEventListener("click", handleConfirm);
            cancelBtns.forEach((btn) => btn.removeEventListener("click", handleCancel));
            closeBtn?.removeEventListener("click", handleCancel);
            backdrop?.removeEventListener("click", handleCancel);
          };
          confirmBtn.addEventListener("click", handleConfirm);
          cancelBtns.forEach((btn) => btn.addEventListener("click", handleCancel));
          closeBtn?.addEventListener("click", handleCancel);
          backdrop?.addEventListener("click", handleCancel);
        }
        // ========== ContextMenu ==========
        createContextMenu() {
          const menu = document.createElement("div");
          menu.id = `${this.grid.instanceId}_contextMenu`;
          menu.className = "smartgrid-context-menu";
          menu.setAttribute("data-instance", this.grid.instanceId);
          menu.innerHTML = `
      <div class="smartgrid-context-menu-item" data-action="copyCell" data-instance="${this.grid.instanceId}">\uC140 \uBCF5\uC0AC</div>
      <div class="smartgrid-context-menu-item" data-action="copyRow" data-instance="${this.grid.instanceId}">\uD589 \uBCF5\uC0AC</div>
      <div class="smartgrid-context-menu-divider"></div>
      <div class="smartgrid-context-menu-item" data-action="addRow" data-instance="${this.grid.instanceId}">\uD589 \uCD94\uAC00</div>
      <div class="smartgrid-context-menu-item" data-action="deleteRow" data-instance="${this.grid.instanceId}">\uD589 \uC0AD\uC81C</div>
      <div class="smartgrid-context-menu-divider"></div>
      <div class="smartgrid-context-menu-item" data-action="toggleColumns" data-instance="${this.grid.instanceId}">\uC5F4 \uD45C\uC2DC/\uC228\uAE40</div>
    `;
          document.body.appendChild(menu);
          this.contextMenuElement = menu;
        }
        showContextMenu(x, y, rowId, cellField) {
          const contextMenu = this.contextMenuElement;
          if (!contextMenu) return;
          contextMenu.style.display = "none";
          setTimeout(() => {
            contextMenu.style.display = "block";
            const isMobile = window.innerWidth < 768;
            if (isMobile) {
              contextMenu.classList.add("smartgrid-context-menu-mobile");
              contextMenu.style.left = "";
              contextMenu.style.top = "";
            } else {
              contextMenu.classList.remove("smartgrid-context-menu-mobile");
              const menuRect = contextMenu.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;
              let adjustedX = x;
              let adjustedY = y;
              if (x + menuRect.width > viewportWidth - 10) adjustedX = viewportWidth - menuRect.width - 10;
              if (y + menuRect.height > viewportHeight - 10) adjustedY = viewportHeight - menuRect.height - 10;
              if (adjustedX < 10) adjustedX = 10;
              if (adjustedY < 10) adjustedY = 10;
              contextMenu.style.left = `${adjustedX}px`;
              contextMenu.style.top = `${adjustedY}px`;
            }
            contextMenu.setAttribute("data-context-row-id", rowId);
            if (cellField) contextMenu.setAttribute("data-context-cell-field", cellField);
          }, 10);
        }
        hideContextMenu() {
          if (this.contextMenuElement) {
            this.contextMenuElement.style.display = "none";
          }
        }
        // ========== ColumnPanel ==========
        createColumnPanel() {
          const panel = document.createElement("div");
          panel.id = `${this.grid.instanceId}_columnPanel`;
          panel.className = "smartgrid-column-panel";
          panel.setAttribute("data-instance", this.grid.instanceId);
          panel.innerHTML = `
      <div class="smartgrid-column-panel-header">\uC5F4 \uD45C\uC2DC \uC124\uC815</div>
      <div class="smartgrid-column-panel-body" id="${this.grid.instanceId}_columnList"></div>
    `;
          document.body.appendChild(panel);
          this.columnPanelElement = panel;
        }
        toggleColumnVisibilityPanel() {
          const panel = this.columnPanelElement;
          if (!panel) return;
          const isActive = panel.classList.toggle("active");
          if (isActive) {
            const toggleButton = this.grid.wrapper.querySelector(`[data-action="toggleColumns"]`);
            if (toggleButton) {
              const rect = toggleButton.getBoundingClientRect();
              panel.style.left = `${rect.left}px`;
              panel.style.top = `${rect.bottom + 5}px`;
            }
            this.renderColumnVisibilityPanel();
          }
        }
        renderColumnVisibilityPanel() {
          const listContainer = this.columnPanelElement.querySelector(`#${this.grid.instanceId}_columnList`);
          if (!listContainer) return;
          listContainer.innerHTML = "";
          this.grid.columns.forEach((column) => {
            if (column.hideColumn) return;
            const item = document.createElement("div");
            item.className = "column-visibility-item";
            const checkboxId = `${this.grid.instanceId}_col_vis_${column.field}`;
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = checkboxId;
            checkbox.className = "smartgrid-input-checkbox";
            checkbox.checked = !this.grid.hiddenColumns.has(column.field);
            checkbox.addEventListener("change", (e) => {
              this.grid[e.target.checked ? "showColumn" : "hideColumn"](column.field);
            });
            const label = document.createElement("label");
            label.setAttribute("for", checkboxId);
            label.textContent = column.title;
            item.appendChild(checkbox);
            item.appendChild(label);
            listContainer.appendChild(item);
          });
        }
        // ========== Loader ==========
        createLoader() {
          const loader = document.createElement("div");
          loader.id = `${this.grid.instanceId}_loader`;
          loader.className = "smartgrid-skeleton-loader";
          loader.setAttribute("data-instance", this.grid.instanceId);
          loader.innerHTML = `
      <div class="smartgrid-skeleton-spinner"></div>
      <div class="smartgrid-skeleton-text">\uB370\uC774\uD130\uB97C \uBD88\uB7EC\uC624\uB294 \uC911...</div>
    `;
          document.body.appendChild(loader);
          this.loaderElement = loader;
        }
        showLoading() {
          this.loaderElement?.classList.add("active");
        }
        hideLoading() {
          this.loaderElement?.classList.remove("active");
        }
        // ========== Pagination ==========
        createPagination() {
          const pagination = document.createElement("div");
          pagination.id = `${this.grid.instanceId}_pagination`;
          pagination.className = "smartgrid-pagination";
          pagination.setAttribute("data-instance", this.grid.instanceId);
          this.grid.wrapper.appendChild(pagination);
          this.paginationElement = pagination;
        }
        renderPagination() {
          if (!this.grid.options.enablePagination || !this.paginationElement) return;
          this.paginationElement.innerHTML = "";
          if (this.grid.totalRows === 0) return;
          const totalPages = Math.ceil(this.grid.totalRows / this.grid.pageSize);
          const PAGINATION_GROUP_SIZE = 5;
          const currentGroup = Math.ceil(this.grid.currentPage / PAGINATION_GROUP_SIZE);
          const startPage = (currentGroup - 1) * PAGINATION_GROUP_SIZE + 1;
          const endPage = Math.min(totalPages, currentGroup * PAGINATION_GROUP_SIZE);
          const ul = document.createElement("ul");
          const fragment = document.createDocumentFragment();
          const prevPage = startPage - 1;
          fragment.appendChild(this.createPaginationButton('<i class="bi bi-chevron-double-left"></i>', prevPage, false, prevPage < 1));
          for (let page = startPage; page <= endPage; page++) {
            fragment.appendChild(this.createPaginationButton(page, page, page === this.grid.currentPage));
          }
          const nextPage = endPage + 1;
          fragment.appendChild(this.createPaginationButton('<i class="bi bi-chevron-double-right"></i>', nextPage, false, nextPage > totalPages));
          ul.appendChild(fragment);
          this.paginationElement.appendChild(ul);
        }
        createPaginationButton(content, page, isActive = false, isDisabled = false) {
          const li = document.createElement("li");
          li.className = "page-item";
          if (isActive) li.classList.add("active");
          if (isDisabled) li.classList.add("disabled");
          const button = document.createElement("button");
          button.classList.add("page-link");
          button.innerHTML = content;
          if (!isDisabled) {
            button.addEventListener("click", () => {
              this.grid.currentPage = page;
              this.grid.changePage();
            });
          }
          li.appendChild(button);
          return li;
        }
        /**
         * 모든 UI 컴포넌트 제거
         */
        destroyAll() {
          this.toastElement?.remove();
          this.modalElement?.remove();
          this.contextMenuElement?.remove();
          this.loaderElement?.remove();
          this.columnPanelElement?.remove();
          this.paginationElement?.remove();
          this.toastElement = null;
          this.modalElement = null;
          this.contextMenuElement = null;
          this.loaderElement = null;
          this.columnPanelElement = null;
          this.paginationElement = null;
        }
      };
    }
  });

  // core/GridRenderer.js
  var GridRenderer;
  var init_GridRenderer = __esm({
    "core/GridRenderer.js"() {
      init_utils();
      GridRenderer = class {
        constructor(grid) {
          this.grid = grid;
        }
        /**
         * 그리드 전체 렌더링
         */
        // GridRenderer.js의 renderGrid 메서드 수정
        renderGrid() {
          try {
            this.clearTable();
            this.grid.table.className = "smartgrid-table";
            this.grid.table.setAttribute("data-instance", this.grid.instanceId);
            this.createTableHead(this.grid.table);
            this.createTableBody(this.grid.table);
            this.createTableFooter(this.grid.table);
            this.grid.columns.forEach((col) => {
              if (col.sortable) {
                this.grid.updateSortIndicator(col.field);
              }
            });
          } catch (error) {
            this.grid.handleError(error, "renderGrid");
          }
        }
        // ========== 테이블 컬럼 그룹 ==========
        createColGroup(tableElement) {
          const colgroup = document.createElement("colgroup");
          if (this.grid.enableCheckboxColumn) {
            const colCheckbox = document.createElement("col");
            colCheckbox.className = "sg-col-checkbox";
            colCheckbox.style.width = "var(--sg-col-checkbox-width)";
            colgroup.appendChild(colCheckbox);
          }
          if (this.grid.enableIndexColumn) {
            const colIndex = document.createElement("col");
            colIndex.className = "sg-col-index";
            colIndex.style.width = "var(--sg-col-index-width)";
            colgroup.appendChild(colIndex);
          }
          this.grid.columns.forEach((column) => {
            if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;
            const col = document.createElement("col");
            col.className = "sg-col-data";
            col.setAttribute("data-field", column.field);
            if (column.width) {
              col.style.width = column.width;
            }
            colgroup.appendChild(col);
          });
          tableElement.appendChild(colgroup);
        }
        /**
         * 테이블 초기화
         */
        clearTable() {
          this.grid.table.replaceChildren();
        }
        // ========== 테이블 헤더 ==========
        createTableHead(tableElement) {
          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");
          this.addCheckboxHeader(headerRow);
          this.addIndexHeader(headerRow);
          this.addDataHeaders(headerRow);
          thead.appendChild(headerRow);
          tableElement.appendChild(thead);
        }
        addCheckboxHeader(headerRow) {
          if (!this.grid.enableCheckboxColumn) return;
          const th = document.createElement("th");
          th.classList.add("sg-col-checkbox");
          const masterCheckbox = document.createElement("input");
          masterCheckbox.type = "checkbox";
          masterCheckbox.classList.add("smartgrid-input-checkbox");
          const allRowsChecked = this.grid.currentPageData.length > 0 && this.grid.currentPageData.every((row) => row.checked);
          masterCheckbox.checked = allRowsChecked;
          th.appendChild(masterCheckbox);
          headerRow.appendChild(th);
        }
        addIndexHeader(headerRow) {
          if (!this.grid.enableIndexColumn) return;
          const th = document.createElement("th");
          th.classList.add("sg-col-index");
          const wrapperSpan = document.createElement("span");
          wrapperSpan.textContent = "\uBC88\uD638";
          th.appendChild(wrapperSpan);
          headerRow.appendChild(th);
        }
        addDataHeaders(headerRow) {
          this.grid.columns.forEach((column) => {
            if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;
            const th = document.createElement("th");
            th.style.width = column.width;
            const alignClass = `sg-align-${column.headAlign || "center"}`;
            th.classList.add(alignClass);
            const wrapperSpan = document.createElement("span");
            if (column.sortable) {
              th.setAttribute("data-sortable", "true");
              th.setAttribute("data-field", column.field);
              th.style.cursor = "pointer";
              const titleSpan = document.createElement("span");
              titleSpan.classList.add("col-title");
              titleSpan.textContent = column.title;
              wrapperSpan.appendChild(titleSpan);
              const sortSpan = document.createElement("span");
              sortSpan.classList.add("sort-indicator");
              sortSpan.innerHTML = `<svg width="16" height="16" style="color: var(--sg-gray-400);"><use href="#icon-sort"></use></svg>`;
              wrapperSpan.appendChild(sortSpan);
              this.grid.updateSortIndicator(column.field);
            } else {
              wrapperSpan.textContent = column.title;
            }
            th.appendChild(wrapperSpan);
            if (column.field) {
              const resizer = document.createElement("div");
              resizer.classList.add("column-resizer");
              resizer.setAttribute("data-field", column.field);
              resizer.addEventListener("mousedown", (e) => this.grid.startColumnResize(e, column));
              th.appendChild(resizer);
            }
            headerRow.appendChild(th);
          });
        }
        // ========== 테이블 바디 ==========
        createTableBody(tableElement) {
          const tbody = document.createElement("tbody");
          tbody.setAttribute("data-grid-body", "true");
          if (this.grid.currentPageData.length === 0) {
            this.addNoDataRow(tbody);
          } else {
            this.addDataRows(tbody);
          }
          tableElement.appendChild(tbody);
        }
        addNoDataRow(tbody) {
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          const visibleColumns = this.grid.columns.filter((col) => !col.hideColumn && !this.grid.hiddenColumns.has(col.field)).length;
          cell.colSpan = visibleColumns + (this.grid.enableCheckboxColumn ? 1 : 0) + (this.grid.enableIndexColumn ? 1 : 0);
          cell.textContent = "\uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.";
          cell.classList.add("smartgrid-text-center");
          cell.style.padding = "2rem";
          cell.style.color = "var(--sg-gray-400)";
          row.appendChild(cell);
          tbody.appendChild(row);
        }
        addDataRows(tbody) {
          const fragment = document.createDocumentFragment();
          this.grid.currentPageData.forEach((rowData, index) => {
            fragment.appendChild(this.createDataRow(rowData, index));
          });
          tbody.appendChild(fragment);
        }
        createDataRow(rowData, pageIndex) {
          const row = document.createElement("tr");
          row.setAttribute("data-row-id", rowData[this.grid.idField]);
          const isNewRow = this.grid.changedRows.newRows.includes(rowData);
          const isUpdatedRow = this.grid.changedRows.updatedRows.includes(rowData);
          if (isNewRow) row.classList.add("row-new");
          else if (isUpdatedRow) row.classList.add("row-updated");
          if (rowData.checked) {
            row.classList.add("row-checked");
          }
          if (this.grid.isEditMode) row.classList.add("edit-mode");
          if (this.grid.enableCheckboxColumn) row.appendChild(this.createCheckboxCell(rowData));
          if (this.grid.enableIndexColumn) row.appendChild(this.createIndexCell(rowData, pageIndex));
          this.grid.columns.forEach((column) => {
            if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;
            row.appendChild(this.createDataCell(column, rowData, isNewRow));
          });
          return row;
        }
        createCheckboxCell(rowData) {
          const td = document.createElement("td");
          td.classList.add("sg-col-checkbox");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = !!rowData.checked;
          checkbox.classList.add("smartgrid-input-checkbox");
          checkbox.setAttribute("data-row-checkbox", "true");
          checkbox.setAttribute("data-row-id", rowData[this.grid.idField]);
          td.appendChild(checkbox);
          return td;
        }
        createIndexCell(rowData, pageIndex) {
          const td = document.createElement("td");
          td.classList.add("sg-col-index");
          td.textContent = (this.grid.currentPage - 1) * this.grid.pageSize + pageIndex + 1;
          return td;
        }
        createDataCell(column, rowData, isNewRow) {
          const td = document.createElement("td");
          td.setAttribute("data-field", column.field);
          td.setAttribute("data-row-id", rowData[this.grid.idField]);
          if (column.width) {
            td.style.width = column.width;
            td.style.minWidth = column.width;
          }
          const isReadonly = column.editor.readonly === true || column.editor.editable === false;
          if (isReadonly) {
            td.classList.add("sg-cell-readonly");
          }
          const value = rowData[column.field] ?? column.editor?.defaultVal ?? "";
          const isEditable = column.editor?.editable ?? true;
          const isCellEditable = (isNewRow || this.grid.isEditMode) && isEditable;
          if (isCellEditable) {
            td.appendChild(this.grid.createCellInput(column, rowData, value));
            if (column.editor.type === "checkbox" || column.editor.type === "radiobutton") {
            }
          } else {
            const displayElement = document.createElement("span");
            displayElement.innerHTML = column.render ? column.render(value, rowData, column) : this.formatValue(column, value);
            td.style.textAlign = column.cellAlign;
            td.appendChild(displayElement);
          }
          return td;
        }
        formatValue(column, value) {
          if (column.editor.type === "numberbox") {
            return formatNumber(value, column.editor.decimalPlaces || 0);
          } else if (column.editor.type === "selectbox" || column.editor.type === "radiobutton") {
            const options = column.editor.options || [];
            const selected = options.find((opt) => String(opt.val) === String(value));
            return selected ? selected.text : value;
          }
          return value;
        }
        // ========== 테이블 푸터 ==========
        createTableFooter(tableElement) {
          if (!this.grid.columns.some((col) => col.sum)) return;
          const existingFooter = tableElement?.querySelector("tfoot");
          existingFooter?.remove();
          const tfoot = document.createElement("tfoot");
          const footerRow = document.createElement("tr");
          if (this.grid.enableCheckboxColumn) {
            const checkboxCell = document.createElement("td");
            checkboxCell.classList.add("sg-col-checkbox");
            checkboxCell.appendChild(document.createElement("span"));
            footerRow.appendChild(checkboxCell);
          }
          if (this.grid.enableIndexColumn) {
            const indexCell = document.createElement("td");
            indexCell.classList.add("sg-col-index");
            const span = document.createElement("span");
            span.textContent = "\uD569\uACC4";
            indexCell.appendChild(span);
            footerRow.appendChild(indexCell);
          }
          this.grid.columns.forEach((column) => {
            if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;
            const td = document.createElement("td");
            const span = document.createElement("span");
            if (column.width) td.style.width = column.width;
            if (column.sum && column.editor.type === "numberbox") {
              const total = this.grid.currentPageData.reduce((sum, row) => sum + (parseFloat(row[column.field]) || 0), 0);
              span.textContent = formatNumber(total, column.editor.decimalPlaces || 0);
              td.classList.add("sg-td-total");
            }
            td.appendChild(span);
            footerRow.appendChild(td);
          });
          tfoot.appendChild(footerRow);
          tableElement.appendChild(tfoot);
        }
        /**
         * 셀 표시 업데이트
         */
        updateCellDisplay(cell, column, value) {
          const input = cell.querySelector("input, select, textarea");
          if (input) {
            if (input.type === "checkbox") {
              input.checked = !!value;
            } else if (input.type === "number") {
              let numericValue = value;
              if (typeof value === "string") {
                numericValue = value.replace(/,/g, "");
              }
              numericValue = parseFloat(numericValue);
              if (!isNaN(numericValue) && column?.editor?.decimalPlaces !== void 0) {
                numericValue = parseFloat(numericValue.toFixed(column.editor.decimalPlaces));
              }
              input.value = !isNaN(numericValue) ? numericValue : "";
            } else {
              input.value = value != null ? value : "";
            }
          } else {
            const displayElement = cell.querySelector("span");
            if (displayElement) {
              displayElement.innerHTML = value != null ? value : "";
            }
          }
        }
        /**
         * 테이블 푸터만 업데이트
         */
        updateTableFooter() {
          if (this.grid.table) {
            this.createTableFooter(this.grid.table);
          }
        }
      };
    }
  });

  // core/GridEvents.js
  var GridEvents;
  var init_GridEvents = __esm({
    "core/GridEvents.js"() {
      GridEvents = class {
        constructor(grid) {
          this.grid = grid;
          this.justResized = false;
        }
        /**
         * 이벤트 위임 설정
         */
        setupEventDelegation() {
          const tbody = this.grid.table.querySelector("tbody[data-grid-body]");
          const thead = this.grid.table.querySelector("thead");
          this.removeEventListeners(tbody, thead);
          if (tbody) {
            this.delegate(tbody, "change", this.handleBodyChange.bind(this));
            this.delegate(tbody, "input", this.handleBodyChange.bind(this));
            this.delegate(tbody, "contextmenu", this.handleBodyContextMenu.bind(this));
          }
          if (thead) {
            this.delegate(thead, "click", this.handleHeadClick.bind(this));
          }
          this.setupContextMenuEvents();
        }
        /**
         * 이벤트 리스너 등록 (위임)
         */
        delegate(element, eventType, handler) {
          element[`${eventType}Handler`] = handler;
          element.addEventListener(eventType, handler);
        }
        /**
         * 이벤트 리스너 제거
         */
        removeEventListeners(tbody, thead) {
          if (tbody) {
            if (tbody.changeHandler) tbody.removeEventListener("change", tbody.changeHandler);
            if (tbody.inputHandler) tbody.removeEventListener("input", tbody.inputHandler);
            if (tbody.contextmenuHandler) tbody.removeEventListener("contextmenu", tbody.contextmenuHandler);
          }
          if (thead && thead.clickHandler) {
            thead.removeEventListener("click", thead.clickHandler);
          }
        }
        // ========== 헤더 클릭 핸들러 ==========
        handleHeadClick(event) {
          if (event.target.closest(".column-resizer")) return;
          const masterCheckbox = event.target.closest("thead th input[type='checkbox']");
          if (masterCheckbox) return this.handleMasterCheckboxClick(masterCheckbox);
          const sortableHeader = event.target.closest("th[data-sortable='true']");
          if (sortableHeader) return this.handleSortableHeaderClick(sortableHeader);
        }
        handleMasterCheckboxClick(checkbox) {
          this.grid.currentPageData.forEach((row) => row.checked = checkbox.checked);
          this.grid.renderGrid();
        }
        handleSortableHeaderClick(header) {
          if (this.justResized) {
            return;
          }
          const field = header.getAttribute("data-field");
          if (field) this.grid.sortColumn(field);
        }
        // ========== 바디 변경 핸들러 ==========
        handleBodyChange(event) {
          const input = event.target.closest("input[data-editor-type], select[data-editor-type], textarea[data-editor-type]");
          if (input) return this.handleInputChange(input);
          const rowCheckbox = event.target.closest('input[type="checkbox"][data-row-checkbox="true"]');
          if (rowCheckbox) return this.handleRowCheckboxChange(rowCheckbox);
        }
        handleInputChange(target) {
          const cell = target.closest("td[data-field]");
          const row = target.closest("tr[data-row-id]");
          if (!cell || !row) return;
          const field = cell.getAttribute("data-field");
          const rowId = row.getAttribute("data-row-id");
          const rowData = this.grid.findRowData(rowId);
          if (!rowData) return;
          let value;
          if (target.type === "checkbox") {
            value = target.checked;
          } else if (target.type === "radio") {
            value = row.querySelector(`input[name="${target.name}"]:checked`)?.value ?? "";
          } else {
            value = target.value;
          }
          this.grid.updateRowData(rowData, field, value);
        }
        handleRowCheckboxChange(checkbox) {
          const rowId = checkbox.getAttribute("data-row-id");
          const rowData = this.grid.findRowData(rowId);
          if (rowData) {
            rowData.checked = checkbox.checked;
            const rowElement = checkbox.closest("tr[data-row-id]");
            if (rowElement) {
              rowElement.classList.toggle("row-checked", checkbox.checked);
            }
          }
        }
        // ========== 컨텍스트 메뉴 핸들러 ==========
        handleBodyContextMenu(event) {
          event.preventDefault();
          event.stopPropagation();
          const row = event.target.closest("tr[data-row-id]");
          if (!row) return;
          const rowId = row.getAttribute("data-row-id");
          const cell = event.target.closest("td[data-field]");
          const cellField = cell?.getAttribute("data-field");
          if (this.grid.findRowData(rowId)) {
            this.grid.uiComponents.showContextMenu(event.pageX, event.pageY, rowId, cellField);
          }
        }
        setupContextMenuEvents() {
          const contextMenu = this.grid.uiComponents.contextMenuElement;
          if (!contextMenu || contextMenu.hasClickHandler) return;
          const menuClickHandler = (event) => {
            event.stopPropagation();
            const menuItem = event.target.closest(`.smartgrid-context-menu-item[data-instance="${this.grid.instanceId}"]`);
            if (!menuItem) return;
            const action = menuItem.getAttribute("data-action");
            const rowId = contextMenu.getAttribute("data-context-row-id");
            const cellField = contextMenu.getAttribute("data-context-cell-field");
            contextMenu.style.display = "none";
            this.handleContextMenuAction(action, rowId, cellField);
            contextMenu.removeAttribute("data-context-row-id");
            contextMenu.removeAttribute("data-context-cell-field");
          };
          contextMenu.addEventListener("click", menuClickHandler);
          contextMenu.hasClickHandler = true;
        }
        handleContextMenuAction(action, rowId, cellField) {
          switch (action) {
            case "copyCell":
              if (rowId && cellField) this.copyCellValue(rowId, cellField);
              break;
            case "copyRow":
              if (rowId) this.copyRowData(rowId);
              break;
            case "addRow":
              this.grid.addRow();
              break;
            case "deleteRow":
              if (rowId) {
                const rowData = this.grid.findRowData(rowId);
                if (rowData) {
                  rowData.checked = true;
                  this.grid.deleteRow();
                }
              }
              break;
            case "toggleColumns":
              this.grid.uiComponents.toggleColumnVisibilityPanel();
              break;
          }
        }
        async copyCellValue(rowId, cellField) {
          const rowData = this.grid.findRowData(rowId);
          if (!rowData) return;
          try {
            await navigator.clipboard.writeText(String(rowData[cellField] ?? ""));
            this.grid.showToast("\uC140 \uAC12\uC774 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "success");
          } catch (err) {
            this.grid.showToast("\uBCF5\uC0AC\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.", "error");
          }
        }
        async copyRowData(rowId) {
          const rowData = this.grid.findRowData(rowId);
          if (!rowData) return;
          const visibleColumns = this.grid.columns.filter((c) => !c.hideColumn && !this.grid.hiddenColumns.has(c.field));
          const rowText = visibleColumns.map((col) => rowData[col.field] ?? "").join("	");
          try {
            await navigator.clipboard.writeText(rowText);
            this.grid.showToast("\uD589 \uB370\uC774\uD130\uAC00 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "success");
          } catch (err) {
            this.grid.showToast("\uBCF5\uC0AC\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.", "error");
          }
        }
        /**
         * 컬럼 리사이징 시작
         */
        startColumnResize(event, column) {
          this.grid.isResizing = true;
          this.grid.resizeStartX = event.clientX;
          this.grid.resizeField = column.field;
          const th = event.target.closest("th");
          this.grid.resizeStartWidth = th.offsetWidth;
          this.grid.table.classList.add("resizing-active");
          document.body.style.cursor = "col-resize";
          event.preventDefault();
        }
        /**
         * 컬럼 리사이징 이동
         */
        handleColumnResizeMove(event) {
          if (!this.grid.isResizing) return;
          const resizerElement = this.grid.table.querySelector(`.column-resizer[data-field="${this.grid.resizeField}"]`);
          if (!resizerElement) return;
          const th = resizerElement.closest("th");
          if (!th) return;
          const widthDiff = event.clientX - this.grid.resizeStartX;
          let newWidth = this.grid.resizeStartWidth + widthDiff;
          if (newWidth < 50) {
            newWidth = 50;
          }
          th.style.width = `${newWidth}px`;
          th.style.minWidth = `${newWidth}px`;
        }
        /**
         * 컬럼 리사이징 종료
         */
        handleColumnResizeEnd() {
          if (!this.grid.isResizing) return;
          this.grid.isResizing = false;
          this.grid.table.classList.remove("resizing-active");
          document.body.style.cursor = "";
          const column = this.grid.columns.find((col) => col.field === this.grid.resizeField);
          if (column) {
            const resizerElement = this.grid.table.querySelector(`.column-resizer[data-field="${this.grid.resizeField}"]`);
            const th = resizerElement?.closest("th");
            if (th) {
              column.width = `${th.offsetWidth}px`;
            }
          }
          this.justResized = true;
          setTimeout(() => {
            this.justResized = false;
          }, 200);
          this.grid.resizeField = null;
        }
      };
    }
  });

  // core/PluginManager.js
  var PluginManager;
  var init_PluginManager = __esm({
    "core/PluginManager.js"() {
      PluginManager = class {
        /**
         * @param {SmartGrid} grid - SmartGrid 인스턴스
         */
        constructor(grid) {
          if (!grid) {
            throw new Error("PluginManager requires a SmartGrid instance");
          }
          this.grid = grid;
          this.plugins = /* @__PURE__ */ new Map();
          this.initializationOrder = [];
        }
        /**
         * 플러그인 등록
         * @param {Class} Plugin - 플러그인 클래스
         * @param {Object} options - 플러그인 옵션
         * @returns {SmartGrid} - 체이닝을 위한 grid 반환
         */
        register(Plugin, options = {}) {
          try {
            const instance = new Plugin(this.grid, options);
            if (!instance.name || typeof instance.name !== "string") {
              throw new Error("\uD50C\uB7EC\uADF8\uC778\uC740 name \uC18D\uC131(string)\uC774 \uD544\uC694\uD569\uB2C8\uB2E4");
            }
            const pluginName = instance.name;
            if (this.plugins.has(pluginName)) {
              this.grid.warn("PLUGIN_ALREADY_REGISTERED", `\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC774 \uC774\uBBF8 \uB4F1\uB85D\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. \uB36E\uC5B4\uC501\uB2C8\uB2E4.`);
              this.unregister(pluginName);
            }
            this.plugins.set(pluginName, instance);
            this.initializationOrder.push(pluginName);
            this._definePluginAccessor(pluginName);
            if (typeof instance.install === "function") {
              instance.install();
            }
            this.grid.info(`\uD50C\uB7EC\uADF8\uC778 "${pluginName}" v${instance.version || "1.0.0"} \uB4F1\uB85D \uC644\uB8CC`);
            this.grid.emit("pluginRegistered", {
              name: pluginName,
              version: instance.version || "1.0.0",
              instance
            });
            return this.grid;
          } catch (error) {
            this.grid.handleError(error, "PluginManager.register");
            throw error;
          }
        }
        /**
         * 플러그인 제거
         * @param {string} pluginName - 제거할 플러그인 이름
         * @returns {boolean} - 제거 성공 여부
         */
        unregister(pluginName) {
          try {
            const plugin = this.plugins.get(pluginName);
            if (!plugin) {
              this.grid.warn("PLUGIN_NOT_FOUND", `\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
              return false;
            }
            if (typeof plugin.uninstall === "function") {
              plugin.uninstall();
            }
            this._removePluginAccessor(pluginName);
            this.plugins.delete(pluginName);
            const orderIndex = this.initializationOrder.indexOf(pluginName);
            if (orderIndex !== -1) {
              this.initializationOrder.splice(orderIndex, 1);
            }
            this.grid.info(`\uD50C\uB7EC\uADF8\uC778 "${pluginName}" \uC81C\uAC70 \uC644\uB8CC`);
            this.grid.emit("pluginUnregistered", { name: pluginName });
            return true;
          } catch (error) {
            this.grid.handleError(error, "PluginManager.unregister");
            return false;
          }
        }
        /**
         * 플러그인 존재 여부 확인
         * @param {string} pluginName - 플러그인 이름
         * @returns {boolean}
         */
        has(pluginName) {
          return this.plugins.has(pluginName);
        }
        /**
         * 특정 플러그인 인스턴스 가져오기
         * @param {string} pluginName - 플러그인 이름
         * @returns {PluginBase|null}
         */
        get(pluginName) {
          return this.plugins.get(pluginName) || null;
        }
        /**
         * 등록된 모든 플러그인 이름 목록
         * @returns {string[]}
         */
        getNames() {
          return Array.from(this.plugins.keys());
        }
        /**
         * 모든 플러그인 인스턴스 목록
         * @returns {PluginBase[]}
         */
        getAll() {
          return Array.from(this.plugins.values());
        }
        /**
         * 모든 플러그인을 Map 형태로 반환
         * @returns {Map<string, PluginBase>}
         */
        getAllAsMap() {
          return new Map(this.plugins);
        }
        /**
         * 모든 플러그인 제거
         * @returns {void}
         */
        unregisterAll() {
          const names = [...this.initializationOrder].reverse();
          names.forEach((name) => this.unregister(name));
          if (this.plugins.size > 0) {
            this.plugins.forEach((plugin, name) => {
              this.unregister(name);
            });
          }
        }
        /**
         * 플러그인 개수
         * @returns {number}
         */
        get count() {
          return this.plugins.size;
        }
        /**
         * 플러그인 초기화 상태 확인
         * @param {string} pluginName - 플러그인 이름
         * @returns {boolean}
         */
        isInstalled(pluginName) {
          const plugin = this.get(pluginName);
          if (!plugin) return false;
          return typeof plugin.isInstalled === "function" ? plugin.isInstalled() : plugin.initialized === true;
        }
        /**
         * 특정 조건으로 플러그인 필터링
         * @param {Function} filterFn - 필터 함수 (plugin => boolean)
         * @returns {PluginBase[]}
         */
        filter(filterFn) {
          if (typeof filterFn !== "function") {
            throw new Error("filter requires a function");
          }
          return this.getAll().filter(filterFn);
        }
        /**
         * 플러그인 정보를 객체 배열로 반환
         * @returns {Array<{name: string, version: string, installed: boolean}>}
         */
        getPluginInfoList() {
          return this.getAll().map((plugin) => ({
            name: plugin.name,
            version: plugin.version || "1.0.0",
            installed: this.isInstalled(plugin.name),
            options: plugin.options || {}
          }));
        }
        /**
         * 플러그인 초기화 순서 조회
         * @returns {string[]}
         */
        getInitializationOrder() {
          return [...this.initializationOrder];
        }
        /**
         * 플러그인 의존성 검증
         * @param {string} pluginName - 플러그인 이름
         * @returns {boolean}
         */
        validateDependencies(pluginName) {
          const plugin = this.get(pluginName);
          if (!plugin) return false;
          const dependencies = plugin.dependencies || [];
          if (dependencies.length === 0) return true;
          const missingDeps = dependencies.filter((dep) => !this.has(dep));
          if (missingDeps.length > 0) {
            this.grid.warn("PLUGIN_DEPENDENCY_MISSING", `\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC758 \uC758\uC874\uC131\uC774 \uB204\uB77D\uB418\uC5C8\uC2B5\uB2C8\uB2E4: ${missingDeps.join(", ")}`);
            return false;
          }
          return true;
        }
        /**
         * 모든 플러그인 의존성 검증
         * @returns {boolean}
         */
        validateAllDependencies() {
          let allValid = true;
          this.getNames().forEach((name) => {
            if (!this.validateDependencies(name)) {
              allValid = false;
            }
          });
          return allValid;
        }
        /**
         * 플러그인 직접 접근을 위한 getter 정의
         * @private
         * @param {string} pluginName - 플러그인 이름
         */
        _definePluginAccessor(pluginName) {
          if (this.grid[pluginName] !== void 0) {
            this.grid.warn("PLUGIN_NAME_CONFLICT", `\uD50C\uB7EC\uADF8\uC778 \uC774\uB984 "${pluginName}"\uC774 \uC774\uBBF8 SmartGrid\uC758 \uC18D\uC131/\uBA54\uC11C\uB4DC\uC640 \uCDA9\uB3CC\uD569\uB2C8\uB2E4.`);
            return;
          }
          Object.defineProperty(this.grid, pluginName, {
            get() {
              return this.pluginManager.plugins.get(pluginName);
            },
            configurable: true,
            enumerable: false
          });
        }
        /**
         * 플러그인 getter 제거
         * @private
         * @param {string} pluginName - 플러그인 이름
         */
        _removePluginAccessor(pluginName) {
          if (this.grid[pluginName] !== void 0) {
            try {
              delete this.grid[pluginName];
            } catch (error) {
              this.grid.warn("PLUGIN_ACCESSOR_REMOVAL_FAILED", `\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC758 \uC811\uADFC\uC790 \uC81C\uAC70\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.`);
            }
          }
        }
        /**
         * 플러그인 정보 출력 (디버깅용)
         * @param {boolean} detailed - 상세 정보 출력 여부
         */
        debug(detailed = false) {
          if (!this.grid.debugMode) return;
          console.group(`\u{1F50C} Plugin Manager [${this.grid.tableId}]`);
          console.log(`Total Plugins: ${this.count}`);
          console.log(`Initialization Order: ${this.initializationOrder.join(" \u2192 ")}`);
          if (detailed) {
            this.plugins.forEach((plugin, name) => {
              console.group(`  \u{1F4E6} ${name}`);
              console.log(`    Version: ${plugin.version || "1.0.0"}`);
              console.log(`    Installed: ${this.isInstalled(name) ? "\u2713" : "\u2717"}`);
              console.log(`    Dependencies: ${plugin.dependencies?.join(", ") || "None"}`);
              console.log(`    Options:`, plugin.options);
              console.groupEnd();
            });
          } else {
            this.plugins.forEach((plugin, name) => {
              const status = this.isInstalled(name) ? "\u2713" : "\u2717";
              console.log(`  ${status} ${name} (v${plugin.version || "1.0.0"})`);
            });
          }
          console.groupEnd();
        }
        /**
         * 플러그인 설정 내보내기 (저장/복원 기능)
         * @returns {Array<{Plugin: Class, options: Object}>}
         */
        exportConfigs() {
          return this.getAll().map((plugin) => ({
            name: plugin.name,
            version: plugin.version || "1.0.0",
            options: { ...plugin.options }
          }));
        }
        /**
         * 여러 플러그인 일괄 등록
         * @param {Array<{Plugin: Class, options?: Object}>} configs - 플러그인 설정 배열
         * @returns {Promise<SmartGrid>}
         */
        async batchRegister(configs) {
          if (!Array.isArray(configs)) {
            throw new Error("batchRegister requires an array of plugin configs");
          }
          for (const config of configs) {
            if (!config.Plugin) {
              this.grid.warn("INVALID_PLUGIN_CONFIG", "Plugin \uC18D\uC131\uC774 \uB204\uB77D\uB41C \uC124\uC815\uC774 \uC788\uC2B5\uB2C8\uB2E4.");
              continue;
            }
            try {
              await this.register(config.Plugin, config.options || {});
            } catch (error) {
              this.grid.handleError(error, "PluginManager.batchRegister");
            }
          }
          return this.grid;
        }
        /**
         * 플러그인 활성화 (비활성화된 플러그인 재활성화)
         * @param {string} pluginName - 플러그인 이름
         * @returns {boolean}
         */
        enable(pluginName) {
          const plugin = this.get(pluginName);
          if (!plugin) {
            this.grid.warn("PLUGIN_NOT_FOUND", `\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
            return false;
          }
          if (this.isInstalled(pluginName)) {
            this.grid.info(`\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC740 \uC774\uBBF8 \uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.`);
            return true;
          }
          if (typeof plugin.install === "function") {
            plugin.install();
            this.grid.info(`\uD50C\uB7EC\uADF8\uC778 "${pluginName}" \uD65C\uC131\uD654\uB428`);
            this.grid.emit("pluginEnabled", { name: pluginName });
            return true;
          }
          return false;
        }
        /**
         * 플러그인 비활성화 (제거하지 않고 일시 중지)
         * @param {string} pluginName - 플러그인 이름
         * @returns {boolean}
         */
        disable(pluginName) {
          const plugin = this.get(pluginName);
          if (!plugin) {
            this.grid.warn("PLUGIN_NOT_FOUND", `\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
            return false;
          }
          if (!this.isInstalled(pluginName)) {
            this.grid.info(`\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC740 \uC774\uBBF8 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.`);
            return true;
          }
          if (typeof plugin.uninstall === "function") {
            plugin.uninstall();
            this.grid.info(`\uD50C\uB7EC\uADF8\uC778 "${pluginName}" \uBE44\uD65C\uC131\uD654\uB428`);
            this.grid.emit("pluginDisabled", { name: pluginName });
            return true;
          }
          return false;
        }
        /**
         * 플러그인 재시작 (uninstall → install)
         * @param {string} pluginName - 플러그인 이름
         * @returns {boolean}
         */
        restart(pluginName) {
          const plugin = this.get(pluginName);
          if (!plugin) {
            this.grid.warn("PLUGIN_NOT_FOUND", `\uD50C\uB7EC\uADF8\uC778 "${pluginName}"\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.`);
            return false;
          }
          this.disable(pluginName);
          return this.enable(pluginName);
        }
        /**
         * 모든 플러그인 상태 조회
         * @returns {Object} - {installed: [], uninstalled: []}
         */
        getStatus() {
          const installed = [];
          const uninstalled = [];
          this.plugins.forEach((plugin, name) => {
            if (this.isInstalled(name)) {
              installed.push(name);
            } else {
              uninstalled.push(name);
            }
          });
          return { installed, uninstalled };
        }
        /**
         * 플러그인 통계
         * @returns {Object}
         */
        getStats() {
          const status = this.getStatus();
          return {
            total: this.count,
            installed: status.installed.length,
            uninstalled: status.uninstalled.length,
            names: this.getNames(),
            initOrder: this.getInitializationOrder()
          };
        }
      };
    }
  });

  // core/SmartGrid.js
  var SmartGrid_exports = {};
  __export(SmartGrid_exports, {
    SmartGrid: () => SmartGrid
  });
  var _SmartGrid, SmartGrid;
  var init_SmartGrid = __esm({
    "core/SmartGrid.js"() {
      init_EventEmitter();
      init_SmartGridError();
      init_DataHandler();
      init_InputFactory();
      init_UIComponents();
      init_GridRenderer();
      init_GridEvents();
      init_PluginManager();
      init_utils();
      _SmartGrid = class _SmartGrid extends EventEmitter {
        // ========== 생성자 ==========
        constructor(tableId, options = {}) {
          super();
          // ========== 인스턴스 속성 ==========
          __publicField(this, "table");
          __publicField(this, "options");
          __publicField(this, "wrapper", null);
          __publicField(this, "dataHandler", null);
          __publicField(this, "renderer", null);
          __publicField(this, "eventHandler", null);
          __publicField(this, "uiComponents", null);
          __publicField(this, "pluginManager", null);
          // ⭐ 변경: plugins → pluginManager
          __publicField(this, "columns", []);
          __publicField(this, "originalData", []);
          __publicField(this, "originalDataBackup", []);
          __publicField(this, "currentPageData", []);
          __publicField(this, "totalRows", 0);
          __publicField(this, "pageSize", 10);
          __publicField(this, "currentPage", 1);
          __publicField(this, "pagingMode", "client");
          __publicField(this, "isEditMode", false);
          __publicField(this, "changedRows", { newRows: [], updatedRows: [], deletedRows: [] });
          __publicField(this, "sortOrders", []);
          __publicField(this, "rowHeight", 35);
          __publicField(this, "isResizing", false);
          __publicField(this, "resizeStartX", 0);
          __publicField(this, "resizeStartWidth", 0);
          __publicField(this, "resizeField", null);
          __publicField(this, "hiddenColumns", /* @__PURE__ */ new Set());
          __publicField(this, "inputFactory", null);
          __publicField(this, "filters", {});
          __publicField(this, "warnings", []);
          __publicField(this, "lastParams", {});
          try {
            this.tableId = tableId;
            this.instanceId = `sg_${tableId}`;
            this.debugMode = options.debug ?? false;
            this.table = document.getElementById(tableId);
            if (!this.table) {
              throw new SmartGridError(`\uD14C\uC774\uBE14\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4: "${tableId}"`, "ELEMENT_NOT_FOUND", this.instanceId, { tableId });
            }
            _SmartGrid.instances.add(this);
            this.columns = options.columns || [];
            this.options = {
              idField: "id",
              pageSize: 10,
              page: 1,
              pagingMode: "client",
              rowHeight: 35,
              enableCheckboxColumn: true,
              enableIndexColumn: true,
              enableEditMode: true,
              loadFilter: null,
              onLoadSuccess: null,
              onLoadError: null,
              enableToolbar: true,
              enablePagination: true,
              enableTotalRows: true,
              enablePageSizeSelect: true,
              toolbarButtons: Object.keys(_SmartGrid.BUTTON_CONFIG),
              queryParams: {},
              ...options
            };
            this.lastParams = this.options.queryParams || {};
            this.pageSize = this.options.pageSize;
            this.currentPage = this.options.page;
            this.rowHeight = this.options.rowHeight;
            this.pluginManager = new PluginManager(this);
            if (this.options.pagingMode === "server" && this.options.url) {
              this.dataHandler = new ServerSideHandler(this);
            } else {
              this.dataHandler = new ClientSideHandler(this);
            }
            this.renderer = new GridRenderer(this);
            this.eventHandler = new GridEvents(this);
            this.uiComponents = new UIComponents(this);
            this.initializeColumns();
            this.setRowHeight(this.rowHeight, false);
            this.createWrapper();
            this.createUIElements();
            this.initializeGlobalEvents();
            this.validateConfiguration();
            this.info("\uADF8\uB9AC\uB4DC \uCD08\uAE30\uD654 \uC644\uB8CC");
          } catch (error) {
            this.handleError(error, "constructor");
            throw error;
          }
        }
        // ========== Getter ==========
        get idField() {
          return this.options.idField;
        }
        get enableCheckboxColumn() {
          return this.options.enableCheckboxColumn;
        }
        get enableIndexColumn() {
          return this.options.enableIndexColumn;
        }
        get editModeEnabled() {
          return this.options.enableEditMode;
        }
        // ========== 정적 메서드 ==========
        static getInstance(instanceId) {
          for (const instance of _SmartGrid.instances) {
            if (instance.instanceId === instanceId) return instance;
          }
          return null;
        }
        static findByTableId(tableId) {
          for (const instance of _SmartGrid.instances) {
            if (instance.tableId === tableId) return instance;
          }
          return null;
        }
        static getAllInstances() {
          return Array.from(_SmartGrid.instances);
        }
        // ========== 플러그인 시스템 (위임 패턴) ==========
        /**
         * 플러그인 등록
         * @param {Class} Plugin - 플러그인 클래스
         * @param {Object} options - 플러그인 옵션
         * @returns {SmartGrid} - 체이닝을 위한 this 반환
         */
        use(Plugin, options = {}) {
          return this.pluginManager.register(Plugin, options);
        }
        /**
         * 플러그인 제거
         * @param {string} pluginName - 제거할 플러그인 이름
         * @returns {boolean} - 제거 성공 여부
         */
        removePlugin(pluginName) {
          return this.pluginManager.unregister(pluginName);
        }
        /**
         * 플러그인 존재 여부 확인
         * @param {string} pluginName - 플러그인 이름
         * @returns {boolean}
         */
        hasPlugin(pluginName) {
          return this.pluginManager.has(pluginName);
        }
        /**
         * 등록된 모든 플러그인 목록
         * @returns {string[]}
         */
        getPluginNames() {
          return this.pluginManager.getNames();
        }
        /**
         * 특정 플러그인 인스턴스 가져오기
         * @param {string} pluginName - 플러그인 이름
         * @returns {PluginBase|null}
         */
        getPlugin(pluginName) {
          return this.pluginManager.get(pluginName);
        }
        // ========== 초기화 메서드 (기존 코드 유지) ==========
        initializeColumns() {
          this.columns.forEach((col, index) => {
            col.field ?? (col.field = col.hideColumn ? void 0 : `column_${index}`);
            col.title ?? (col.title = col.field || `\uCEEC\uB7FC ${index + 1}`);
            col.width ?? (col.width = "auto");
            col.headAlign ?? (col.headAlign = "center");
            col.print ?? (col.print = true);
            col.exportExcel ?? (col.exportExcel = true);
            if (typeof col.editor !== "object" || col.editor === null) {
              col.editor = { type: col.editor || "textbox" };
            }
            col.cellAlign ?? (col.cellAlign = col.editor.type === "numberbox" ? "right" : "left");
          });
        }
        // ========== [추가] 행 클릭 이벤트 바인딩 ==========
        _bindRowClick() {
          const tbody = this.table?.querySelector("tbody");
          if (!tbody) return;
          if (this._rowClickHandler) {
            tbody.removeEventListener("click", this._rowClickHandler);
          }
          this._rowClickHandler = (e) => {
            const tr = e.target.closest("tr[data-row-id]");
            if (!tr) return;
            const rowId = tr.getAttribute("data-row-id");
            const rowData = this.findRowData(rowId);
            if (!rowData) return;
            tbody.querySelectorAll("tr").forEach((r) => r.classList.remove("sg-row-selected"));
            tr.classList.add("sg-row-selected");
            this.emit("rowClick", rowData, e);
          };
          tbody.addEventListener("click", this._rowClickHandler);
        }
        createWrapper() {
          const container = document.createElement("div");
          container.className = "smartgrid-container";
          this.table.parentNode.insertBefore(container, this.table);
          container.appendChild(this.table);
          const wrapper = document.createElement("div");
          wrapper.className = "smartgrid-wrapper";
          wrapper.setAttribute("data-instance", this.instanceId);
          wrapper.setAttribute("data-grid-id", this.tableId);
          if (this.options.width !== void 0) {
            wrapper.style.width = typeof this.options.width === "number" ? `${this.options.width}px` : this.options.width;
          }
          container.parentNode.insertBefore(wrapper, container);
          wrapper.appendChild(container);
          if (this.options.height !== void 0) {
            container.style.height = typeof this.options.height === "number" ? `${this.options.height}px` : this.options.height;
          }
          container.style.overflow = "auto";
          container.setAttribute("data-instance", this.instanceId);
          container.setAttribute("data-grid-id", this.tableId);
          this.wrapper = wrapper;
        }
        createUIElements() {
          this.uiComponents.createAll();
          if (this.options.enableToolbar || this.options.enableTotalRows || this.options.enablePageSizeSelect) {
            this.createToolbar();
          }
        }
        createToolbar() {
          if (!this.options.enableToolbar && !this.options.enableTotalRows && !this.options.enablePageSizeSelect) return;
          const toolbarContainer = document.createElement("div");
          toolbarContainer.className = "smartgrid-toolbar-container";
          toolbarContainer.setAttribute("data-grid-id", this.tableId);
          const section1 = document.createElement("div");
          section1.className = "smartgrid-toolbar-section";
          if (this.options.enableToolbar) {
            const buttonGroup = document.createElement("div");
            buttonGroup.className = "smartgrid-toolbar-group";
            section1.appendChild(buttonGroup);
            const toolbarButtons = this.options.toolbarButtons;
            const buttonEntries = Array.isArray(toolbarButtons) ? toolbarButtons.map((btn) => [null, btn]) : Object.entries(toolbarButtons);
            buttonEntries.forEach(([key, btnConfig]) => {
              let config;
              if (typeof btnConfig === "string") {
                config = _SmartGrid.BUTTON_CONFIG[btnConfig];
              } else {
                config = btnConfig[Object.keys(btnConfig)[0]];
              }
              const button = document.createElement("button");
              button.className = config.className ? config.className : "smartgrid-btn smartgrid-btn-secondary";
              const iconHtml = config.icon ? `<i class="${config.icon}"></i>` : "";
              button.innerHTML = `${iconHtml}<span>${config.text}</span>`;
              button.addEventListener("click", (event) => {
                event.stopPropagation();
                if (typeof config.action === "function") {
                  config.action.call(this, event);
                } else if (typeof config.action === "string") {
                  const action = this[config.action];
                  if (typeof action === "function") {
                    action.apply(this, config.params || []);
                  }
                }
              });
              buttonGroup.appendChild(button);
            });
          }
          const section2 = document.createElement("div");
          section2.className = "smartgrid-toolbar-section";
          if (this.options.enableTotalRows) {
            const totalRowsDiv = document.createElement("div");
            totalRowsDiv.id = `${this.instanceId}_totalRows`;
            totalRowsDiv.className = "smartgrid-info-text";
            section2.appendChild(totalRowsDiv);
            this.totalRowsElement = totalRowsDiv;
          }
          if (this.options.enablePageSizeSelect) {
            const pageSizeSelect = document.createElement("select");
            pageSizeSelect.id = `${this.instanceId}_pageSize`;
            pageSizeSelect.className = "smartgrid-select";
            pageSizeSelect.innerHTML = _SmartGrid.PAGE_SIZE_OPTIONS.map((opt) => `<option value="${opt.value}">${opt.text}</option>`).join("");
            pageSizeSelect.value = this.pageSize;
            pageSizeSelect.addEventListener("change", (e) => {
              const newSize = e.target.value;
              if (newSize === "all") {
                if (this.pagingMode === "client") {
                  this.setPageSize(this.getSortedData().length || 1);
                  this.changePage();
                } else {
                  if (this.totalRows > 0) {
                    this.setPageSize(this.totalRows);
                    this.changePage();
                  } else {
                    this.showToast("\uC11C\uBC84\uC0AC\uC774\uB4DC \uBAA8\uB4DC\uC5D0\uC11C\uB294 '\uC804\uCCB4 \uBCF4\uAE30'\uB97C \uC9C0\uC6D0\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.", "warning");
                    e.target.value = this.pageSize;
                  }
                }
              } else {
                this.setPageSize(parseInt(newSize, 10));
                this.changePage();
              }
            });
            section2.appendChild(pageSizeSelect);
            this.pageSizeSelectElement = pageSizeSelect;
          }
          if (section1.children.length > 0) toolbarContainer.appendChild(section1);
          if (section2.children.length > 0) toolbarContainer.appendChild(section2);
          if (toolbarContainer.children.length > 0) {
            this.wrapper.insertBefore(toolbarContainer, this.wrapper.firstChild);
            this.toolbarElement = toolbarContainer;
          }
        }
        initializeGlobalEvents() {
          if (_SmartGrid.globalEventsInitialized) return;
          document.addEventListener("mousemove", (e) => {
            _SmartGrid.instances.forEach((grid) => {
              if (grid.isResizing) grid.eventHandler.handleColumnResizeMove(e);
            });
          });
          document.addEventListener("mouseup", (e) => {
            _SmartGrid.instances.forEach((grid) => {
              if (grid.isResizing) grid.eventHandler.handleColumnResizeEnd(e);
            });
          });
          document.addEventListener("click", (e) => {
            _SmartGrid.instances.forEach((grid) => {
              const contextMenu = grid.uiComponents.contextMenuElement;
              if (contextMenu && !contextMenu.contains(e.target)) {
                const isContextMenuItem = e.target.closest(".smartgrid-context-menu-item");
                if (!isContextMenuItem || e.target.getAttribute("data-instance") !== grid.instanceId) {
                  contextMenu.style.display = "none";
                }
              }
              const columnPanel = grid.uiComponents.columnPanelElement;
              if (columnPanel && !columnPanel.contains(e.target)) {
                const toggleBtn = document.getElementById(`${grid.instanceId}_toggleColumnsBtn`);
                if (!toggleBtn || !toggleBtn.contains(e.target)) {
                  columnPanel.classList.remove("active");
                }
              }
            });
          });
          _SmartGrid.globalEventsInitialized = true;
        }
        validateConfiguration() {
          if (!this.columns || this.columns.length === 0) {
            this.warn("NO_COLUMNS", "\uCEEC\uB7FC\uC774 \uC815\uC758\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uBE48 \uD14C\uC774\uBE14\uC774 \uD45C\uC2DC\uB429\uB2C8\uB2E4.");
          }
          const fieldIds = this.columns.map((col) => col.field).filter(Boolean);
          const duplicates = fieldIds.filter((field, index) => fieldIds.indexOf(field) !== index);
          if (duplicates.length > 0) {
            this.warn("DUPLICATE_FIELDS", `\uC911\uBCF5\uB41C \uD544\uB4DC ID\uAC00 \uBC1C\uACAC\uB418\uC5C8\uC2B5\uB2C8\uB2E4: ${duplicates.join(", ")}`);
          }
          if (this.options.pageSize > 100) {
            this.warn("LARGE_PAGE_SIZE", `\uD398\uC774\uC9C0 \uD06C\uAE30\uAC00 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${this.options.pageSize}. \uC131\uB2A5 \uC800\uD558\uAC00 \uBC1C\uC0DD\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`);
          }
        }
        // ========== 데이터 로드 메서드 ==========
        async loadData(data) {
          if (this.dataHandler instanceof ClientSideHandler) {
            return this.dataHandler.load(data);
          } else {
            this.warn("INVALID_OPERATION", "\uC11C\uBC84 \uBAA8\uB4DC\uC5D0\uC11C\uB294 loadData \uB300\uC2E0 fetchData\uB97C \uC0AC\uC6A9\uD574\uC57C \uD569\uB2C8\uB2E4.");
          }
        }
        // SmartGrid.js
        async fetchData(params) {
          if (params !== void 0) {
            this.lastParams = params;
          }
          return this.dataHandler.load();
        }
        // ========== 정렬/페이징 메서드 ==========
        async sortColumn(field) {
          this.emit("beforeSort", { field, sortOrders: [...this.sortOrders] });
          const existingIndex = this.sortOrders.findIndex((order) => order.field === field);
          if (existingIndex !== -1) {
            const currentOrder = this.sortOrders[existingIndex].order;
            if (currentOrder === "asc") this.sortOrders[existingIndex].order = "desc";
            else if (currentOrder === "desc") this.sortOrders.splice(existingIndex, 1);
          } else {
            this.sortOrders.push({ field, order: "asc" });
          }
          await this.dataHandler.sort();
          this.emit("afterSort", { field, sortOrders: [...this.sortOrders] });
        }
        async changePage() {
          const beforeEvent = { currentPage: this.currentPage, cancelled: false };
          this.emit("beforePageChange", beforeEvent);
          if (beforeEvent.cancelled) return;
          await this.dataHandler.page();
          this.emit("afterPageChange", { currentPage: this.currentPage });
        }
        setPageSize(newPageSize) {
          this.pageSize = parseInt(newPageSize, 10);
          this.currentPage = 1;
        }
        // ========== CRUD 메서드 ==========
        addRow() {
          this.dataHandler.add();
        }
        saveRow() {
          this.dataHandler.save();
        }
        rejectRow() {
          this.dataHandler.reject();
        }
        deleteRow() {
          this.dataHandler.delete();
        }
        // ========== 데이터 조회 메서드 ==========
        getData() {
          return this.getSortedData();
        }
        getSortedData() {
          return this.dataHandler.getSortedData();
        }
        getRows() {
          return [...this.currentPageData];
        }
        getCheckedRows() {
          if (!this.currentPageData || !Array.isArray(this.currentPageData)) {
            this.warn("GET_CHECKED_ROWS_FAILED", "\uD604\uC7AC \uD398\uC774\uC9C0 \uB370\uC774\uD130\uAC00 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.");
            return [];
          }
          return this.currentPageData.filter((row) => row.checked === true);
        }
        updateTotalRowsInfo() {
          this.dataHandler.updateTotalRowsInfo();
        }
        invalidateSortCache() {
          if (this.dataHandler instanceof ClientSideHandler) {
            this.dataHandler.invalidateSortCache();
          }
        }
        // ========== 렌더링 메서드 ==========
        renderGrid() {
          this.renderer.renderGrid();
          this.eventHandler.setupEventDelegation();
          this._bindRowClick();
        }
        renderPagination() {
          this.uiComponents.renderPagination();
        }
        updateSortIndicator(field) {
          const th = this.table.querySelector(`th[data-field="${field}"]`);
          if (!th) return;
          const sortSpan = th.querySelector(".sort-indicator");
          if (!sortSpan) return;
          const { order, index } = this.getSortOrder(field);
          let html = "";
          if (index !== null) {
            html += `<span class="smartgrid-badge">${index}</span>`;
          }
          if (order === "asc") {
            html += `<i class="bi bi-caret-up-fill" style="font-size:12px; color: var(--sg-gray-900);"></i>`;
          } else if (order === "desc") {
            html += `<i class="bi bi-caret-down-fill" style="font-size:12px; color: var(--sg-gray-900);"></i>`;
          } else {
            html += `<i class="bi bi-arrow-down-up" style="font-size:12px; color: var(--sg-gray-400);"></i>`;
          }
          sortSpan.innerHTML = html;
        }
        // ========== 컬럼 리사이징 ==========
        startColumnResize(event, column) {
          this.eventHandler.startColumnResize(event, column);
        }
        // ========== 입력 요소 생성 ==========
        getInputFactory() {
          this.inputFactory ?? (this.inputFactory = new InputFactory(this));
          return this.inputFactory;
        }
        createCellInput(column, rowData, value) {
          return this.getInputFactory().create(column, rowData, value);
        }
        // ========== 행 데이터 업데이트 ==========
        updateRowData(rowData, field, value) {
          if (rowData[field] === value) return;
          const oldValue = rowData[field];
          const column = this.columns.find((col) => col.field === field);
          const beforeEvent = { rowData, field, oldValue, newValue: value, cancelled: false };
          this.emit("beforeCellChange", beforeEvent);
          if (beforeEvent.cancelled) return;
          if (column?.editor.type === "numberbox") {
            if (value === "" || value === null || value === void 0) {
              value = null;
            } else {
              if (typeof value === "string") {
                value = value.replace(/,/g, "");
              }
              value = parseFloat(value) || 0;
              if (column.editor.decimalPlaces !== void 0) {
                value = parseFloat(value.toFixed(column.editor.decimalPlaces));
              }
            }
          }
          rowData[field] = value;
          const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
          const formulaColumns = this.columns.filter((col) => typeof col.formula === "function");
          if (formulaColumns.length > 0 && rowElement) {
            const cells = new Map(Array.from(rowElement.querySelectorAll("td[data-field]")).map((cell) => [cell.getAttribute("data-field"), cell]));
            formulaColumns.forEach((col, index) => {
              let formulaValue = this.evaluateFormula(col.formula, rowData, col, index);
              if (isNaN(formulaValue)) {
                formulaValue = 0;
              }
              if (col.editor.type === "numberbox" && col.editor.decimalPlaces !== void 0) {
                formulaValue = parseFloat(formulaValue.toFixed(col.editor.decimalPlaces));
              }
              rowData[col.field] = formulaValue;
              const cell = cells.get(col.field);
              if (cell) {
                let displayValue = formulaValue;
                if (col.editor.type === "numberbox" && col.editor.decimalPlaces !== void 0) {
                  const decimalPlaces = col.editor.decimalPlaces;
                  displayValue = formatNumber(formulaValue, decimalPlaces);
                }
                this.renderer.updateCellDisplay(cell, col, displayValue);
              }
            });
          }
          if (!this.changedRows.newRows.includes(rowData) && !this.changedRows.updatedRows.includes(rowData)) {
            this.changedRows.updatedRows.push(rowData);
            rowElement?.classList.add("row-updated");
          }
          this.invalidateSortCache();
          this.renderer.updateTableFooter();
          this.emit("afterCellChange", { rowData, field, oldValue, newValue: value });
        }
        findRowData(rowId) {
          const findById = (row) => String(row[this.idField]) === String(rowId);
          return this.currentPageData.find(findById) || this.originalData.find(findById);
        }
        // ========== 수식/필터 ==========
        applyFormula(row) {
          this.columns.forEach((col, index) => {
            if (col.formula) {
              row[col.field] = this.evaluateFormula(col.formula, row, col, index);
            }
          });
        }
        evaluateFormula(formula, row, column, index) {
          if (typeof formula !== "function") return void 0;
          try {
            let result = formula(row, column, index);
            if (isNaN(result)) {
              return 0;
            }
            return result;
          } catch (err) {
            console.error(`Error executing formula for column "${column.field}":`, err);
            return 0;
          }
        }
        compareRowsForSort(rowA, rowB) {
          for (const { field, order } of this.sortOrders) {
            const valueA = rowA[field] ?? "";
            const valueB = rowB[field] ?? "";
            if (valueA < valueB) return order === "asc" ? -1 : 1;
            if (valueA > valueB) return order === "asc" ? 1 : -1;
          }
          return 0;
        }
        applyFilters(data) {
          if (!this.filters || Object.keys(this.filters).length === 0) {
            return data;
          }
          return data.filter((row) => {
            if (this.filters.keyword) {
              const keyword = this.filters.keyword.toLowerCase();
              const matchFields = ["fCode", "fName", "fOrigin", "comment"];
              const hasMatch = matchFields.some(
                (field) => String(row[field] || "").toLowerCase().includes(keyword)
              );
              if (!hasMatch) return false;
            }
            if (this.filters.startDate && row.expDate < this.filters.startDate) return false;
            if (this.filters.endDate && row.expDate > this.filters.endDate) return false;
            if (this.filters.status && this.filters.status.length > 0) {
              if (!this.filters.status.includes(row.stockStatus)) return false;
            }
            return true;
          });
        }
        getSortOrder(field) {
          const sortOrder = this.sortOrders.find((order) => order.field === field);
          const sortIndex = this.sortOrders.findIndex((order) => order.field === field);
          return {
            order: sortOrder?.order || null,
            index: sortIndex !== -1 ? sortIndex + 1 : null
          };
        }
        // ========== 행 높이 설정 ==========
        setRowHeight(height, reRender = true) {
          this.rowHeight = parseInt(height, 10) || 30;
          if (this.table) {
            this.table.style.setProperty("--row-height", `${this.rowHeight}px`);
          } else {
            document.documentElement.style.setProperty("--row-height", `${this.rowHeight}px`);
          }
          if (reRender) {
            this.renderGrid();
            this.showToast(`\uD589 \uB192\uC774\uAC00 ${this.rowHeight}px\uB85C \uC124\uC815\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`, "info");
          }
        }
        // ========== 수정 모드 ==========
        setEditMode(enabled) {
          if (enabled && (this.changedRows.newRows.length > 0 || this.changedRows.updatedRows.length > 0 || this.changedRows.deletedRows.length > 0)) {
            this.showToast("\uC800\uC7A5\uD558\uC9C0 \uC54A\uC740 \uBCC0\uACBD \uC0AC\uD56D\uC774 \uC788\uC2B5\uB2C8\uB2E4. \uBA3C\uC800 \uC800\uC7A5\uD558\uAC70\uB098 \uCDE8\uC18C\uD574\uC8FC\uC138\uC694.", "warning");
            return false;
          }
          if (!this.editModeEnabled) {
            this.showToast("\uC774 \uADF8\uB9AC\uB4DC\uB294 \uC218\uC815 \uBAA8\uB4DC\uAC00 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.", "warning");
            return false;
          }
          if (this.isEditMode === enabled) return false;
          const beforeEvent = { previousMode: this.isEditMode, newMode: enabled, cancelled: false };
          this.emit("beforeEditModeChange", beforeEvent);
          if (beforeEvent.cancelled) return false;
          if (enabled && !this.isEditMode) {
            if (!this.originalDataBackup || this.originalDataBackup.length === 0) {
              this.originalDataBackup = deepClone(this.originalData);
            }
          }
          this.isEditMode = enabled;
          this.renderGrid();
          this.columns.forEach((col) => {
            if (col.sortable) {
              this.updateSortIndicator(col.field);
            }
          });
          const message = enabled ? "\uC218\uC815 \uBAA8\uB4DC \uD65C\uC131\uD654" : "\uC218\uC815 \uBAA8\uB4DC \uBE44\uD65C\uC131\uD654";
          this.showToast(message, "success");
          this.emit("afterEditModeChange", { previousMode: beforeEvent.previousMode, currentMode: enabled });
          return true;
        }
        isEditModeEnabled() {
          return this.editModeEnabled;
        }
        getEditMode() {
          return this.isEditMode;
        }
        // ========== 유효성 검사 ==========
        validateChanges() {
          if (this.changedRows.newRows.length > 0) {
            const hasEmptyNewRow = this.changedRows.newRows.some((row) => {
              return this.columns.every((col) => {
                const val = row[col.field];
                return val === null || val === void 0 || String(val).trim() === "";
              });
            });
            if (hasEmptyNewRow) {
              this.showToast("\uB370\uC774\uD130\uAC00 \uC785\uB825\uB418\uC9C0 \uC54A\uC740 \uD589\uC774 \uC788\uC2B5\uB2C8\uB2E4. \uB0B4\uC6A9\uC744 \uC785\uB825\uD558\uAC70\uB098 \uC0AD\uC81C \uD6C4 \uC800\uC7A5\uD574\uC8FC\uC138\uC694.", "warning");
              return false;
            }
          }
          const rowsToValidate = [...this.changedRows.newRows, ...this.changedRows.updatedRows];
          const beforeEvent = { rowsToValidate, cancelled: false };
          this.emit("beforeValidate", beforeEvent);
          if (beforeEvent.cancelled) return false;
          const errors = [];
          for (const rowData of rowsToValidate) {
            for (const column of this.columns) {
              const value = rowData[column.field];
              if (column.editor?.required) {
                if (value === null || value === void 0 || String(value).trim() === "") {
                  this.showToast(`'${column.title}' \uD544\uB4DC\uB294 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.`, "error");
                  const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
                  const cellElement = rowElement?.querySelector(`td[data-field="${column.field}"]`);
                  if (cellElement) {
                    cellElement.classList.add("cell-invalid");
                    cellElement.querySelector("input, select, textarea")?.focus();
                    setTimeout(() => cellElement.classList.remove("cell-invalid"), 3e3);
                  }
                  const errorInfo = {
                    rowData,
                    column,
                    value,
                    message: `'${column.title}' \uD544\uB4DC\uB294 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.`
                  };
                  errors.push(errorInfo);
                  this.emit("validationError", errorInfo);
                  this.emit("afterValidate", { isValid: false, errors });
                  return false;
                }
              }
              if (typeof column.editor?.validate === "function") {
                try {
                  const validationResult = column.editor.validate(value, rowData, column);
                  if (validationResult !== true) {
                    const message = typeof validationResult === "string" ? validationResult : `'${column.title}' \uD544\uB4DC\uC758 \uAC12\uC774 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.`;
                    this.showToast(message, "error");
                    const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
                    const cellElement = rowElement?.querySelector(`td[data-field="${column.field}"]`);
                    if (cellElement) {
                      cellElement.classList.add("cell-invalid");
                      cellElement.querySelector("input, select, textarea")?.focus();
                      setTimeout(() => cellElement.classList.remove("cell-invalid"), 3e3);
                    }
                    const errorInfo = {
                      rowData,
                      column,
                      value,
                      message
                    };
                    errors.push(errorInfo);
                    this.emit("validationError", errorInfo);
                    this.emit("afterValidate", { isValid: false, errors });
                    return false;
                  }
                } catch (e) {
                  const message = `'${column.title}' \uC720\uD6A8\uC131 \uAC80\uC0AC \uC911 \uC624\uB958: ${e.message}`;
                  console.error(`Validation function error for ${column.field}:`, e);
                  this.showToast(message, "error");
                  const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
                  const cellElement = rowElement?.querySelector(`td[data-field="${column.field}"]`);
                  if (cellElement) {
                    cellElement.classList.add("cell-invalid");
                    cellElement.querySelector("input, select, textarea")?.focus();
                    setTimeout(() => cellElement.classList.remove("cell-invalid"), 3e3);
                  }
                  const errorInfo = {
                    rowData,
                    column,
                    value,
                    message
                  };
                  errors.push(errorInfo);
                  this.emit("validationError", errorInfo);
                  this.emit("afterValidate", { isValid: false, errors });
                  return false;
                }
              }
            }
          }
          this.emit("afterValidate", { isValid: true, errors: [] });
          return true;
        }
        printCurrentPage() {
          const data = this.getSortedData();
          if (!data.length) {
            this.showToast("\uC778\uC1C4\uD560 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.", "warning");
            return;
          }
          this.showLoading();
          try {
            const visibleColumns = this.columns.filter((col) => !col.hideColumn && !this.hiddenColumns.has(col.field) && col.print !== false);
            const headerRow = visibleColumns.map((col) => `<th style="${col.width ? `width:${col.width};` : ""} text-align: ${col.headAlign || "center"}; padding: 6px;">${col.title}</th>`).join("");
            const tableHTML = `<table border="1" style="width: 100%; border-collapse: collapse; text-align: center; font-size: 10pt;"><thead><tr style="background: #f0f0f0;"><th style="width: 50px;">\uBC88\uD638</th>${headerRow}</tr></thead><tbody>${data.map(
              (row, i) => `<tr><td style="padding: 6px;">${i + 1}</td>${visibleColumns.map((col) => {
                const rawValue = row[col.field] ?? "";
                let cellContent = rawValue;
                if (col.editor && col.editor.type === "numberbox") {
                  cellContent = formatNumber(rawValue, col.editor.decimalPlaces || 0);
                }
                const align = col.cellAlign || (col.editor?.type === "numberbox" ? "right" : "left");
                return `<td style="text-align: ${align}; padding: 6px;">${cellContent}</td>`;
              }).join("")}</tr>`
            ).join("")}</tbody></table>`;
            this.openPrintWindow(tableHTML);
          } finally {
            this.hideLoading();
          }
        }
        openPrintWindow(html) {
          const win = window.open("", "_blank", "width=800,height=600");
          const docTitle = document.title;
          const time = getCurrentDateTime();
          win.document.write(
            `<html><head><title>\uC778\uC1C4</title><style>@media print{@page{margin:1cm}thead{display:table-header-group}}body{font-family:'Malgun Gothic','Arial',sans-serif}h1{text-align:center;margin-bottom:5px;font-size:18pt}.subtitle{text-align:center;color:#666;margin-bottom:20px;font-size:10pt}table{width:100%;border-collapse:collapse;table-layout:fixed}th,td{border:1px solid #ccc;padding:8px;font-size:9pt;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}th{background:#f5f5f5;font-weight:bold}</style></head><body><h1>${docTitle.replace(
              "V4",
              "\uC778\uC1C4"
            )}</h1><div class="subtitle">\uCD9C\uB825\uC77C: ${time}</div>${html}</body></html>`
          );
          win.document.close();
          win.focus();
          setTimeout(() => win.print(), 250);
        }
        // ========== 컬럼 표시/숨김 ==========
        hideColumn(field) {
          this.hiddenColumns.add(field);
          this.renderGrid();
          this.showToast(`"${this.columns.find((c) => c.field === field)?.title}" \uC5F4\uC774 \uC228\uACA8\uC84C\uC2B5\uB2C8\uB2E4.`, "info");
        }
        showColumn(field) {
          this.hiddenColumns.delete(field);
          this.renderGrid();
          this.showToast(`"${this.columns.find((c) => c.field === field)?.title}" \uC5F4\uC774 \uD45C\uC2DC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`, "info");
        }
        // ========== UI 메서드 (위임) ==========
        showLoading() {
          this.uiComponents.showLoading();
        }
        hideLoading() {
          this.uiComponents.hideLoading();
        }
        showToast(message, type = "info") {
          this.uiComponents.showToast(message, type);
        }
        showConfirmModal(message, callback) {
          this.uiComponents.showConfirmModal(message, callback);
        }
        // ========== 에러 처리 ==========
        handleError(error, context = "") {
          const errorInfo = {
            message: error.message,
            code: error.code || "UNKNOWN_ERROR",
            context,
            instanceId: this.instanceId,
            tableId: this.tableId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            stack: error.stack
          };
          if (this.debugMode) {
            console.group(`\u274C SmartGrid Error [${this.tableId}]`);
            console.error("Error:", error.message);
            console.log("Context:", context);
            console.log("Instance:", this.instanceId);
            console.groupEnd();
          }
          this.emit("error", errorInfo);
          const userMessage = this.getUserFriendlyMessage(error);
          this.showToast(userMessage, "error");
        }
        getUserFriendlyMessage(error) {
          const errorMessages = {
            INVALID_DATA: "\uC798\uBABB\uB41C \uB370\uC774\uD130 \uD615\uC2DD\uC785\uB2C8\uB2E4.",
            INVALID_COLUMN: "\uC798\uBABB\uB41C \uCEEC\uB7FC \uC124\uC815\uC785\uB2C8\uB2E4.",
            RENDER_FAILED: "\uADF8\uB9AC\uB4DC\uB97C \uB80C\uB354\uB9C1\uD558\uB294 \uB370 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.",
            VALIDATION_FAILED: "\uB370\uC774\uD130 \uAC80\uC99D\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4.",
            ELEMENT_NOT_FOUND: "\uD544\uC218 HTML \uC694\uC18C\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
            INITIALIZATION_FAILED: "\uADF8\uB9AC\uB4DC \uCD08\uAE30\uD654\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4."
          };
          return errorMessages[error.code] || "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.";
        }
        warn(code, message, details = {}) {
          const warning = {
            code,
            message,
            details,
            instanceId: this.instanceId,
            tableId: this.tableId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          this.warnings.push(warning);
          console.warn(`\u26A0\uFE0F SmartGrid Warning [${this.tableId}]`, `
${message}`, details);
          this.emit("warning", warning);
          if (this.debugMode) {
            this.showToast(`[\uACBD\uACE0] ${message}`, "warning");
          }
        }
        info(message, details = {}) {
          if (this.debugMode) {
            console.info(`\u2139\uFE0F SmartGrid Info [${this.tableId}]`, `
${message}`, details);
          }
        }
        // ========== 파괴 ==========
        destroy() {
          this.emit("beforeDestroy");
          this.pluginManager?.unregisterAll();
          _SmartGrid.instances.delete(this);
          this.removeAllListeners();
          this.uiComponents.destroyAll();
          this.wrapper?.remove();
          this.renderer.clearTable();
          this.table = this.columns = this.originalData = this.currentPageData = this.inputFactory = this.pluginManager = null;
          console.log(`\u2705 SmartGrid \uC778\uC2A4\uD134\uC2A4 "${this.tableId}" \uC81C\uAC70 \uC644\uB8CC`);
          if (_SmartGrid.instances.size === 0) {
            _SmartGrid.globalEventsInitialized = false;
            console.log("\u2705 \uBAA8\uB4E0 SmartGrid \uC778\uC2A4\uD134\uC2A4 \uC815\uB9AC \uC644\uB8CC");
          }
        }
      };
      // ========== 정적 상수 ==========
      __publicField(_SmartGrid, "BUTTON_CONFIG", {
        Add: { text: "\uCD94\uAC00", action: "addRow", icon: "bi bi-plus-lg" },
        Edit: { text: "\uC218\uC815", action: "setEditMode", params: [true], icon: "bi bi-pencil-square" },
        Save: { text: "\uC800\uC7A5", action: "saveRow", icon: "bi bi-save" },
        Cancel: { text: "\uCDE8\uC18C", action: "rejectRow", icon: "bi bi-x-circle" },
        Delete: { text: "\uC0AD\uC81C", action: "deleteRow", icon: "bi bi-trash" },
        Print: { text: "\uC778\uC1C4", action: "printCurrentPage", icon: "bi bi-printer" }
      });
      __publicField(_SmartGrid, "PAGE_SIZE_OPTIONS", [
        { value: 10, text: "10\uAC1C\uC529" },
        { value: 20, text: "20\uAC1C\uC529" },
        { value: 50, text: "50\uAC1C\uC529" },
        { value: 100, text: "100\uAC1C\uC529" },
        { value: "all", text: "\uC804\uCCB4 \uBCF4\uAE30" }
      ]);
      __publicField(_SmartGrid, "instances", /* @__PURE__ */ new Set());
      __publicField(_SmartGrid, "globalEventsInitialized", false);
      SmartGrid = _SmartGrid;
    }
  });

  // core/PluginBase.js
  var PluginBase;
  var init_PluginBase = __esm({
    "core/PluginBase.js"() {
      PluginBase = class _PluginBase {
        constructor(grid, options = {}) {
          if (this.constructor === _PluginBase) {
            throw new Error("PluginBase\uB294 \uC9C1\uC811 \uC778\uC2A4\uD134\uC2A4\uD654\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4");
          }
          this.grid = grid;
          this.options = options;
          this.initialized = false;
        }
        /**
         * 플러그인 고유 이름 (필수 구현)
         * @returns {string}
         */
        get name() {
          throw new Error("name getter\uB294 \uBC18\uB4DC\uC2DC \uAD6C\uD604\uD574\uC57C \uD569\uB2C8\uB2E4");
        }
        /**
         * 플러그인 버전
         * @returns {string}
         */
        get version() {
          return "1.0.0";
        }
        /**
         * 플러그인 초기화 (선택적 구현)
         */
        install() {
          this.initialized = true;
          this.grid.info(`Plugin "${this.name}" v${this.version} installed`);
        }
        /**
         * 플러그인 제거 (선택적 구현)
         */
        uninstall() {
          this.initialized = false;
          this.grid.info(`Plugin "${this.name}" uninstalled`);
        }
        /**
         * 플러그인 활성화 여부
         * @returns {boolean}
         */
        isInstalled() {
          return this.initialized;
        }
        /**
         * 에러 처리 헬퍼
         * @param {Error} error - 에러 객체
         * @param {string} context - 에러 발생 컨텍스트
         */
        handleError(error, context = "") {
          this.grid.handleError(error, `${this.name}:${context}`);
        }
        /**
         * 로깅 헬퍼
         * @param {string} message - 로그 메시지
         * @param {string} type - 로그 타입 (info, warn, error)
         */
        log(message, type = "info") {
          const prefix = `[Plugin:${this.name}]`;
          switch (type) {
            case "error":
              console.error(prefix, message);
              break;
            case "warn":
              console.warn(prefix, message);
              break;
            default:
              console.log(prefix, message);
          }
        }
        /**
         * 옵션 병합 헬퍼
         * @param {Object} defaultOptions - 기본 옵션
         * @param {Object} userOptions - 사용자 옵션
         * @returns {Object}
         */
        mergeOptions(defaultOptions, userOptions) {
          return { ...defaultOptions, ...userOptions };
        }
      };
    }
  });

  // plugins/excel.js
  var excel_exports = {};
  __export(excel_exports, {
    GridExcelPlugin: () => GridExcelPlugin
  });
  var PreviewUploadStrategy, DirectUploadStrategy, GridExcelPlugin;
  var init_excel = __esm({
    "plugins/excel.js"() {
      init_PluginBase();
      PreviewUploadStrategy = class {
        async handle(plugin, parsedData, options) {
          const { validData, errors } = plugin.validate(parsedData, options);
          if (errors.length > 0) {
            plugin.grid.showToast(errors[0], "error");
            return;
          }
          const processedData = options.dataProcessor ? options.dataProcessor(validData) : validData;
          plugin.bind(processedData, options);
          plugin.grid.showToast("\uC5D1\uC140 \uB370\uC774\uD130\uAC00 \uADF8\uB9AC\uB4DC\uC5D0 \uC131\uACF5\uC801\uC73C\uB85C \uBC14\uC778\uB529\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "success");
        }
      };
      DirectUploadStrategy = class {
        async handle(plugin, parsedData, options) {
          const { validData, errors } = plugin.validate(parsedData, options);
          if (errors.length > 0) {
            plugin.grid.showToast(errors[0], "error");
            return;
          }
          const processedData = options.dataProcessor ? options.dataProcessor(validData) : validData;
          const mappedData = plugin.mapData(processedData, options);
          plugin.grid.showConfirmModal(`\uCD1D ${mappedData.length}\uAC74\uC758 \uB370\uC774\uD130\uB97C \uC11C\uBC84\uB85C \uC804\uC1A1\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`, async (confirmed) => {
            if (confirmed) {
              await plugin.sendToServer(mappedData, options);
            }
          });
        }
      };
      GridExcelPlugin = class extends PluginBase {
        constructor(grid, options = {}) {
          super(grid, options);
          const defaultOptions = {
            columnMap: this.generateColumnMap(),
            validationRules: this.generateValidationRules(),
            dataProcessor: null
          };
          this.options = this.mergeOptions(defaultOptions, options);
        }
        /**
         * 플러그인 이름
         */
        get name() {
          return "excel";
        }
        /**
         * 플러그인 버전
         */
        get version() {
          return "1.0.0";
        }
        /**
         * 플러그인 초기화
         */
        install() {
          super.install();
          this.grid.on("beforeDestroy", () => this.uninstall());
        }
        // ========== Public Methods ==========
        /**
         * 엑셀 파일 업로드
         * @param {File} file - 엑셀 파일
         * @param {Object} options - 업로드 옵션
         * @param {string} options.mode - 'preview' | 'direct'
         * @param {string} options.url - 서버 URL (direct 모드용)
         * @param {Object} options.columnMap - 컬럼 매핑
         * @param {Object} options.validationRules - 유효성 규칙
         * @param {Function} options.dataProcessor - 데이터 전처리 함수
         */
        async upload(file, options = {}) {
          try {
            this.log(`Uploading file: ${file.name}`);
            const uploadOptions = this.mergeOptions(this.options, options);
            const parsedData = await this.parse(file);
            const strategy = uploadOptions.mode === "direct" ? new DirectUploadStrategy() : new PreviewUploadStrategy();
            await strategy.handle(this, parsedData, uploadOptions);
            this.log("Upload completed successfully");
          } catch (error) {
            this.handleError(error, "upload");
            throw error;
          }
        }
        /**
         * 그리드 데이터를 엑셀로 다운로드
         * @param {string} fileName - 파일명
         */
        async download(fileName = "grid_data.xlsx") {
          try {
            this.log(`Downloading file: ${fileName}`);
            const gridData = this.grid.getData();
            if (gridData.length === 0) {
              this.grid.showToast("\uB2E4\uC6B4\uB85C\uB4DC\uD560 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.", "info");
              return;
            }
            const dataToExport = this.prepareExportData(gridData);
            if (typeof XLSX === "undefined") {
              throw new Error("XLSX \uB77C\uC774\uBE0C\uB7EC\uB9AC\uAC00 \uB85C\uB4DC\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
            }
            const worksheet = XLSX.utils.json_to_sheet(dataToExport);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
            XLSX.writeFile(workbook, fileName);
            this.grid.showToast("\uC5D1\uC140 \uD30C\uC77C\uC774 \uB2E4\uC6B4\uB85C\uB4DC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "success");
            this.log("Download completed successfully");
          } catch (error) {
            this.handleError(error, "download");
            throw error;
          }
        }
        /**
         * 그리드 데이터를 서버로 전송
         * @param {Object} options - 전송 옵션
         * @param {string} options.url - 서버 URL
         */
        // async send(options = {}) {
        //   const dataToSend = this.grid.getData();
        //   // 데이터 없을 경우 조기 반환
        //   if (!dataToSend || dataToSend.length === 0) {
        //     this.grid.showToast('전송할 데이터가 없습니다.', 'warning');
        //     return;
        //   }
        //   await this.sendToServer(dataToSend, options);
        // }
        async send(options = {}) {
          try {
            const dataToSend = this.grid.getData();
            if (!dataToSend || dataToSend.length === 0) {
              this.grid.showToast("\uC804\uC1A1\uD560 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.", "warning");
              return;
            }
            if (options.skipConfirm === true) {
              await this.sendToServer(dataToSend, options);
            } else {
              this.grid.showConfirmModal(`\uCD1D ${dataToSend.length}\uAC74\uC758 \uB370\uC774\uD130\uB97C \uC11C\uBC84\uB85C \uC804\uC1A1\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`, async (confirmed) => {
                if (confirmed) {
                  await this.sendToServer(dataToSend, options);
                }
              });
            }
          } catch (error) {
            this.handleError(error, "send");
            throw error;
          }
        }
        // ========== Internal Methods ==========
        /**
         * 엑셀 파일 파싱
         * @private
         */
        async parse(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              try {
                if (typeof XLSX === "undefined") {
                  throw new Error("XLSX \uB77C\uC774\uBE0C\uB7EC\uB9AC\uAC00 \uB85C\uB4DC\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
                }
                const workbook = XLSX.read(reader.result, {
                  type: "array",
                  cellDates: true,
                  raw: false,
                  dateNF: "yyyy-mm-dd"
                });
                const sheetName = workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetName];
                const headers = XLSX.utils.sheet_to_json(sheet, {
                  header: 1,
                  range: 0,
                  raw: false
                })[0];
                if (!headers || headers.length === 0) {
                  throw new Error("\uC5D1\uC140 \uD30C\uC77C\uC774 \uBE44\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.");
                }
                const data = XLSX.utils.sheet_to_json(sheet, {
                  header: headers,
                  defval: "",
                  raw: false,
                  range: 1
                });
                this.log(`Parsed ${data.length} rows from Excel file`);
                resolve(data);
              } catch (err) {
                reject(err);
              }
            };
            reader.onerror = (err) => reject(err);
            reader.readAsArrayBuffer(file);
          });
        }
        /**
         * 데이터 유효성 검사
         * @private
         */
        validate(data, options) {
          const validData = [];
          const errors = [];
          const { validationRules } = options;
          for (const [index, row] of data.entries()) {
            const rowErrors = [];
            for (const excelHeader in validationRules) {
              if (validationRules[excelHeader].required) {
                const value = row[excelHeader];
                if (value === void 0 || value === null || String(value).trim() === "") {
                  rowErrors.push(`'${excelHeader}'`);
                }
              }
            }
            if (rowErrors.length > 0) {
              errors.push(`${index + 2}\uD589\uC5D0\uC11C ${rowErrors.join(", ")} \uD544\uB4DC\uC758 \uAC12\uC774 \uB204\uB77D\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
              break;
            } else {
              validData.push(row);
            }
          }
          return { validData, errors };
        }
        /**
         * 데이터 매핑 (엑셀 헤더 → 그리드 필드명)
         * @private
         */
        mapData(data, options) {
          const { columnMap } = options;
          return data.map((row) => {
            const newRow = {};
            for (const excelHeader in columnMap) {
              if (row[excelHeader] !== void 0) {
                newRow[columnMap[excelHeader]] = row[excelHeader];
              }
            }
            return newRow;
          });
        }
        /**
         * 엑셀 데이터를 그리드에 바인딩
         * @private
         */
        bind(data, options) {
          const mappedData = this.mapData(data, options);
          if (typeof this.grid.applyFormula === "function") {
            mappedData.forEach((row) => this.grid.applyFormula(row));
          }
          this.grid.invalidateSortCache();
          if (this.grid.pagingMode === "server") {
            this.grid.currentPageData = mappedData;
            this.grid.totalRows = mappedData.length;
            this.grid.currentPage = 1;
            this.grid.renderGrid();
            this.grid.renderPagination();
            this.grid.updateTotalRowsInfo();
          } else {
            this.grid.originalData = mappedData;
            this.grid.totalRows = mappedData.length;
            this.grid.currentPage = 1;
            this.grid.currentPageData = mappedData.slice(0, this.grid.pageSize);
            this.grid.renderGrid();
            this.grid.renderPagination();
            this.grid.updateTotalRowsInfo();
          }
          this.log(`Bound ${mappedData.length} rows to grid`);
        }
        /**
         * 서버로 데이터 전송
         * @private
         */
        async sendToServer(data, options) {
          if (!data || data.length === 0) {
            this.grid.showToast("\uC804\uC1A1\uD560 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.", "info");
            return;
          }
          const url = options.url || "/";
          this.log(`Sending ${data.length} rows to ${url}`);
          this.grid.showLoading();
          try {
            const response = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(data)
            });
            if (!response.ok) {
              throw new Error(`Server response error: ${response.status}`);
            }
            const result = await response.json();
            this.grid.showToast("\uB370\uC774\uD130\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uC804\uC1A1\uB418\uC5C8\uC2B5\uB2C8\uB2E4.", "success");
            this.log("Data sent successfully");
            if (options.clearAfterSend === true) {
              this.grid.loadData([]);
              this.log("Grid cleared after send");
            }
            return result;
          } catch (error) {
            this.log(`Send failed: ${error.message}`, "error");
            this.grid.showToast("\uC11C\uBC84 \uC804\uC1A1 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.", "error");
            throw error;
          } finally {
            this.grid.hideLoading();
          }
        }
        /**
         * 컬럼 매핑 자동 생성
         * @private
         */
        generateColumnMap() {
          return this.grid.columns.reduce((map, col) => {
            if (col.title && col.field) {
              map[col.title] = col.field;
            }
            return map;
          }, {});
        }
        /**
         * 유효성 검사 규칙 자동 생성
         * @private
         */
        generateValidationRules() {
          return this.grid.columns.reduce((rules, col) => {
            if (col.title && col.editor?.required) {
              rules[col.title] = { required: true };
            }
            return rules;
          }, {});
        }
        /**
         * 내보내기 데이터 준비
         * @private
         */
        prepareExportData(gridData) {
          return gridData.map((row) => {
            const newRow = {};
            this.grid.columns.forEach((col) => {
              if (!col.hideColumn && col.exportExcel !== false) {
                newRow[col.title] = row[col.field];
              }
            });
            return newRow;
          });
        }
      };
    }
  });

  // plugins/chart.js
  var chart_exports = {};
  __export(chart_exports, {
    GridChartPlugin: () => GridChartPlugin
  });
  var GridChartPlugin;
  var init_chart = __esm({
    "plugins/chart.js"() {
      init_PluginBase();
      GridChartPlugin = class extends PluginBase {
        /**
         * GridChartPlugin 생성자
         * @param {SmartGrid} grid - SmartGrid 인스턴스
         * @param {Object} options - 플러그인 옵션
         */
        constructor(grid, options = {}) {
          super(grid, options);
          const defaultOptions = {
            defaultChartType: "bar",
            modalTitle: "\uB370\uC774\uD130 \uCC28\uD2B8",
            chartLibrary: window.Chart
          };
          this.options = this.mergeOptions(defaultOptions, options);
          this.chartModalElement = null;
          this.chartInstance = null;
          this.boundHideModal = this._hideModal.bind(this);
        }
        /**
         * 플러그인 고유 이름
         */
        get name() {
          return "chart";
        }
        /**
         * 플러그인 버전
         */
        get version() {
          return "1.2.1";
        }
        /**
         * 플러그인 설치 (초기화)
         */
        install() {
          super.install();
          this.createChartModal();
          this.grid.on("beforeDestroy", () => this.uninstall());
        }
        /**
         * 플러그인 제거 (파괴)
         */
        uninstall() {
          this.chartModalElement?.remove();
          this.chartModalElement = null;
          if (this.chartInstance) {
            this.chartInstance.destroy();
            this.chartInstance = null;
          }
          super.uninstall();
        }
        // ========== Public Methods (공개 메서드) ==========
        /**
         * 차트를 생성하고 모달로 표시합니다.
         * (index.php의 헬퍼 로직 통합)
         * @param {Object} options - 차트 생성 옵션
         * @param {string} options.type - 차트 타입 (예: 'bar', 'line', 'pie')
         * @param {string} [options.groupBy] - (NEW) 데이터를 그룹화할 필드명. 지정 시 labelField는 무시됨.
         * @param {string} options.labelField - (groupBy 미지정 시) 레이블(X축)로 사용할 데이터 필드명
         * @param {string|string[]} options.dataFields - 데이터(Y축)로 사용할 필드명 (필수)
         * @param {string} [options.title] - 차트 모달에 표시될 제목
         * @param {Object} [options.chartOptions] - Chart.js에 전달할 추가 옵션
         */
        showChart(options = {}) {
          if (!this.options.chartLibrary) {
            const errorMsg = "Chart.js \uB77C\uC774\uBE0C\uB7EC\uB9AC\uAC00 \uB85C\uB4DC\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. (window.Chart\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4)";
            this.handleError(new Error(errorMsg), "showChart");
            this.grid.showToast(errorMsg, "error");
            return;
          }
          if (!this.chartModalElement) {
            this.handleError(new Error("\uCC28\uD2B8 \uBAA8\uB2EC\uC774 \uCD08\uAE30\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4."), "showChart");
            return;
          }
          try {
            const chartType = options.type || this.options.defaultChartType;
            const modalTitle = options.title || this.options.modalTitle;
            const chartData = this.generateChartData(options);
            if (!chartData) {
              return;
            }
            const titleElement = this.chartModalElement.querySelector(".smartgrid-modal-title");
            if (titleElement) titleElement.textContent = modalTitle;
            const canvas = this.chartModalElement.querySelector("canvas");
            if (!canvas) {
              this.handleError(new Error("\uBAA8\uB2EC\uC5D0\uC11C Canvas \uC694\uC18C\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."), "showChart");
              return;
            }
            this.renderChart(canvas, chartType, chartData, options.chartOptions || {});
            this.chartModalElement.classList.add("show");
          } catch (error) {
            this.handleError(error, "showChart");
            this.grid.showToast("\uCC28\uD2B8 \uC0DD\uC131 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.", "error");
          }
        }
        /**
         * 차트 모달을 숨깁니다.
         */
        hideChart() {
          this._hideModal();
        }
        // ========== Internal Methods (내부 메서드) ==========
        /**
         * 차트를 표시할 모달 UI를 생성합니다. (UIComponents.js 참고)
         * @private
         */
        createChartModal() {
          if (this.chartModalElement) return;
          const modal = document.createElement("div");
          modal.id = `${this.grid.instanceId}_chartModal`;
          modal.className = "smartgrid-modal smartgrid-chart-modal";
          modal.setAttribute("data-instance", this.grid.instanceId);
          modal.innerHTML = `
      <div class="smartgrid-modal-backdrop" data-instance="${this.grid.instanceId}"></div>
      <div class="smartgrid-modal-content" data-instance="${this.grid.instanceId}" style="max-width: 800px; width: 90%;">
        <div class="smartgrid-modal-header">
          <h5 class="smartgrid-modal-title">${this.options.modalTitle}</h5>
          <button class="smartgrid-modal-close" data-instance="${this.grid.instanceId}">&times;</button>
        </div>
        <div class="smartgrid-modal-body" style="padding: 1rem; max-height: 70vh; overflow-y: auto;">
          <canvas id="${this.grid.instanceId}_chartCanvas"></canvas>
        </div>
        <div class="smartgrid-modal-footer">
          <button class="smartgrid-btn smartgrid-btn-secondary" data-dismiss="modal" data-instance="${this.grid.instanceId}">\uB2EB\uAE30</button>
        </div>
      </div>
    `;
          document.body.appendChild(modal);
          this.chartModalElement = modal;
          const closeTriggers = modal.querySelectorAll(`
      [data-dismiss="modal"],
      .smartgrid-modal-close,
      .smartgrid-modal-backdrop
    `);
          closeTriggers.forEach((btn) => {
            btn.addEventListener("click", this.boundHideModal);
          });
        }
        /**
         * 모달을 숨기고 차트 인스턴스를 파괴하는 내부 함수
         * @private
         */
        _hideModal() {
          if (this.chartModalElement) {
            this.chartModalElement.classList.remove("show");
          }
          if (this.chartInstance) {
            this.chartInstance.destroy();
            this.chartInstance = null;
          }
        }
        /**
         * 그리드 데이터로부터 Chart.js 형식의 데이터를 생성합니다.
         * (groupBy 옵션 추가됨)
         * @private
         */
        generateChartData(options) {
          const { labelField, dataFields, groupBy } = options;
          if (!dataFields || Array.isArray(dataFields) && dataFields.length === 0 || typeof dataFields !== "string" && !Array.isArray(dataFields)) {
            this.grid.showToast("\uCC28\uD2B8 \uB370\uC774\uD130 \uD544\uB4DC(dataFields)\uAC00 \uC9C0\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.", "warning");
            return null;
          }
          const gridData = this.grid.getRows();
          if (gridData.length === 0) {
            this.grid.showToast("\uCC28\uD2B8\uB97C \uC0DD\uC131\uD560 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.", "info");
            return null;
          }
          const fields = Array.isArray(dataFields) ? dataFields : [dataFields];
          let labels = [];
          let datasets = [];
          if (groupBy) {
            const groups = /* @__PURE__ */ new Map();
            gridData.forEach((row) => {
              const key = row[groupBy] || "\uBBF8\uBD84\uB958";
              if (!groups.has(key)) {
                const newGroup = {};
                fields.forEach((field) => {
                  newGroup[field] = 0;
                });
                groups.set(key, newGroup);
              }
              const group = groups.get(key);
              fields.forEach((field) => {
                group[field] += parseFloat(row[field]) || 0;
              });
            });
            labels = Array.from(groups.keys());
            datasets = fields.map((field) => {
              const column = this.grid.columns.find((c) => c.field === field);
              return {
                label: column ? column.title : field,
                // 범례 (예: '수량')
                data: labels.map((key) => groups.get(key)[field])
                // (예: [150, 200, ...])
              };
            });
          } else {
            labels = gridData.map((row) => labelField ? row[labelField] : "");
            datasets = fields.map((field) => {
              const column = this.grid.columns.find((c) => c.field === field);
              return {
                label: column ? column.title : field,
                data: gridData.map((row) => parseFloat(row[field]) || 0)
              };
            });
          }
          return {
            labels,
            datasets
          };
        }
        /**
         * Canvas에 Chart.js 차트를 렌더링합니다.
         * @private
         */
        renderChart(canvas, type, data, chartOptions = {}) {
          if (this.chartInstance) {
            this.chartInstance.destroy();
          }
          const Chart = this.options.chartLibrary;
          try {
            this.chartInstance = new Chart(canvas, {
              type,
              data,
              options: this.mergeOptions(
                {
                  responsive: true,
                  maintainAspectRatio: true,
                  plugins: {
                    legend: {
                      position: "top"
                    },
                    title: {
                      display: false
                    }
                  }
                },
                chartOptions
              )
            });
          } catch (e) {
            this.handleError(e, "renderChart");
            this.grid.showToast(`\uCC28\uD2B8 \uB80C\uB354\uB9C1 \uC2E4\uD328: ${e.message}`, "error");
          }
        }
      };
    }
  });

  // index.js
  var index_exports = {};
  __export(index_exports, {
    ClientSideHandler: () => ClientSideHandler,
    DataHandler: () => DataHandler,
    EventEmitter: () => EventEmitter,
    GridChartPlugin: () => GridChartPlugin,
    GridEvents: () => GridEvents,
    GridExcelPlugin: () => GridExcelPlugin,
    GridRenderer: () => GridRenderer,
    InputFactory: () => InputFactory,
    PluginBase: () => PluginBase,
    ServerSideHandler: () => ServerSideHandler,
    SmartGrid: () => SmartGrid,
    SmartGridError: () => SmartGridError,
    UIComponents: () => UIComponents,
    createSvgUse: () => createSvgUse,
    deepClone: () => deepClone,
    default: () => SmartGrid,
    formatNumber: () => formatNumber,
    getCurrentDateTime: () => getCurrentDateTime,
    isEmpty: () => isEmpty,
    sleep: () => sleep,
    stripHtml: () => stripHtml
  });
  init_EventEmitter();
  init_SmartGridError();
  init_SmartGrid();
  init_DataHandler();
  init_InputFactory();
  init_UIComponents();
  init_GridRenderer();
  init_GridEvents();
  init_utils();
  init_PluginBase();
  init_excel();
  init_chart();
  init_SmartGrid();
  if (typeof window !== "undefined") {
    Promise.resolve().then(() => (init_SmartGrid(), SmartGrid_exports)).then((module) => {
      window.SmartGrid = module.SmartGrid;
    });
    Promise.resolve().then(() => (init_excel(), excel_exports)).then((module) => {
      window.GridExcelPlugin = module.GridExcelPlugin;
    });
    Promise.resolve().then(() => (init_chart(), chart_exports)).then((module) => {
      window.GridChartPlugin = module.GridChartPlugin;
    });
  }
  return __toCommonJS(index_exports);
})();
