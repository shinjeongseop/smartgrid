var smartGrid = (function (exports) {
  'use strict';

  /**
   * EventEmitter Class
   * @version 1.0.0
   * @description ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ë¥¼ ìœ„í•œ ì´ë²¤íŠ¸ ê´€ë¦¬ í´ë˜ìŠ¤
   */

  class EventEmitter {
    events = new Map();
    maxListeners = 10;

    /**
     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
     * @param {string} eventName - ì´ë²¤íŠ¸ ì´ë¦„
     * @param {Function} listener - ë¦¬ìŠ¤ë„ˆ í•¨ìˆ˜
     * @returns {Function} ë¦¬ìŠ¤ë„ˆ ì œê±° í•¨ìˆ˜
     */
    on(eventName, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('Listener must be a function');
      }
      if (!this.events.has(eventName)) {
        this.events.set(eventName, []);
      }
      const listeners = this.events.get(eventName);
      if (listeners.length >= this.maxListeners) {
        console.warn(`Possible EventEmitter memory leak detected. ${listeners.length + 1} ${eventName} listeners added. Use setMaxListeners() to increase limit`);
      }
      listeners.push(listener);
      return () => this.off(eventName, listener);
    }

    /**
     * ì¼íšŒì„± ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
     * @param {string} eventName - ì´ë²¤íŠ¸ ì´ë¦„
     * @param {Function} listener - ë¦¬ìŠ¤ë„ˆ í•¨ìˆ˜
     * @returns {Function} ë¦¬ìŠ¤ë„ˆ ì œê±° í•¨ìˆ˜
     */
    once(eventName, listener) {
      const wrapper = (...args) => {
        listener(...args);
        this.off(eventName, wrapper);
      };
      wrapper.listener = listener;
      return this.on(eventName, wrapper);
    }

    /**
     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
     * @param {string} eventName - ì´ë²¤íŠ¸ ì´ë¦„
     * @param {Function} listener - ì œê±°í•  ë¦¬ìŠ¤ë„ˆ í•¨ìˆ˜
     * @returns {boolean} ì œê±° ì„±ê³µ ì—¬ë¶€
     */
    off(eventName, listener) {
      if (!this.events.has(eventName)) return false;
      const listeners = this.events.get(eventName);
      const index = listeners.findIndex((l) => l === listener || l.listener === listener);
      if (index !== -1) {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          this.events.delete(eventName);
        }
        return true;
      }
      return false;
    }

    /**
     * ì´ë²¤íŠ¸ ë°œìƒ
     * @param {string} eventName - ì´ë²¤íŠ¸ ì´ë¦„
     * @param {...any} args - ë¦¬ìŠ¤ë„ˆì— ì „ë‹¬í•  ì¸ì
     * @returns {boolean} ë¦¬ìŠ¤ë„ˆ í˜¸ì¶œ ì—¬ë¶€
     */
    emit(eventName, ...args) {
      if (!this.events.has(eventName)) return false;
      const listeners = [...this.events.get(eventName)];
      for (const listener of listeners) {
        try {
          listener(...args);
        } catch (error) {
          console.error(`Error in event listener for "${eventName}":`, error);
          this.emit('error', { eventName, error, listener });
        }
      }
      return true;
    }

    /**
     * ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
     * @param {string} [eventName] - íŠ¹ì • ì´ë²¤íŠ¸ ì´ë¦„ (ì„ íƒì‚¬í•­)
     * @returns {boolean} ì œê±° ì„±ê³µ ì—¬ë¶€
     */
    removeAllListeners(eventName) {
      if (eventName) {
        return this.events.delete(eventName);
      }
      this.events.clear();
      return true;
    }

    /**
     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ê°œìˆ˜ ë°˜í™˜
     * @param {string} eventName - ì´ë²¤íŠ¸ ì´ë¦„
     * @returns {number} ë¦¬ìŠ¤ë„ˆ ê°œìˆ˜
     */
    listenerCount(eventName) {
      return this.events.get(eventName)?.length ?? 0;
    }

    /**
     * ë“±ë¡ëœ ëª¨ë“  ì´ë²¤íŠ¸ ì´ë¦„ ë°˜í™˜
     * @returns {string[]} ì´ë²¤íŠ¸ ì´ë¦„ ë°°ì—´
     */
    eventNames() {
      return Array.from(this.events.keys());
    }

    /**
     * ìµœëŒ€ ë¦¬ìŠ¤ë„ˆ ê°œìˆ˜ ì„¤ì •
     * @param {number} n - ìµœëŒ€ ê°œìˆ˜
     * @returns {EventEmitter} ì²´ì´ë‹ì„ ìœ„í•œ this ë°˜í™˜
     */
    setMaxListeners(n) {
      this.maxListeners = n;
      return this;
    }

    /**
     * ìµœëŒ€ ë¦¬ìŠ¤ë„ˆ ê°œìˆ˜ ë°˜í™˜
     * @returns {number} ìµœëŒ€ ë¦¬ìŠ¤ë„ˆ ê°œìˆ˜
     */
    getMaxListeners() {
      return this.maxListeners;
    }
  }

  /**
   * SmartGridError Class
   * @version 1.0.0
   * @description SmartGrid ì „ìš© ì—ëŸ¬ í´ë˜ìŠ¤
   */

  class SmartGridError extends Error {
    /**
     * SmartGridError ìƒì„±ì
     * @param {string} message - ì—ëŸ¬ ë©”ì‹œì§€
     * @param {string} code - ì—ëŸ¬ ì½”ë“œ
     * @param {string} instanceId - ê·¸ë¦¬ë“œ ì¸ìŠ¤í„´ìŠ¤ ID
     * @param {Object} details - ì¶”ê°€ ìƒì„¸ ì •ë³´
     */
    constructor(message, code, instanceId, details = {}) {
      super(message);
      this.name = 'SmartGridError';
      this.code = code;
      this.instanceId = instanceId;
      this.details = details;
      this.timestamp = new Date().toISOString();
    }
  }

  /**
   * Utility Functions
   * @version 1.0.0
   * @description SmartGrid ê³µí†µ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ëª¨ìŒ
   */

  /**
   * ìˆ«ìë¥¼ í¬ë§·íŒ…í•˜ì—¬ ë°˜í™˜
   * @param {number|string} value - í¬ë§·íŒ…í•  ê°’
   * @param {number} decimalPlaces - ì†Œìˆ˜ì  ìë¦¿ìˆ˜ (ê¸°ë³¸ê°’: 0)
   * @returns {string} í¬ë§·íŒ…ëœ ë¬¸ìì—´
   */
  function formatNumber(value, decimalPlaces = 0) {
    if (value === null || value === undefined || value === '') return '';
    const number = parseFloat(value);
    if (isNaN(number)) return String(value);
    return number.toLocaleString('ko-KR', {
      minimumFractionDigits: decimalPlaces,
      maximumFractionDigits: decimalPlaces,
    });
  }

  /**
   * HTML íƒœê·¸ë¥¼ ì œê±°í•˜ê³  í…ìŠ¤íŠ¸ë§Œ ë°˜í™˜
   * @param {string} html - HTML ë¬¸ìì—´
   * @returns {string} íƒœê·¸ê°€ ì œê±°ëœ í…ìŠ¤íŠ¸
   */
  function stripHtml(html) {
    const div = document.createElement('div');
    div.innerHTML = html;
    return div.textContent || div.innerText || '';
  }

  /**
   * í˜„ì¬ ë‚ ì§œ/ì‹œê°„ì„ í¬ë§·íŒ…í•˜ì—¬ ë°˜í™˜
   * @returns {string} YYYY-MM-DD í˜•ì‹ì˜ ë‚ ì§œ
   */
  function getCurrentDateTime() {
    return new Date().toLocaleDateString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit' }).replace(/\. /g, '-').replace('.', '');
  }

  /**
   * SVG use ìš”ì†Œë¥¼ ìƒì„±í•˜ì—¬ ë°˜í™˜
   * @param {string} iconId - ì•„ì´ì½˜ ID (ì˜ˆ: '#icon-chevron-left')
   * @returns {string} SVG HTML ë¬¸ìì—´
   */
  function createSvgUse(iconId) {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '16');
    svg.setAttribute('height', '16');
    const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
    use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', iconId);
    svg.appendChild(use);
    return svg.outerHTML;
  }

  /**
   * ì§€ì—° ì‹¤í–‰ì„ ìœ„í•œ Promise ê¸°ë°˜ sleep í•¨ìˆ˜
   * @param {number} ms - ëŒ€ê¸° ì‹œê°„ (ë°€ë¦¬ì´ˆ)
   * @returns {Promise} Promise ê°ì²´
   */
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * ê¹Šì€ ë³µì‚¬ (structuredClone ë˜í¼)
   * @param {any} obj - ë³µì‚¬í•  ê°ì²´
   * @returns {any} ë³µì‚¬ëœ ê°ì²´
   */
  function deepClone(obj) {
    return structuredClone(obj);
  }

  /**
   * ê°ì²´ê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
   * @param {Object} obj - í™•ì¸í•  ê°ì²´
   * @returns {boolean} ë¹„ì–´ìˆìœ¼ë©´ true
   */
  function isEmpty(obj) {
    return Object.keys(obj).length === 0;
  }

  /**
   * DataHandler Classes (Strategy Pattern)
   * @version 1.0.0
   * @description ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ í•¸ë“¤ëŸ¬ í´ë˜ìŠ¤ (ì¶”ìƒ í´ë˜ìŠ¤ + êµ¬í˜„ì²´ 2ê°œ)
   */

  // ========== ì¶”ìƒ í´ë˜ìŠ¤ ==========
  class DataHandler {
    constructor(grid) {
      if (this.constructor === DataHandler) {
        throw new TypeError('Abstract class "DataHandler" cannot be instantiated directly.');
      }
      this.grid = grid;
    }

    async load(dataOrParams) {
      throw new Error('Method "load" must be implemented.');
    }

    async page() {
      throw new Error('Method "page" must be implemented.');
    }

    async sort() {
      throw new Error('Method "sort" must be implemented.');
    }

    async add() {
      throw new Error('Method "add" must be implemented.');
    }

    async save() {
      throw new Error('Method "save" must be implemented.');
    }

    async reject() {
      throw new Error('Method "reject" must be implemented.');
    }

    async delete() {
      throw new Error('Method "delete" must be implemented.');
    }

    getSortedData() {
      throw new Error('Method "getSortedData" must be implemented.');
    }

    updateTotalRowsInfo() {
      throw new Error('Method "updateTotalRowsInfo" must be implemented.');
    }
  }

  // ========== í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ í•¸ë“¤ëŸ¬ ==========
  class ClientSideHandler extends DataHandler {
    sortedDataCache = null;
    sortCacheKey = null;

    constructor(grid) {
      super(grid);
      this.grid.pagingMode = 'client';
    }

    async load(data) {
      const { grid } = this;
      try {
        if (!Array.isArray(data)) {
          throw new SmartGridError('ë°ì´í„°ëŠ” ë°°ì—´ í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤.', 'INVALID_DATA', grid.instanceId, { dataType: typeof data });
        }
        grid.info('ë°ì´í„° ë¡œë“œ ì‹œì‘', { rowCount: data.length });

        if (data.length > 10000) {
          grid.warn('LARGE_DATASET', `ëŒ€ìš©ëŸ‰ ë°ì´í„°(${data.length}í–‰)ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        let processedData = deepClone(data);
        if (grid.options.loadFilter) {
          processedData = grid.options.loadFilter(processedData);
        }
        processedData.forEach((row) => grid.applyFormula(row));

        grid.originalData = processedData;
        grid.originalDataBackup = deepClone(grid.originalData);
        grid.totalRows = grid.originalData.length;
        grid.currentPage = 1;

        // ìºì‹œ ì´ˆê¸°í™” - í•µì‹¬!
        this.sortedDataCache = null;
        this.sortCacheKey = null;

        if (grid.options.isEditMode) {
          grid.isEditMode = true;
        }

        this.page();

        grid.emit('afterLoad', { data: grid.originalData, totalRows: grid.totalRows });
        grid.options.onLoadSuccess?.(grid.originalData, grid.totalRows, grid);
        return grid.originalData;
      } catch (error) {
        grid.handleError(error, 'loadData');
        grid.emit('loadError', { error });
        grid.options.onLoadError?.(error, grid);
        grid.originalData = [];
        grid.totalRows = 0;

        // ìºì‹œ ì´ˆê¸°í™”
        this.sortedDataCache = null;
        this.sortCacheKey = null;

        this.page();
        throw error;
      }
    }

    page() {
      const { grid } = this;
      const sortedData = this.getSortedData();
      grid.totalRows = sortedData.length;

      const startIndex = (grid.currentPage - 1) * grid.pageSize;
      const endIndex = startIndex + grid.pageSize;
      grid.currentPageData = sortedData.slice(startIndex, endIndex);

      if (grid.currentPageData.length === 0 && grid.totalRows > 0) {
        grid.currentPage = Math.ceil(grid.totalRows / grid.pageSize) || 1;
        return this.page();
      }

      grid.renderGrid();
      grid.columns.forEach((col) => grid.updateSortIndicator(col.field));
      grid.renderPagination();
      this.updateTotalRowsInfo();
    }

    sort() {
      this.invalidateSortCache();
      this.grid.currentPage = 1;
      this.page();
      this.grid.columns.forEach((col) => this.grid.updateSortIndicator(col.field));
    }

    add() {
      const { grid } = this;

      if (grid.isEditMode) {
        grid.showToast('ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” í–‰ì„ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì €ì¥í•˜ê±°ë‚˜ ì·¨ì†Œí•´ì£¼ì„¸ìš”.', 'warning');
        return;
      }
      if (grid.changedRows.newRows.length > 0) {
        grid.showToast('ë¨¼ì € ì¶”ê°€ëœ í–‰ì„ ì €ì¥í•´ì£¼ì„¸ìš”.', 'warning');
        return;
      }
      grid.emit('beforeRowAdd', { cancelled: false });

      // originalDataBackup ìƒì„±
      if (!grid.originalDataBackup || grid.originalDataBackup.length === 0) {
        grid.originalDataBackup = deepClone(grid.originalData);
      }

      const newRow = grid.columns.reduce(
        (acc, col, index) => {
          if (col.formula) {
            // ìˆ˜ì •: evaluateFormulaì— newRow ëŒ€ì‹  í˜„ì¬ ëˆ„ì ëœ accë¥¼ ì „ë‹¬
            acc[col.field] = grid.evaluateFormula(col.formula, acc, index);
          } else {
            const rawDefaultVal = col.editor?.defaultVal;
            let defaultValue;

            if (typeof rawDefaultVal === 'function') {
              try {
                defaultValue = rawDefaultVal(col, grid);
              } catch (e) {
                console.error(`defaultVal í•¨ìˆ˜ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ (í•„ë“œ: ${col.field}):`, e);
                defaultValue = undefined;
              }
            }

            if (defaultValue === undefined && (col.editor?.type === 'selectbox' || col.editor?.type === 'radiobutton') && Array.isArray(col.editor.options) && col.editor.options.length > 0) {
              defaultValue = col.editor.options[0].val;
            }

            acc[col.field] = defaultValue ?? '';
          }
          return acc;
        },
        { [grid.idField]: `new_${Date.now()}` }
      );

      grid.originalData.unshift(newRow);
      grid.changedRows.newRows.push(newRow);
      this.invalidateSortCache();
      grid.currentPage = 1;
      this.page();
      grid.emit('afterRowAdd', { row: newRow });
      grid.showToast('ìƒˆ í–‰ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
    }

    async save() {
      const { grid } = this;
      if (!grid.validateChanges()) return;

      const { newRows, updatedRows, deletedRows } = grid.changedRows;
      if (newRows.length === 0 && updatedRows.length === 0 && deletedRows.length === 0) {
        grid.showToast('ë³€ê²½ëœ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.', 'info');
        return;
      }

      const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
      grid.emit('beforeSave', beforeEvent);
      if (beforeEvent.cancelled) return;

      try {
        grid.showToast(`ì´ ${newRows.length}ê°œ ì¶”ê°€, ${updatedRows.length}ê°œ ìˆ˜ì •, ${deletedRows.length}ê°œ ì‚­ì œ ì™„ë£Œ`, 'success');
        grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
        grid.originalDataBackup = [];
        grid.emit('afterSave', { changes: beforeEvent.changes });

        if (grid.isEditMode) {
          grid.setEditMode(false);
        } else {
          grid.renderGrid();
        }
      } catch (error) {
        grid.emit('saveError', { error, changes: grid.changedRows });
        grid.showToast('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
      }
    }

    async reject() {
      const { grid } = this;
      grid.showConfirmModal('ëª¨ë“  ë³€ê²½ ì‚¬í•­ì„ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?', (confirmed) => {
        if (confirmed) {
          const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
          grid.emit('beforeCancel', beforeEvent);
          if (beforeEvent.cancelled) return;

          if (grid.originalDataBackup && grid.originalDataBackup.length > 0) {
            grid.originalData = deepClone(grid.originalDataBackup);
          }
          grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
          grid.originalDataBackup = [];

          if (grid.isEditMode) {
            grid.isEditMode = false;
          }

          this.invalidateSortCache();
          this.page();

          grid.emit('afterCancel', {});
          grid.showToast('ëª¨ë“  ë³€ê²½ ì‚¬í•­ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
        }
      });
    }

    async delete() {
      const { grid } = this;
      const selectedRows = grid.currentPageData.filter((row) => row.checked);
      if (selectedRows.length === 0) {
        grid.showToast('ì‚­ì œí•  í–‰ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
        return;
      }

      grid.showConfirmModal(`ì„ íƒëœ ${selectedRows.length}ê°œì˜ í–‰ì„ ì¦‰ì‹œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤)`, (confirmed) => {
        if (confirmed) {
          const beforeEvent = { rows: [...selectedRows], cancelled: false };
          grid.emit('beforeRowDelete', beforeEvent);
          if (beforeEvent.cancelled) return;

          const selectedIds = new Set(selectedRows.map((row) => row[grid.idField]));

          grid.changedRows.newRows = grid.changedRows.newRows.filter((r) => !selectedIds.has(r[grid.idField]));
          grid.changedRows.updatedRows = grid.changedRows.updatedRows.filter((r) => !selectedIds.has(r[grid.idField]));

          grid.originalData = grid.originalData.filter((r) => !selectedIds.has(r[grid.idField]));

          this.invalidateSortCache();
          this.page();

          grid.emit('afterRowDelete', { rows: selectedRows });
          grid.showToast(`${selectedRows.length}ê°œì˜ í–‰ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
        }
      });
    }

    getSortedData() {
      const { grid } = this;
      const sortKey = JSON.stringify(grid.sortOrders);
      // const filterKey = JSON.stringify(grid.filters); // í•„í„° ë¡œì§ ì œê±°
      const cacheKey = sortKey; // í•„í„° í‚¤ ì œê±°
      if (this.sortCacheKey === cacheKey && this.sortedDataCache) {
        return [...this.sortedDataCache];
      }
      let dataToProcess = [...grid.originalData]; // applyFilters í˜¸ì¶œ ì œê±°
      if (grid.sortOrders.length > 0) {
        dataToProcess.sort(grid.compareRowsForSort.bind(grid));
      }

      this.sortedDataCache = dataToProcess;
      this.sortCacheKey = cacheKey;
      return [...dataToProcess];
    }

    updateTotalRowsInfo() {
      const { grid } = this;
      if (!grid.options.enableTotalRows || !grid.totalRowsElement) return;
      // const filteredCount = this.getSortedData().length; // getSortedData()ëŠ” ì´ì œ í•­ìƒ ì „ì²´ ì¹´ìš´íŠ¸ë¥¼ ë°˜í™˜
      const totalCount = grid.originalData.length;
      grid.totalRowsElement.textContent = `ì „ì²´ ë°ì´í„°: ${totalCount}ê°œ`;
    }

    invalidateSortCache() {
      this.sortedDataCache = null;
      this.sortCacheKey = null;
    }
  }

  // ========== ì„œë²„ ì‚¬ì´ë“œ í•¸ë“¤ëŸ¬ ==========
  class ServerSideHandler extends DataHandler {
    constructor(grid) {
      super(grid);
      this.grid.pagingMode = 'server';
      if (!this.grid.options.url) {
        throw new SmartGridError('ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.', 'INVALID_DATA', this.grid.instanceId);
      }
    }

    async load() {
      const { grid } = this;
      grid.showLoading();
      try {
        const beforeEvent = { params: grid.lastParams, cancelled: false };
        grid.emit('beforeLoad', beforeEvent);
        if (beforeEvent.cancelled) return;

        const requestParams = {
          // 1. ì •ì  ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° (search_status: 'ëŒ€ê¸°' ë“±ì˜ ê¸°ë³¸ê°’ ì„¤ì •)
          ...grid.options.queryParams,

          // 2. í˜„ì¬ ê·¸ë¦¬ë“œ ìƒíƒœ (í˜ì´ì§•/ì •ë ¬. queryParamsì˜ page/pageSize/sortOrdersë¥¼ ë®ì–´ì”€)
          page: grid.currentPage,
          pageSize: grid.pageSize,
          sortOrders: grid.sortOrders,

          // 3. ë™ì  íŒŒë¼ë¯¸í„° (íˆ´ë°” í•„í„° ë˜ëŠ” fetchData ì¸ì. 1, 2ë¥¼ ëª¨ë‘ ë®ì–´ì“°ë©° ê°€ì¥ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§)
          ...grid.lastParams,
        };
        //const finalParams = grid.options.queryParams ? grid.options.queryParams(requestParams) : requestParams;

        const response = await fetch(grid.options.url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestParams),
        });

        if (!response.ok) {
          throw new SmartGridError(`ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜: ${response.status} ${response.statusText}`, 'INVALID_DATA', grid.instanceId);
        }

        const result = await response.json();
        if (!result.success) {
          throw new SmartGridError(result.error || 'ì„œë²„ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'INVALID_DATA', grid.instanceId);
        }

        const processedData = grid.options.loadFilter ? grid.options.loadFilter(result) : result;
        const rows = processedData.rows ?? processedData.data ?? (Array.isArray(processedData) ? processedData : []);
        const total = processedData.total ?? processedData.count ?? rows.length;

        rows.forEach((row) => grid.applyFormula(row));

        grid.originalData = rows;
        grid.totalRows = total;
        grid.currentPageData = rows;

        grid.renderGrid();
        grid.renderPagination();
        this.updateTotalRowsInfo();
        grid.columns.forEach((col) => grid.updateSortIndicator(col.field));

        grid.emit('afterLoad', { data: rows, totalRows: total });
        grid.options.onLoadSuccess?.(rows, total, grid);
        return rows;
      } catch (error) {
        grid.handleError(error, 'fetchData');
        grid.emit('loadError', { error });
        grid.options.onLoadError?.(error, grid);
        grid.renderGrid();
        throw error;
      } finally {
        await new Promise((resolve) => setTimeout(resolve, 300));
        grid.hideLoading();
      }
    }

    async page() {
      await this.load();
    }

    async add() {
      const { grid } = this;

      if (grid.isEditMode) {
        grid.showToast('ìˆ˜ì • ëª¨ë“œì—ì„œëŠ” í–‰ì„ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì €ì¥í•˜ê±°ë‚˜ ì·¨ì†Œí•´ì£¼ì„¸ìš”.', 'warning');
        return;
      }
      // ğŸŒŸ ì¶”ê°€: ìƒˆ í–‰ ì²´í¬
      if (grid.changedRows.newRows.length > 0) {
        grid.showToast('ë¨¼ì € ì¶”ê°€ëœ í–‰ì„ ì €ì¥í•´ì£¼ì„¸ìš”.', 'warning');
        return;
      }

      const beforeEvent = { cancelled: false };
      grid.emit('beforeRowAdd', beforeEvent);
      if (beforeEvent.cancelled) return;

      const newRow = grid.columns.reduce(
        (acc, col) => {
          if (col.formula) {
            acc[col.field] = grid.evaluateFormula(col.formula, acc, col); // L502
          } else {
            // 1. ì›ë³¸ defaultValì„ ê°€ì ¸ì˜µë‹ˆë‹¤ (í•¨ìˆ˜ì—¬ì•¼ í•¨)
            const rawDefaultVal = col.editor?.defaultVal;
            let defaultValue; // 2. undefinedë¡œ ì´ˆê¸°í™” // 3. [ìˆ˜ì •] defaultValì´ í•¨ìˆ˜ì¸ ê²½ìš°ì—ë§Œ ì‹¤í–‰

            if (typeof rawDefaultVal === 'function') {
              try {
                defaultValue = rawDefaultVal(col, this.grid);
              } catch (e) {
                console.error(`defaultVal í•¨ìˆ˜ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ (í•„ë“œ: ${col.field}):`, e);
                defaultValue = undefined;
              }
            } // 4. (ì œê±°) í•¨ìˆ˜ê°€ ì•„ë‹Œ ê²½ìš° (ë¬¸ìì—´ ë“±)ëŠ” ë¬´ì‹œë¨ // 5. Selectbox/Radiobutton ê¸°ë³¸ê°’ ì²˜ë¦¬ (ê¸°ë³¸ê°’ í•¨ìˆ˜ê°€ ì—†ê±°ë‚˜ undefined ë°˜í™˜ ì‹œ)
            if (defaultValue === undefined && (col.editor?.type === 'selectbox' || col.editor?.type === 'radiobutton') && Array.isArray(col.editor.options) && col.editor.options.length > 0) {
              defaultValue = col.editor.options[0].val;
            } // 6. ìµœì¢… í• ë‹¹

            acc[col.field] = defaultValue ?? '';
          }
          return acc;
        },
        { [grid.idField]: `new_${Date.now()}` }
      );

      grid.currentPageData.unshift(newRow);
      grid.changedRows.newRows.push(newRow);

      grid.renderGrid();

      grid.emit('afterRowAdd', { row: newRow });
      grid.showToast('ìƒˆ í–‰ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. ì €ì¥ ì‹œ ì„œë²„ì— ë°˜ì˜ë©ë‹ˆë‹¤.', 'success');
    }

    async sort() {
      this.grid.currentPage = 1;
      await this.load();
    }

    async save() {
      const { grid } = this;
      const context = 'saveToServer';

      try {
        const { newRows, updatedRows, deletedRows } = grid.changedRows;
        if (newRows.length === 0 && updatedRows.length === 0 && deletedRows.length === 0) {
          grid.showToast('ë³€ê²½ëœ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.', 'info');
          return;
        }
        if (!grid.validateChanges()) return;

        const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
        grid.emit('beforeSave', beforeEvent);
        if (beforeEvent.cancelled) return;

        grid.showLoading();

        const results = { inserted: 0, updated: 0, deleted: 0, errors: [] };
        const { writeUrl, updateUrl, deleteUrl } = grid.options;

        if (newRows.length > 0 && writeUrl) {
          try {
            const res = await this.sendRequest(writeUrl, newRows); // âœ… ë°°ì—´ë§Œ ì „ì†¡
            results.inserted = res.inserted ?? newRows.length;
          } catch (error) {
            results.errors.push({ type: 'insert', error: error.message });
          }
        }

        if (updatedRows.length > 0 && updateUrl) {
          try {
            const res = await this.sendRequest(updateUrl, updatedRows); // âœ… ë°°ì—´ë§Œ ì „ì†¡
            results.updated = res.updated ?? updatedRows.length;
            grid.isEditMode = false;
          } catch (error) {
            results.errors.push({ type: 'update', error: error.message });
          }
        }

        if (deletedRows.length > 0 && deleteUrl) {
          try {
            const ids = deletedRows.map((row) => row[grid.idField]);
            const res = await this.sendRequest(deleteUrl, ids); // âœ… ë°°ì—´ë§Œ ì „ì†¡
            results.deleted = res.deleted ?? deletedRows.length;
          } catch (error) {
            results.errors.push({ type: 'delete', error: error.message });
          }
        }

        grid.hideLoading();

        if (results.errors.length > 0) {
          const errorMessages = results.errors.map((e) => `${e.type}: ${e.error}`).join('\n');
          grid.showToast(`ì¼ë¶€ ì‘ì—…ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n${errorMessages}`, 'error');
          grid.emit('saveError', { results });
        } else {
          grid.showToast(`ì´ ${results.inserted}ê°œ ì¶”ê°€, ${results.updated}ê°œ ìˆ˜ì •, ${results.deleted}ê°œ ì‚­ì œ ì™„ë£Œ`, 'success');
          grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
          grid.originalDataBackup = [];
          grid.emit('afterSave', { results });
          await this.load();
        }
      } catch (error) {
        grid.handleError(error, context);
        grid.emit('saveError', { error });
        grid.showToast('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
      }
    }

    async sendRequest(url, body) {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!response.ok) throw new Error(`Request failed with status ${response.status}`);
      const result = await response.json();
      if (!result.success) throw new Error(result.error || 'Request failed');
      return result;
    }

    async reject() {
      const { grid } = this;
      grid.showConfirmModal('ëª¨ë“  ë³€ê²½ ì‚¬í•­ì„ ì·¨ì†Œí•˜ê³  ì„œë²„ì—ì„œ ë°ì´í„°ë¥¼ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ?', (confirmed) => {
        if (confirmed) {
          const beforeEvent = { changes: deepClone(grid.changedRows), cancelled: false };
          grid.emit('beforeCancel', beforeEvent);
          if (beforeEvent.cancelled) return;

          grid.changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
          grid.originalDataBackup = [];
          if (grid.isEditMode) {
            grid.isEditMode = false;
          }

          this.load();

          grid.emit('afterCancel', {});
          grid.showToast('ëª¨ë“  ë³€ê²½ ì‚¬í•­ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
        }
      });
    }

    async delete() {
      const { grid } = this;
      const selectedRows = grid.currentPageData.filter((row) => row.checked);
      if (selectedRows.length === 0) {
        grid.showToast('ì‚­ì œí•  í–‰ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
        return;
      }

      grid.showConfirmModal(`ì„ íƒëœ ${selectedRows.length}ê°œì˜ í–‰ì„ ì„œë²„ì—ì„œ ì¦‰ì‹œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤)`, async (confirmed) => {
        if (confirmed) {
          const beforeEvent = { rows: [...selectedRows], cancelled: false };
          grid.emit('beforeRowDelete', beforeEvent);
          if (beforeEvent.cancelled) return;

          const idsToDelete = selectedRows.map((row) => row[grid.idField]);

          if (!grid.options.deleteUrl) {
            grid.showToast('ì‚­ì œë¥¼ ì²˜ë¦¬í•  ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.', 'error');
            return;
          }

          grid.showLoading();
          try {
            const response = await fetch(grid.options.deleteUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ ids: idsToDelete }),
            });

            if (!response.ok) {
              throw new Error(`ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜: ${response.status}`);
            }

            const result = await response.json();

            if (result.success) {
              grid.showToast(`${result.deleted}ê°œì˜ í–‰ì´ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
              grid.emit('afterRowDelete', { rows: selectedRows, result });
              await this.load();
            } else {
              throw new Error(result.error || 'ì„œë²„ì—ì„œ ì‚­ì œ ì²˜ë¦¬ë¥¼ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
          } catch (error) {
            grid.handleError(error, 'immediateDelete');
            grid.showToast('ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
          } finally {
            grid.hideLoading();
          }
        }
      });
    }

    getSortedData() {
      return [...this.grid.currentPageData];
    }

    updateTotalRowsInfo() {
      const { grid } = this;
      if (!grid.options.enableTotalRows || !grid.totalRowsElement) return;
      grid.totalRowsElement.textContent = `ì „ì²´ ë°ì´í„°: ${grid.totalRows}ê°œ`;
    }
  }

  /**
   * InputFactory Class (Factory Pattern)
   * @version 1.0.0
   * @description ë‹¤ì–‘í•œ íƒ€ì…ì˜ ì…ë ¥ ìš”ì†Œë¥¼ ìƒì„±í•˜ëŠ” íŒ©í† ë¦¬ í´ë˜ìŠ¤
   */

  class InputFactory {
    constructor(grid) {
      this.grid = grid;
      this.selectOptionCache = new Map();
      this.inputConfigs = {
        textbox: { type: 'text', class: 'smartgrid-input smartgrid-input-text' },
        email: { type: 'email', class: 'smartgrid-input smartgrid-input-email' },
        // password: { type: 'password', class: 'smartgrid-input smartgrid-input-password' },
        // tel: { type: 'tel', class: 'smartgrid-input smartgrid-input-tel' },
        // url: { type: 'url', class: 'smartgrid-input smartgrid-input-url' },
        // 'datetime-local': { type: 'datetime-local', class: 'smartgrid-input smartgrid-input-datetime' },
        // month: { type: 'month', class: 'smartgrid-input smartgrid-input-month' },
        // week: { type: 'week', class: 'smartgrid-input smartgrid-input-week' },
        // time: { type: 'time', class: 'smartgrid-input smartgrid-input-time' },
        datebox: { type: 'date', class: 'smartgrid-input smartgrid-input-date' },
        // color: { type: 'color', class: 'smartgrid-input smartgrid-input-color' },
      };
      this.creators = {
        numberbox: this.createNumberInput.bind(this),
        checkbox: this.createCheckboxInput.bind(this),
        selectbox: this.createSelectInput.bind(this),
        radiobutton: this.createRadioInput.bind(this),
        // textarea: this.createTextareaInput.bind(this),
        // range: this.createRangeInput.bind(this),
      };
      Object.keys(this.inputConfigs).forEach((type) => {
        this.creators[type] = (col, row, val) => this.createStandardInput(type, col, row, val);
      });
    }

    /**
     * ì…ë ¥ ìš”ì†Œ ìƒì„±
     * @param {Object} column - ì»¬ëŸ¼ ì •ì˜
     * @param {Object} rowData - í–‰ ë°ì´í„°
     * @param {any} value - ê°’
     * @returns {HTMLElement} ìƒì„±ëœ ì…ë ¥ ìš”ì†Œ
     */
    create(column, rowData, value) {
      const editorType = column.editor.type || 'textbox';
      const creator = this.creators[editorType];
      if (!creator) {
        console.warn(`'${editorType}' íƒ€ì…ì˜ ì—ë””í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ textboxë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.`);
        return this.createStandardInput('textbox', column, rowData, value);
      }
      return creator(column, rowData, value);
    }

    /**
     * ê³µí†µ ì†ì„± ì ìš©
     * @param {HTMLElement} input - ì…ë ¥ ìš”ì†Œ
     * @param {Object} column - ì»¬ëŸ¼ ì •ì˜
     */
    CommonAttributes(input, column) {
      const { editor } = column;
      if (editor.placeholder) input.placeholder = editor.placeholder;
      if (editor.required) input.required = editor.required;
      if (editor.multiple) input.multiple = editor.multiple;
      if (editor.disabled) input.disabled = editor.disabled;
      if (editor.readonly) input.readOnly = editor.readonly;
    }

    // ... (InputFactory í´ë˜ìŠ¤ ë‚´ë¶€)

    getDefault(column, rowData, value) {
      const ed = column.editor;

      let def = '';
      if (typeof ed.defaultVal === 'function') {
        def = ed.defaultVal(column, this.grid) ?? '';
      } else if (ed.defaultVal !== undefined && ed.defaultVal !== null) {
        def = ed.defaultVal;
      }

      let finalValue = value !== null && value !== undefined && value !== '' ? value : def;

      // â˜… [ì¶”ê°€ëœ ë¡œì§] ìˆ˜ì‹ì´ ìˆëŠ” ì»¬ëŸ¼ì— ëŒ€í•´ ì´ˆê¸°ê°’ì„ ê°•ì œí•©ë‹ˆë‹¤.
      if (column.formula && (finalValue === null || finalValue === undefined || finalValue === isNaN)) {
        // numberbox ë˜ëŠ” ìˆ«ìê°€ í•„ìš”í•œ ìˆ˜ì‹ ì»¬ëŸ¼ì˜ ê²½ìš° 0ìœ¼ë¡œ ê°•ì œ
        if (ed.type === 'numberbox' || typeof column.formula === 'function') {
          finalValue = 0;
        } else {
          finalValue = '';
        }
      }
      // â˜… [ë] ì¶”ê°€ëœ ë¡œì§

      return finalValue;
    }

    // ... (ì´í•˜ ë™ì¼)
    /**
     * í‘œì¤€ ì…ë ¥ ìš”ì†Œ ìƒì„±
     * @param {string} editorType - ì—ë””í„° íƒ€ì…
     * @param {Object} column - ì»¬ëŸ¼ ì •ì˜
     * @param {Object} rowData - í–‰ ë°ì´í„°
     * @param {any} value - ê°’
     * @returns {HTMLElement} ìƒì„±ëœ ì…ë ¥ ìš”ì†Œ
     */
    createStandardInput(editorType, column, rowData, value) {
      const config = this.inputConfigs[editorType];
      const input = document.createElement('input');
      input.type = config.type;
      input.value = value ?? '';
      input.className = config.class;
      input.setAttribute('data-editor-type', editorType);
      this.CommonAttributes(input, column);
      // â˜… defaultVal ì ìš©
      const v = this.getDefault(column, rowData, value);
      input.value = v;

      // â˜… rowData ì¦‰ì‹œ ë°˜ì˜ (ì €ì¥ ì‹œ í•„ìˆ˜ ì˜¤ë¥˜ ë°©ì§€)
      rowData[column.field] = v;

      // // UI ì…ë ¥ â†’ rowData ë°˜ì˜
      // input.addEventListener('input', () => {
      //   rowData[column.field] = input.value;
      // });

      return input;
    }

    /**
     * ìˆ«ì ì…ë ¥ ìš”ì†Œ ìƒì„±
     */

    createNumberInput(column, rowData, value) {
      const input = document.createElement('input');
      input.type = 'number';
      input.step = 'any'; // í•­ìƒ anyë¡œ ì„¤ì •

      const decimalPlaces = column.editor.decimalPlaces ?? 0;
      const formattedValue = value !== null && value !== undefined && value !== '' ? Number(value).toFixed(decimalPlaces) : 0;

      input.value = formattedValue;
      input.className = 'smartgrid-input smartgrid-input-number';

      if (column.editor.min !== void 0) input.min = column.editor.min;
      if (column.editor.max !== void 0) input.max = column.editor.max;
      if (column.editor.step !== void 0) input.step = column.editor.step;

      input.setAttribute('data-editor-type', 'numberbox');
      this.CommonAttributes(input, column);
      // â˜… defaultVal + ìˆ«ì formatting ìœ ì§€
      const v = this.getDefault(column, rowData, value);
      input.value = v !== '' ? Number(v) : '';

      rowData[column.field] = input.value;

      // input.addEventListener('input', () => {
      //   rowData[column.field] = input.value;
      // });
      return input;
    }

    /**
     * ì²´í¬ë°•ìŠ¤ ì…ë ¥ ìš”ì†Œ ìƒì„±
     */
    createCheckboxInput(column, rowData, value) {
      const container = document.createElement('div');
      container.className = 'smartgrid-d-flex smartgrid-justify-content-center smartgrid-align-items-center';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'smartgrid-input-checkbox';
      checkbox.setAttribute('data-editor-type', 'checkbox');
      this.CommonAttributes(checkbox, column);

      const v = this.getDefault(column, rowData, value);
      checkbox.checked = !!v;
      rowData[column.field] = checkbox.checked ? 1 : 0;

      // checkbox.addEventListener('change', () => {
      //   rowData[column.field] = checkbox.checked ? 1 : 0;
      // });

      container.appendChild(checkbox);
      return container;
    }

    /**
     * ì…€ë ‰íŠ¸ ë°•ìŠ¤ ìƒì„±
     * [ë³€ê²½] editor.valueField, editor.textFieldë¥¼ ì§€ì›í•˜ë„ë¡ ìˆ˜ì •
     */
    createSelectInput(column, rowData, value) {
      const select = document.createElement('select');
      select.className = 'smartgrid-input-select';
      select.setAttribute('data-editor-type', 'selectbox');
      this.CommonAttributes(select, column);

      const editorConfig = column.editor;
      const valueField = editorConfig.valueField || 'value';
      const textField = editorConfig.textField || 'text';
      const url = editorConfig.url; // âœ… url ë³€ìˆ˜ëª… ê°„ê²°í•˜ê²Œ ì •ì˜

      // defaultVal ê³„ì‚°
      let def = '';
      if (typeof editorConfig.defaultVal === 'function') {
        def = editorConfig.defaultVal(column, this.grid) ?? '';
      } else if (editorConfig.defaultVal !== undefined && editorConfig.defaultVal !== null) {
        def = editorConfig.defaultVal;
      }

      // ê³µí†µ ì ìš© í•¨ìˆ˜ (ê¸°ë³¸ê°’ / ì²« ì˜µì…˜ ì„ íƒ)
      const applyFinalValue = (optList) => {
        const firstVal = optList.length > 0 ? optList[0][valueField] : '';
        const final = value !== null && value !== undefined && value !== '' ? value : def !== '' ? def : firstVal;

        select.value = final;

        // â˜… rowDataì—ë„ ì¦‰ì‹œ ë°˜ì˜ (í•„ìˆ˜ í•­ëª© ì˜¤ë¥˜ í•´ê²° í•µì‹¬ë¼ì¸)
        rowData[column.field] = select.value;
      };

      // ì˜µì…˜ ìƒì„± í•¨ìˆ˜
      const createOptions = (data) => {
        select.innerHTML = '';
        if (!Array.isArray(data)) throw new Error(`URL(${url})ì€ ë°°ì—´ì„ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.`);

        data.forEach((item) => {
          const opt = document.createElement('option');
          opt.value = item[valueField];
          opt.textContent = item[textField];
          select.appendChild(opt);
        });
        return data; // ì ìš© í›„ ë°ì´í„° ë°˜í™˜
      };

      // 1) AJAX ë¡œë”©
      if (url && typeof url === 'string') {
        select.disabled = true;
        select.innerHTML = '<option>ë¡œë”© ì¤‘...</option>';

        // âœ… ìºì‹œ í™•ì¸
        let fetchPromise = this.selectOptionCache.get(url);

        if (!fetchPromise) {
          // ìºì‹œ ë¯¸ìŠ¤: ìƒˆ ìš”ì²­ ìƒì„± ë° Promise ìºì‹œì— ì €ì¥
          fetchPromise = fetch(url)
            .then((res) => {
              if (!res.ok) throw new Error(`Selectbox ì˜µì…˜ ë¡œë“œ ì‹¤íŒ¨: ${res.status}`);
              return res.json();
            })
            // âœ… ìºì‹œ ì €ì¥
            .catch((err) => {
              // ì—ëŸ¬ ë°œìƒ ì‹œ ìºì‹œì—ì„œ Promise ì œê±° (ë‹¤ìŒ ì‹œë„ ê°€ëŠ¥í•˜ë„ë¡)
              this.selectOptionCache.delete(url);
              throw err; // ì—ëŸ¬ ì¬ì „íŒŒ
            });

          // âœ… ì„±ê³µ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ Promiseë¥¼ ìºì‹œì— ì €ì¥ (ì¤‘ë³µ ìš”ì²­ ë°©ì§€)
          this.selectOptionCache.set(url, fetchPromise);
        }

        fetchPromise
          .then(createOptions) // ì˜µì…˜ ìƒì„±
          .then((data) => {
            // ìµœì¢… ê°’ ì„¤ì •
            applyFinalValue(data);
            select.disabled = false;
          })
          .catch((err) => {
            this.grid?.handleError?.(err, `createSelectInput.fetch(${url})`);
            select.innerHTML = '<option>ë¡œë“œ ì‹¤íŒ¨</option>';
          });

        return select;
      }
      // 2) ì •ì  ì˜µì…˜
      if (Array.isArray(editorConfig.options)) {
        const opts = editorConfig.options;

        opts.forEach((option) => {
          const opt = document.createElement('option');
          opt.value = option[valueField];
          opt.textContent = option[textField];
          select.appendChild(opt);
        });

        applyFinalValue(opts);
        return select;
      }

      // 3) ì˜µì…˜ ì—†ìŒ
      select.innerHTML = '<option>ì˜µì…˜ ì—†ìŒ</option>';
      return select;

      // URLì´ ì—†ëŠ” ê²½ìš° ê¸°ì¡´ ë¡œì§ (options ë°°ì—´ ì‚¬ìš© ë“±) ì²˜ë¦¬...
      // (ì´ ë¶€ë¶„ì€ ì œì‹œëœ ì½”ë“œì— ì—†ìœ¼ë¯€ë¡œ ìƒëµ)
    }

    /* ... InputFactory í´ë˜ìŠ¤ì˜ ë‹¤ë¥¸ ë©”ì„œë“œë“¤ ... */
    /**
     * ë¼ë””ì˜¤ ë²„íŠ¼ ìƒì„±
     */
    createRadioInput(column, rowData, value) {
      const container = document.createElement('div');
      container.className = 'smartgrid-d-flex smartgrid-align-items-center';
      container.style.cssText = 'height: 100%; justify-content: flex-start; padding: 0 8px; flex-wrap: wrap;';
      const name = `radio_${column.field}_${rowData[this.grid.idField]}`;
      (column.editor.options || []).forEach((option) => {
        const radioId = `${name}_${option.val}`;
        const radioDiv = document.createElement('div');
        radioDiv.style.cssText = 'display: inline-flex; align-items: center; margin-right: 12px; margin: 0;';
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.id = radioId;
        radio.name = name;
        radio.value = option.val;
        radio.className = 'smartgrid-input-radio';
        radio.checked = String(option.val) === String(value);
        radio.setAttribute('data-editor-type', 'radiobutton');
        this.CommonAttributes(radio, column);
        const label = document.createElement('label');
        label.className = 'smartgrid-input-radio-label';
        label.setAttribute('for', radioId);
        label.textContent = option.text;
        radioDiv.appendChild(radio);
        radioDiv.appendChild(label);
        container.appendChild(radioDiv);
      });
      return container;
    }

    /**
     * í…ìŠ¤íŠ¸ ì˜ì—­ ìƒì„±
     */
    createTextareaInput(column, rowData, value) {
      const textarea = document.createElement('textarea');
      textarea.value = value ?? '';
      textarea.className = 'smartgrid-input-textarea';
      textarea.style.cssText = 'width: 100%; box-sizing: border-box; resize: none;';
      textarea.style.height = `calc(var(--row-height, 30px) - 8px)`;
      textarea.setAttribute('data-editor-type', 'textarea');
      this.CommonAttributes(textarea, column);
      const v = this.getDefault(column, rowData, value);
      textarea.value = v;
      rowData[column.field] = v;

      textarea.addEventListener('input', () => {
        rowData[column.field] = textarea.value;
      });
      return textarea;
    }

    /**
     * ë²”ìœ„ ì…ë ¥ ìš”ì†Œ ìƒì„±
     */
    createRangeInput(column, rowData, value) {
      const input = document.createElement('input');
      input.type = 'range';
      input.value = value ?? '0';
      input.className = 'smartgrid-input-range';
      input.style.width = '100%';
      if (column.editor.min !== undefined) input.min = column.editor.min;
      if (column.editor.max !== undefined) input.max = column.editor.max;
      if (column.editor.step !== undefined) input.step = column.editor.step;
      input.setAttribute('data-editor-type', 'range');
      this.CommonAttributes(input, column);
      return input;
    }
  }

  /**
   * UIComponents Class
   * @version 1.0.0
   * @description SmartGrid UI ì»´í¬ë„ŒíŠ¸ í†µí•© í´ë˜ìŠ¤ (Toast, Modal, ContextMenu, ColumnPanel, Loader, Pagination)
   */

  class UIComponents {
    constructor(grid) {
      this.grid = grid;
      this.toastElement = null;
      this.modalElement = null;
      this.contextMenuElement = null;
      this.columnPanelElement = null;
      this.loaderElement = null;
      this.paginationElement = null;
    }

    /**
     * ëª¨ë“  UI ì»´í¬ë„ŒíŠ¸ ìƒì„±
     */
    createAll() {
      this.createToast();
      this.createModal();
      this.createContextMenu();
      this.createLoader();
      this.createColumnPanel();
      if (this.grid.options.enablePagination) {
        this.createPagination();
      }
    }

    // ========== Toast ==========
    createToast() {
      const toast = document.createElement('div');
      toast.id = `${this.grid.instanceId}_toast`;
      toast.className = 'smartgrid-toast';
      toast.setAttribute('data-instance', this.grid.instanceId);
      toast.innerHTML = `
      <div class="smartgrid-toast-header" data-instance="${this.grid.instanceId}">
        <div class="smartgrid-toast-icon" id="${this.grid.instanceId}_toastIcon"></div>
        <div class="smartgrid-toast-title" id="${this.grid.instanceId}_toastTitle">ì•Œë¦¼</div>
        <button class="smartgrid-toast-close" data-instance="${this.grid.instanceId}">&times;</button>
      </div>
      <div class="smartgrid-toast-body" id="${this.grid.instanceId}_toastBody"></div>
    `;
      document.body.appendChild(toast);
      this.toastElement = toast;
      this.toastTimer = null;
    }

    showToast(message, type = 'info') {
      const toastElement = this.toastElement;
      if (!toastElement) return;
      const icon = toastElement.querySelector(`#${this.grid.instanceId}_toastIcon`);
      const title = toastElement.querySelector(`#${this.grid.instanceId}_toastTitle`);
      const body = toastElement.querySelector(`#${this.grid.instanceId}_toastBody`);
      const closeBtn = toastElement.querySelector(`.smartgrid-toast-close[data-instance="${this.grid.instanceId}"]`);

      // [ë³€ê²½ 1] ê¸°ì¡´ íƒ€ì… í´ë˜ìŠ¤ ì œê±° (DataHandlerì—ì„œ 'warning'ë„ ì‚¬ìš©í•˜ë¯€ë¡œ í¬í•¨)
      const allTypes = ['info', 'success', 'error', 'warning'];
      toastElement.classList.remove(...allTypes);

      // [ë³€ê²½ 2] toastElementì— ìƒˆ íƒ€ì… í´ë˜ìŠ¤ ì¶”ê°€
      toastElement.classList.add(type);

      // [ìœ ì§€] ì•„ì´ì½˜ì—ë„ í´ë˜ìŠ¤ ì„¤ì • (ê¸°ì¡´ ë¡œì§)
      icon.className = `smartgrid-toast-icon ${type}`;

      title.textContent = type.charAt(0).toUpperCase() + type.slice(1);
      body.textContent = message;

      // [ë³€ê²½ 3] ê¸°ì¡´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ì·¨ì†Œ (ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€)
      if (this.toastTimer) {
        clearTimeout(this.toastTimer);
      }

      toastElement.classList.add('show');

      const handleClose = () => {
        toastElement.classList.remove('show');
        closeBtn.removeEventListener('click', handleClose);
        this.toastTimer = null;
        // [ë³€ê²½ 4] ë‹«í ë•Œ íƒ€ì… í´ë˜ìŠ¤ë„ ì œê±° (ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ 300ms ê³ ë ¤)
        setTimeout(() => toastElement.classList.remove(type), 300);
      };

      closeBtn.addEventListener('click', handleClose);

      this.toastTimer = setTimeout(handleClose, 3e3);
    }

    // ========== Modal ==========
    createModal() {
      const modal = document.createElement('div');
      modal.id = `${this.grid.instanceId}_modal`;
      modal.className = 'smartgrid-modal';
      modal.setAttribute('data-instance', this.grid.instanceId);
      modal.innerHTML = `
      <div class="smartgrid-modal-backdrop" data-instance="${this.grid.instanceId}"></div>
      <div class="smartgrid-modal-content" data-instance="${this.grid.instanceId}">
        <div class="smartgrid-modal-header">
          <h5 class="smartgrid-modal-title">í™•ì¸</h5>
          <button class="smartgrid-modal-close" data-instance="${this.grid.instanceId}">&times;</button>
        </div>
        <div class="smartgrid-modal-body">
          <p id="${this.grid.instanceId}_modalText"></p>
        </div>
        <div class="smartgrid-modal-footer">
          <button class="smartgrid-btn smartgrid-btn-secondary" data-dismiss="modal" data-instance="${this.grid.instanceId}">ì·¨ì†Œ</button>
          <button class="smartgrid-btn smartgrid-btn-primary" id="${this.grid.instanceId}_modalConfirm" data-instance="${this.grid.instanceId}">í™•ì¸</button>
        </div>
      </div>
    `;
      document.body.appendChild(modal);
      this.modalElement = modal;
    }

    showConfirmModal(message, callback) {
      const modalElement = this.modalElement;
      if (!modalElement) return;
      const modalText = modalElement.querySelector(`#${this.grid.instanceId}_modalText`);
      const confirmBtn = modalElement.querySelector(`#${this.grid.instanceId}_modalConfirm`);
      const cancelBtns = modalElement.querySelectorAll(`[data-dismiss="modal"][data-instance="${this.grid.instanceId}"]`);
      const closeBtn = modalElement.querySelector(`.smartgrid-modal-close[data-instance="${this.grid.instanceId}"]`);
      const backdrop = modalElement.querySelector(`.smartgrid-modal-backdrop[data-instance="${this.grid.instanceId}"]`);
      modalText.textContent = message;
      modalElement.classList.add('show');
      const handleConfirm = () => {
        callback(true);
        modalElement.classList.remove('show');
        cleanup();
      };
      const handleCancel = () => {
        callback(false);
        modalElement.classList.remove('show');
        cleanup();
      };
      const cleanup = () => {
        confirmBtn.removeEventListener('click', handleConfirm);
        cancelBtns.forEach((btn) => btn.removeEventListener('click', handleCancel));
        closeBtn?.removeEventListener('click', handleCancel);
        backdrop?.removeEventListener('click', handleCancel);
      };
      confirmBtn.addEventListener('click', handleConfirm);
      cancelBtns.forEach((btn) => btn.addEventListener('click', handleCancel));
      closeBtn?.addEventListener('click', handleCancel);
      backdrop?.addEventListener('click', handleCancel);
    }

    // ========== ContextMenu ==========
    createContextMenu() {
      const menu = document.createElement('div');
      menu.id = `${this.grid.instanceId}_contextMenu`;
      menu.className = 'smartgrid-context-menu';
      menu.setAttribute('data-instance', this.grid.instanceId);
      menu.innerHTML = `
      <div class="smartgrid-context-menu-item" data-action="copyCell" data-instance="${this.grid.instanceId}">ì…€ ë³µì‚¬</div>
      <div class="smartgrid-context-menu-item" data-action="copyRow" data-instance="${this.grid.instanceId}">í–‰ ë³µì‚¬</div>
      <div class="smartgrid-context-menu-divider"></div>
      <div class="smartgrid-context-menu-item" data-action="addRow" data-instance="${this.grid.instanceId}">í–‰ ì¶”ê°€</div>
      <div class="smartgrid-context-menu-item" data-action="deleteRow" data-instance="${this.grid.instanceId}">í–‰ ì‚­ì œ</div>
      <div class="smartgrid-context-menu-divider"></div>
      <div class="smartgrid-context-menu-item" data-action="toggleColumns" data-instance="${this.grid.instanceId}">ì—´ í‘œì‹œ/ìˆ¨ê¹€</div>
    `;
      document.body.appendChild(menu);
      this.contextMenuElement = menu;
    }

    showContextMenu(x, y, rowId, cellField) {
      const contextMenu = this.contextMenuElement;
      if (!contextMenu) return;
      contextMenu.style.display = 'none';
      setTimeout(() => {
        contextMenu.style.display = 'block';
        const isMobile = window.innerWidth < 768;
        if (isMobile) {
          contextMenu.classList.add('smartgrid-context-menu-mobile');
          contextMenu.style.left = '';
          contextMenu.style.top = '';
        } else {
          contextMenu.classList.remove('smartgrid-context-menu-mobile');
          const menuRect = contextMenu.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          let adjustedX = x;
          let adjustedY = y;
          if (x + menuRect.width > viewportWidth - 10) adjustedX = viewportWidth - menuRect.width - 10;
          if (y + menuRect.height > viewportHeight - 10) adjustedY = viewportHeight - menuRect.height - 10;
          if (adjustedX < 10) adjustedX = 10;
          if (adjustedY < 10) adjustedY = 10;
          contextMenu.style.left = `${adjustedX}px`;
          contextMenu.style.top = `${adjustedY}px`;
        }
        contextMenu.setAttribute('data-context-row-id', rowId);
        if (cellField) contextMenu.setAttribute('data-context-cell-field', cellField);
      }, 10);
    }

    hideContextMenu() {
      if (this.contextMenuElement) {
        this.contextMenuElement.style.display = 'none';
      }
    }

    // ========== ColumnPanel ==========
    createColumnPanel() {
      const panel = document.createElement('div');
      panel.id = `${this.grid.instanceId}_columnPanel`;
      panel.className = 'smartgrid-column-panel';
      panel.setAttribute('data-instance', this.grid.instanceId);
      panel.innerHTML = `
      <div class="smartgrid-column-panel-header">ì—´ í‘œì‹œ ì„¤ì •</div>
      <div class="smartgrid-column-panel-body" id="${this.grid.instanceId}_columnList"></div>
    `;
      document.body.appendChild(panel);
      this.columnPanelElement = panel;
    }

    toggleColumnVisibilityPanel() {
      const panel = this.columnPanelElement;
      if (!panel) return;
      const isActive = panel.classList.toggle('active');
      if (isActive) {
        const toggleButton = this.grid.wrapper.querySelector(`[data-action="toggleColumns"]`);
        if (toggleButton) {
          const rect = toggleButton.getBoundingClientRect();
          panel.style.left = `${rect.left}px`;
          panel.style.top = `${rect.bottom + 5}px`;
        }
        this.renderColumnVisibilityPanel();
      }
    }

    renderColumnVisibilityPanel() {
      const listContainer = this.columnPanelElement.querySelector(`#${this.grid.instanceId}_columnList`);
      if (!listContainer) return;
      listContainer.innerHTML = '';
      this.grid.columns.forEach((column) => {
        if (column.hideColumn) return;
        const item = document.createElement('div');
        item.className = 'column-visibility-item';
        const checkboxId = `${this.grid.instanceId}_col_vis_${column.field}`;
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.className = 'smartgrid-input-checkbox';
        checkbox.checked = !this.grid.hiddenColumns.has(column.field);
        checkbox.addEventListener('change', (e) => {
          this.grid[e.target.checked ? 'showColumn' : 'hideColumn'](column.field);
        });
        const label = document.createElement('label');
        label.setAttribute('for', checkboxId);
        label.textContent = column.title;
        item.appendChild(checkbox);
        item.appendChild(label);
        listContainer.appendChild(item);
      });
    }

    // ========== Loader ==========
    createLoader() {
      const loader = document.createElement('div');
      loader.id = `${this.grid.instanceId}_loader`;
      loader.className = 'smartgrid-skeleton-loader';
      loader.setAttribute('data-instance', this.grid.instanceId);
      loader.innerHTML = `
      <div class="smartgrid-skeleton-spinner"></div>
      <div class="smartgrid-skeleton-text">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
    `;
      document.body.appendChild(loader);
      this.loaderElement = loader;
    }

    showLoading() {
      this.loaderElement?.classList.add('active');
    }

    hideLoading() {
      this.loaderElement?.classList.remove('active');
    }

    // ========== Pagination ==========
    createPagination() {
      const pagination = document.createElement('div');
      pagination.id = `${this.grid.instanceId}_pagination`;
      pagination.className = 'smartgrid-pagination';
      pagination.setAttribute('data-instance', this.grid.instanceId);
      this.grid.wrapper.appendChild(pagination);
      this.paginationElement = pagination;
    }

    renderPagination() {
      if (!this.grid.options.enablePagination || !this.paginationElement) return;
      this.paginationElement.innerHTML = '';
      if (this.grid.totalRows === 0) return;
      const totalPages = Math.ceil(this.grid.totalRows / this.grid.pageSize);
      const PAGINATION_GROUP_SIZE = 5;
      const currentGroup = Math.ceil(this.grid.currentPage / PAGINATION_GROUP_SIZE);
      const startPage = (currentGroup - 1) * PAGINATION_GROUP_SIZE + 1;
      const endPage = Math.min(totalPages, currentGroup * PAGINATION_GROUP_SIZE);
      const ul = document.createElement('ul');
      const fragment = document.createDocumentFragment();
      const prevPage = startPage - 1;
      fragment.appendChild(this.createPaginationButton('<i class="bi bi-chevron-double-left"></i>', prevPage, false, prevPage < 1));
      for (let page = startPage; page <= endPage; page++) {
        fragment.appendChild(this.createPaginationButton(page, page, page === this.grid.currentPage));
      }
      const nextPage = endPage + 1;
      fragment.appendChild(this.createPaginationButton('<i class="bi bi-chevron-double-right"></i>', nextPage, false, nextPage > totalPages));
      ul.appendChild(fragment);
      this.paginationElement.appendChild(ul);
    }

    createPaginationButton(content, page, isActive = false, isDisabled = false) {
      const li = document.createElement('li');
      li.className = 'page-item';
      if (isActive) li.classList.add('active');
      if (isDisabled) li.classList.add('disabled');
      const button = document.createElement('button');
      button.classList.add('page-link');
      button.innerHTML = content;
      if (!isDisabled) {
        button.addEventListener('click', () => {
          this.grid.currentPage = page;
          this.grid.changePage();
        });
      }
      li.appendChild(button);
      return li;
    }

    /**
     * ëª¨ë“  UI ì»´í¬ë„ŒíŠ¸ ì œê±°
     */
    destroyAll() {
      this.toastElement?.remove();
      this.modalElement?.remove();
      this.contextMenuElement?.remove();
      this.loaderElement?.remove();
      this.columnPanelElement?.remove();
      this.paginationElement?.remove();

      this.toastElement = null;
      this.modalElement = null;
      this.contextMenuElement = null;
      this.loaderElement = null;
      this.columnPanelElement = null;
      this.paginationElement = null;
    }
  }

  /**
   * GridRenderer Class
   * @version 1.0.0
   * @description ê·¸ë¦¬ë“œ ë Œë”ë§ ë¡œì§ (í…Œì´ë¸” ìƒì„±, í—¤ë”, ë°”ë””, í‘¸í„°)
   */

  class GridRenderer {
    constructor(grid) {
      this.grid = grid;
    }

    /**
     * ê·¸ë¦¬ë“œ ì „ì²´ ë Œë”ë§
     */
    // GridRenderer.jsì˜ renderGrid ë©”ì„œë“œ ìˆ˜ì •
    renderGrid() {
      try {
        this.clearTable();
        this.grid.table.className = 'smartgrid-table';
        this.grid.table.setAttribute('data-instance', this.grid.instanceId);
        this.createColGroup(this.grid.table); // ğŸ†• ì¶”ê°€
        this.createTableHead(this.grid.table);
        this.createTableBody(this.grid.table);
        this.createTableFooter(this.grid.table);

        // ğŸŒŸ ì¶”ê°€: ë Œë”ë§ í›„ ì •ë ¬ í‘œì‹œ ë³µì›
        this.grid.columns.forEach((col) => {
          if (col.sortable) {
            this.grid.updateSortIndicator(col.field);
          }
        });
      } catch (error) {
        this.grid.handleError(error, 'renderGrid');
      }
    }
    // ========== í…Œì´ë¸” ì»¬ëŸ¼ ê·¸ë£¹ ==========
    createColGroup(tableElement) {
      const colgroup = document.createElement('colgroup'); // ì²´í¬ë°•ìŠ¤ ì—´

      if (this.grid.enableCheckboxColumn) {
        const colCheckbox = document.createElement('col');
        colCheckbox.className = 'sg-col-checkbox';
        colCheckbox.style.width = 'var(--sg-col-checkbox-width)';
        colgroup.appendChild(colCheckbox);
      } // ì¸ë±ìŠ¤ ì—´

      if (this.grid.enableIndexColumn) {
        const colIndex = document.createElement('col');
        colIndex.className = 'sg-col-index';
        colIndex.style.width = 'var(--sg-col-index-width)';
        colgroup.appendChild(colIndex);
      } // ë°ì´í„° ì—´ë“¤ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)

      this.grid.columns.forEach((column) => {
        if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;

        const col = document.createElement('col');
        col.className = 'sg-col-data';
        col.setAttribute('data-field', column.field);

        if (column.width) {
          col.style.width = column.width;
        }

        colgroup.appendChild(col);
      });

      tableElement.appendChild(colgroup);
    }
    /**
     * í…Œì´ë¸” ì´ˆê¸°í™”
     */
    clearTable() {
      this.grid.table.replaceChildren();
    }

    // ========== í…Œì´ë¸” í—¤ë” ==========
    createTableHead(tableElement) {
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      this.addCheckboxHeader(headerRow);
      this.addIndexHeader(headerRow);
      this.addDataHeaders(headerRow);
      thead.appendChild(headerRow);
      tableElement.appendChild(thead);
    }

    addCheckboxHeader(headerRow) {
      if (!this.grid.enableCheckboxColumn) return;
      const th = document.createElement('th');
      th.classList.add('sg-col-checkbox');

      const masterCheckbox = document.createElement('input');
      masterCheckbox.type = 'checkbox';
      masterCheckbox.classList.add('smartgrid-input-checkbox');
      const allRowsChecked = this.grid.currentPageData.length > 0 && this.grid.currentPageData.every((row) => row.checked);
      masterCheckbox.checked = allRowsChecked;
      th.appendChild(masterCheckbox);
      headerRow.appendChild(th);
    }

    addIndexHeader(headerRow) {
      if (!this.grid.enableIndexColumn) return;
      const th = document.createElement('th');
      th.classList.add('sg-col-index');

      const wrapperSpan = document.createElement('span');
      wrapperSpan.textContent = 'ë²ˆí˜¸';

      th.appendChild(wrapperSpan);
      headerRow.appendChild(th);
    }

    addDataHeaders(headerRow) {
      this.grid.columns.forEach((column) => {
        if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;

        const th = document.createElement('th');
        th.style.width = column.width;

        const alignClass = `sg-align-${column.headAlign || 'center'}`;
        th.classList.add(alignClass);

        const wrapperSpan = document.createElement('span');

        if (column.sortable) {
          th.setAttribute('data-sortable', 'true');
          th.setAttribute('data-field', column.field);
          th.style.cursor = 'pointer';

          const titleSpan = document.createElement('span');
          titleSpan.classList.add('col-title');
          titleSpan.textContent = column.title;
          wrapperSpan.appendChild(titleSpan);

          const sortSpan = document.createElement('span');
          sortSpan.classList.add('sort-indicator');
          sortSpan.innerHTML = `<svg width="16" height="16" style="color: var(--sg-gray-400);"><use href="#icon-sort"></use></svg>`;
          wrapperSpan.appendChild(sortSpan);

          this.grid.updateSortIndicator(column.field);
        } else {
          wrapperSpan.textContent = column.title;
        }

        th.appendChild(wrapperSpan);

        if (column.field) {
          const resizer = document.createElement('div');
          resizer.classList.add('column-resizer');
          resizer.setAttribute('data-field', column.field);
          resizer.addEventListener('mousedown', (e) => this.grid.startColumnResize(e, column));
          th.appendChild(resizer);
        }

        headerRow.appendChild(th);
      });
    }

    // ========== í…Œì´ë¸” ë°”ë”” ==========
    createTableBody(tableElement) {
      const tbody = document.createElement('tbody');
      tbody.setAttribute('data-grid-body', 'true');
      if (this.grid.currentPageData.length === 0) {
        this.addNoDataRow(tbody);
      } else {
        this.addDataRows(tbody);
      }
      tableElement.appendChild(tbody);
    }

    addNoDataRow(tbody) {
      const row = document.createElement('tr');
      const cell = document.createElement('td');
      const visibleColumns = this.grid.columns.filter((col) => !col.hideColumn && !this.grid.hiddenColumns.has(col.field)).length;
      cell.colSpan = visibleColumns + (this.grid.enableCheckboxColumn ? 1 : 0) + (this.grid.enableIndexColumn ? 1 : 0);
      cell.textContent = 'ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.';
      cell.classList.add('smartgrid-text-center');
      cell.style.padding = '2rem';
      cell.style.color = 'var(--sg-gray-400)';
      row.appendChild(cell);
      tbody.appendChild(row);
    }

    addDataRows(tbody) {
      const fragment = document.createDocumentFragment();
      this.grid.currentPageData.forEach((rowData, index) => {
        fragment.appendChild(this.createDataRow(rowData, index));
      });
      tbody.appendChild(fragment);
    }

    createDataRow(rowData, pageIndex) {
      const row = document.createElement('tr');
      row.setAttribute('data-row-id', rowData[this.grid.idField]);
      const isNewRow = this.grid.changedRows.newRows.includes(rowData);
      const isUpdatedRow = this.grid.changedRows.updatedRows.includes(rowData);
      if (isNewRow) row.classList.add('row-new');
      else if (isUpdatedRow) row.classList.add('row-updated');
      if (rowData.checked) {
        row.classList.add('row-checked');
      }
      if (this.grid.isEditMode) row.classList.add('edit-mode');
      if (this.grid.enableCheckboxColumn) row.appendChild(this.createCheckboxCell(rowData));
      if (this.grid.enableIndexColumn) row.appendChild(this.createIndexCell(rowData, pageIndex));
      this.grid.columns.forEach((column) => {
        if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;
        row.appendChild(this.createDataCell(column, rowData, isNewRow));
      });
      return row;
    }

    createCheckboxCell(rowData) {
      const td = document.createElement('td');
      td.classList.add('sg-col-checkbox');

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = !!rowData.checked;
      checkbox.classList.add('smartgrid-input-checkbox');
      checkbox.setAttribute('data-row-checkbox', 'true');
      checkbox.setAttribute('data-row-id', rowData[this.grid.idField]);
      td.appendChild(checkbox);
      return td;
    }

    createIndexCell(rowData, pageIndex) {
      const td = document.createElement('td');
      td.classList.add('sg-col-index');

      td.textContent = (this.grid.currentPage - 1) * this.grid.pageSize + pageIndex + 1;
      return td;
    }

    createDataCell(column, rowData, isNewRow) {
      const td = document.createElement('td');
      td.setAttribute('data-field', column.field);
      td.setAttribute('data-row-id', rowData[this.grid.idField]);

      if (column.width) {
        td.style.width = column.width;
        td.style.minWidth = column.width;
      }

      const isReadonly = column.editor.readonly === true || column.editor.editable === false;
      if (isReadonly) {
        td.classList.add('sg-cell-readonly');
      }

      const value = rowData[column.field] ?? column.editor?.defaultVal ?? '';
      const isEditable = column.editor?.editable ?? true;
      const isCellEditable = (isNewRow || this.grid.isEditMode) && isEditable;
      // if (!isCellEditable && value) {
      //   const displayValue = column.render ? stripHtml(column.render(value, rowData, column)) : this.formatValue(column, value);
      //   td.setAttribute('data-tooltip', displayValue);
      // }

      if (isCellEditable) {
        td.appendChild(this.grid.createCellInput(column, rowData, value));
        if (column.editor.type === 'checkbox' || column.editor.type === 'radiobutton') ;
      } else {
        const displayElement = document.createElement('span');
        displayElement.innerHTML = column.render ? column.render(value, rowData, column) : this.formatValue(column, value);

        td.style.textAlign = column.cellAlign;

        td.appendChild(displayElement);
      }
      return td;
    }

    formatValue(column, value) {
      if (column.editor.type === 'numberbox') {
        return formatNumber(value, column.editor.decimalPlaces || 0);
      } else if (column.editor.type === 'selectbox' || column.editor.type === 'radiobutton') {
        const options = column.editor.options || [];
        const selected = options.find((opt) => String(opt.val) === String(value));
        return selected ? selected.text : value;
      }
      return value;
    }

    // ========== í…Œì´ë¸” í‘¸í„° ==========
    createTableFooter(tableElement) {
      if (!this.grid.columns.some((col) => col.sum)) return;

      const existingFooter = tableElement?.querySelector('tfoot');
      existingFooter?.remove();

      const tfoot = document.createElement('tfoot');
      const footerRow = document.createElement('tr');

      if (this.grid.enableCheckboxColumn) {
        const checkboxCell = document.createElement('td');
        checkboxCell.classList.add('sg-col-checkbox');
        checkboxCell.appendChild(document.createElement('span'));
        footerRow.appendChild(checkboxCell);
      }

      if (this.grid.enableIndexColumn) {
        const indexCell = document.createElement('td');
        indexCell.classList.add('sg-col-index');
        const span = document.createElement('span');
        span.textContent = 'í•©ê³„';
        indexCell.appendChild(span);
        footerRow.appendChild(indexCell);
      }

      this.grid.columns.forEach((column) => {
        if (column.hideColumn || this.grid.hiddenColumns.has(column.field)) return;

        const td = document.createElement('td');
        const span = document.createElement('span');

        if (column.width) td.style.width = column.width;

        if (column.sum && column.editor.type === 'numberbox') {
          const total = this.grid.currentPageData.reduce((sum, row) => sum + (parseFloat(row[column.field]) || 0), 0);
          span.textContent = formatNumber(total, column.editor.decimalPlaces || 0);
          td.classList.add('sg-td-total');
        }

        td.appendChild(span);
        footerRow.appendChild(td);
      });

      tfoot.appendChild(footerRow);
      tableElement.appendChild(tfoot);
    }

    /**
     * ì…€ í‘œì‹œ ì—…ë°ì´íŠ¸
     */
    updateCellDisplay(cell, column, value) {
      const input = cell.querySelector('input, select, textarea');
      if (input) {
        if (input.type === 'checkbox') {
          input.checked = !!value;
        } else if (input.type === 'number') {
          let numericValue = value;

          // 1. ë¬¸ìì—´ì´ë©´ ì½¤ë§ˆ ì œê±°
          if (typeof value === 'string') {
            numericValue = value.replace(/,/g, '');
          }

          // 2. ìˆ«ìë¡œ ë³€í™˜
          numericValue = parseFloat(numericValue);

          // 3. decimalPlacesê°€ ìˆìœ¼ë©´ ë°˜ì˜¬ë¦¼ ì ìš©
          if (!isNaN(numericValue) && column?.editor?.decimalPlaces !== undefined) {
            numericValue = parseFloat(numericValue.toFixed(column.editor.decimalPlaces));
          }

          // 4. inputì— ê°’ í• ë‹¹
          input.value = !isNaN(numericValue) ? numericValue : '';
        } else {
          input.value = value != null ? value : '';
        }
      } else {
        const displayElement = cell.querySelector('span');
        if (displayElement) {
          displayElement.innerHTML = value != null ? value : '';
        }
      }
    }

    /**
     * í…Œì´ë¸” í‘¸í„°ë§Œ ì—…ë°ì´íŠ¸
     */
    updateTableFooter() {
      if (this.grid.table) {
        this.createTableFooter(this.grid.table);
      }
    }
  }

  /**
   * GridEvents Class
   * @version 1.0.0
   * @description ê·¸ë¦¬ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬ (ì´ë²¤íŠ¸ ìœ„ì„, í•¸ë“¤ëŸ¬)
   */

  class GridEvents {
    constructor(grid) {
      this.grid = grid;
      this.justResized = false; // âœ¨ [ì¶”ê°€]
    }

    /**
     * ì´ë²¤íŠ¸ ìœ„ì„ ì„¤ì •
     */
    setupEventDelegation() {
      const tbody = this.grid.table.querySelector('tbody[data-grid-body]');
      const thead = this.grid.table.querySelector('thead');
      this.removeEventListeners(tbody, thead);
      if (tbody) {
        this.delegate(tbody, 'change', this.handleBodyChange.bind(this));
        this.delegate(tbody, 'input', this.handleBodyChange.bind(this));
        this.delegate(tbody, 'contextmenu', this.handleBodyContextMenu.bind(this));
      }
      if (thead) {
        this.delegate(thead, 'click', this.handleHeadClick.bind(this));
      }
      this.setupContextMenuEvents();
    }

    /**
     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (ìœ„ì„)
     */
    delegate(element, eventType, handler) {
      element[`${eventType}Handler`] = handler;
      element.addEventListener(eventType, handler);
    }

    /**
     * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
     */
    removeEventListeners(tbody, thead) {
      if (tbody) {
        if (tbody.changeHandler) tbody.removeEventListener('change', tbody.changeHandler);
        if (tbody.inputHandler) tbody.removeEventListener('input', tbody.inputHandler);
        if (tbody.contextmenuHandler) tbody.removeEventListener('contextmenu', tbody.contextmenuHandler);
      }
      if (thead && thead.clickHandler) {
        thead.removeEventListener('click', thead.clickHandler);
      }
    }

    // ========== í—¤ë” í´ë¦­ í•¸ë“¤ëŸ¬ ==========
    handleHeadClick(event) {
      if (event.target.closest('.column-resizer')) return;
      const masterCheckbox = event.target.closest("thead th input[type='checkbox']");
      if (masterCheckbox) return this.handleMasterCheckboxClick(masterCheckbox);
      const sortableHeader = event.target.closest("th[data-sortable='true']");
      if (sortableHeader) return this.handleSortableHeaderClick(sortableHeader);
    }

    handleMasterCheckboxClick(checkbox) {
      this.grid.currentPageData.forEach((row) => (row.checked = checkbox.checked));
      this.grid.renderGrid();
    }

    handleSortableHeaderClick(header) {
      if (this.justResized) {
        return;
      }
      const field = header.getAttribute('data-field');
      if (field) this.grid.sortColumn(field);
    }

    // ========== ë°”ë”” ë³€ê²½ í•¸ë“¤ëŸ¬ ==========
    handleBodyChange(event) {
      const input = event.target.closest('input[data-editor-type], select[data-editor-type], textarea[data-editor-type]');
      if (input) return this.handleInputChange(input);
      const rowCheckbox = event.target.closest('input[type="checkbox"][data-row-checkbox="true"]');
      if (rowCheckbox) return this.handleRowCheckboxChange(rowCheckbox);
    }

    handleInputChange(target) {
      const cell = target.closest('td[data-field]');
      const row = target.closest('tr[data-row-id]');
      if (!cell || !row) return;
      const field = cell.getAttribute('data-field');
      const rowId = row.getAttribute('data-row-id');
      const rowData = this.grid.findRowData(rowId);
      if (!rowData) return;
      let value;
      if (target.type === 'checkbox') {
        value = target.checked;
      } else if (target.type === 'radio') {
        value = row.querySelector(`input[name="${target.name}"]:checked`)?.value ?? '';
      } else {
        value = target.value;
      }
      this.grid.updateRowData(rowData, field, value);
    }

    handleRowCheckboxChange(checkbox) {
      const rowId = checkbox.getAttribute('data-row-id');
      const rowData = this.grid.findRowData(rowId);
      if (rowData) {
        rowData.checked = checkbox.checked;

        // [ì¶”ê°€] <tr> ìš”ì†Œë¥¼ ì°¾ì•„ì„œ 'row-checked' í´ë˜ìŠ¤ë¥¼ í† ê¸€í•©ë‹ˆë‹¤.
        const rowElement = checkbox.closest('tr[data-row-id]');
        if (rowElement) {
          rowElement.classList.toggle('row-checked', checkbox.checked);
        }
      }
    }

    // ========== ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í•¸ë“¤ëŸ¬ ==========
    handleBodyContextMenu(event) {
      event.preventDefault();
      event.stopPropagation();
      const row = event.target.closest('tr[data-row-id]');
      if (!row) return;
      const rowId = row.getAttribute('data-row-id');
      const cell = event.target.closest('td[data-field]');
      const cellField = cell?.getAttribute('data-field');
      if (this.grid.findRowData(rowId)) {
        this.grid.uiComponents.showContextMenu(event.pageX, event.pageY, rowId, cellField);
      }
    }

    setupContextMenuEvents() {
      const contextMenu = this.grid.uiComponents.contextMenuElement;
      if (!contextMenu || contextMenu.hasClickHandler) return;
      const menuClickHandler = (event) => {
        event.stopPropagation();
        const menuItem = event.target.closest(`.smartgrid-context-menu-item[data-instance="${this.grid.instanceId}"]`);
        if (!menuItem) return;
        const action = menuItem.getAttribute('data-action');
        const rowId = contextMenu.getAttribute('data-context-row-id');
        const cellField = contextMenu.getAttribute('data-context-cell-field');
        contextMenu.style.display = 'none';
        this.handleContextMenuAction(action, rowId, cellField);
        contextMenu.removeAttribute('data-context-row-id');
        contextMenu.removeAttribute('data-context-cell-field');
      };
      contextMenu.addEventListener('click', menuClickHandler);
      contextMenu.hasClickHandler = true;
    }

    handleContextMenuAction(action, rowId, cellField) {
      switch (action) {
        case 'copyCell':
          if (rowId && cellField) this.copyCellValue(rowId, cellField);
          break;
        case 'copyRow':
          if (rowId) this.copyRowData(rowId);
          break;
        case 'addRow':
          this.grid.addRow();
          break;
        case 'deleteRow':
          if (rowId) {
            const rowData = this.grid.findRowData(rowId);
            if (rowData) {
              rowData.checked = true;
              this.grid.deleteRow();
            }
          }
          break;
        case 'toggleColumns':
          this.grid.uiComponents.toggleColumnVisibilityPanel();
          break;
      }
    }

    async copyCellValue(rowId, cellField) {
      const rowData = this.grid.findRowData(rowId);
      if (!rowData) return;
      try {
        await navigator.clipboard.writeText(String(rowData[cellField] ?? ''));
        this.grid.showToast('ì…€ ê°’ì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
      } catch (err) {
        this.grid.showToast('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
      }
    }

    async copyRowData(rowId) {
      const rowData = this.grid.findRowData(rowId);
      if (!rowData) return;
      const visibleColumns = this.grid.columns.filter((c) => !c.hideColumn && !this.grid.hiddenColumns.has(c.field));
      const rowText = visibleColumns.map((col) => rowData[col.field] ?? '').join('\t');
      try {
        await navigator.clipboard.writeText(rowText);
        this.grid.showToast('í–‰ ë°ì´í„°ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
      } catch (err) {
        this.grid.showToast('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
      }
    }

    /**
     * ì»¬ëŸ¼ ë¦¬ì‚¬ì´ì§• ì‹œì‘
     */
    startColumnResize(event, column) {
      this.grid.isResizing = true;
      this.grid.resizeStartX = event.clientX;
      this.grid.resizeField = column.field;
      const th = event.target.closest('th');
      this.grid.resizeStartWidth = th.offsetWidth;
      this.grid.table.classList.add('resizing-active');
      document.body.style.cursor = 'col-resize';
      event.preventDefault();
    }

    /**
     * ì»¬ëŸ¼ ë¦¬ì‚¬ì´ì§• ì´ë™
     */
    handleColumnResizeMove(event) {
      if (!this.grid.isResizing) return;
      const resizerElement = this.grid.table.querySelector(`.column-resizer[data-field="${this.grid.resizeField}"]`);
      if (!resizerElement) return;
      const th = resizerElement.closest('th');
      if (!th) return;
      const widthDiff = event.clientX - this.grid.resizeStartX;
      let newWidth = this.grid.resizeStartWidth + widthDiff;
      if (newWidth < 50) {
        newWidth = 50;
      }
      th.style.width = `${newWidth}px`;
      th.style.minWidth = `${newWidth}px`;
    }

    /**
     * ì»¬ëŸ¼ ë¦¬ì‚¬ì´ì§• ì¢…ë£Œ
     */
    handleColumnResizeEnd() {
      if (!this.grid.isResizing) return;

      this.grid.isResizing = false;
      this.grid.table.classList.remove('resizing-active');
      document.body.style.cursor = '';

      const column = this.grid.columns.find((col) => col.field === this.grid.resizeField);
      if (column) {
        const resizerElement = this.grid.table.querySelector(`.column-resizer[data-field="${this.grid.resizeField}"]`);
        const th = resizerElement?.closest('th');
        if (th) {
          column.width = `${th.offsetWidth}px`;
        }
      }

      // âœ¨ [ì¶”ê°€] í´ë¦­ ì´ë²¤íŠ¸ ì°¨ë‹¨ í”Œë˜ê·¸ ì„¤ì •
      this.justResized = true;

      // âœ¨ [ì¶”ê°€] ì§§ì€ ì§€ì—° í›„ í”Œë˜ê·¸ í•´ì œ
      setTimeout(() => {
        this.justResized = false;
      }, 200);

      this.grid.resizeField = null;
    }
  }

  /**
   * Plugin Manager
   * @version 1.0.0
   * @description í”ŒëŸ¬ê·¸ì¸ ë“±ë¡/ì œê±°/ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” ì „ìš© í´ë˜ìŠ¤
   */

  class PluginManager {
    /**
     * @param {SmartGrid} grid - SmartGrid ì¸ìŠ¤í„´ìŠ¤
     */
    constructor(grid) {
      if (!grid) {
        throw new Error('PluginManager requires a SmartGrid instance');
      }
      this.grid = grid;
      this.plugins = new Map();
      this.initializationOrder = [];
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ë“±ë¡
     * @param {Class} Plugin - í”ŒëŸ¬ê·¸ì¸ í´ë˜ìŠ¤
     * @param {Object} options - í”ŒëŸ¬ê·¸ì¸ ì˜µì…˜
     * @returns {SmartGrid} - ì²´ì´ë‹ì„ ìœ„í•œ grid ë°˜í™˜
     */
    register(Plugin, options = {}) {
      try {
        // í”ŒëŸ¬ê·¸ì¸ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        const instance = new Plugin(this.grid, options);

        // name ì†ì„± ê²€ì¦
        if (!instance.name || typeof instance.name !== 'string') {
          throw new Error('í”ŒëŸ¬ê·¸ì¸ì€ name ì†ì„±(string)ì´ í•„ìš”í•©ë‹ˆë‹¤');
        }

        const pluginName = instance.name;

        // ì¤‘ë³µ ë“±ë¡ ì²˜ë¦¬
        if (this.plugins.has(pluginName)) {
          this.grid.warn('PLUGIN_ALREADY_REGISTERED', `í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì´ ì´ë¯¸ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë®ì–´ì”ë‹ˆë‹¤.`);
          this.unregister(pluginName);
        }

        // í”ŒëŸ¬ê·¸ì¸ ì €ì¥
        this.plugins.set(pluginName, instance);
        this.initializationOrder.push(pluginName);

        // ì§ì ‘ ì ‘ê·¼ì„ ìœ„í•œ getter ì„¤ì •
        this._definePluginAccessor(pluginName);

        // í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™”
        if (typeof instance.install === 'function') {
          instance.install();
        }

        this.grid.info(`í”ŒëŸ¬ê·¸ì¸ "${pluginName}" v${instance.version || '1.0.0'} ë“±ë¡ ì™„ë£Œ`);

        // ì´ë²¤íŠ¸ ë°œìƒ
        this.grid.emit('pluginRegistered', {
          name: pluginName,
          version: instance.version || '1.0.0',
          instance,
        });

        return this.grid;
      } catch (error) {
        this.grid.handleError(error, 'PluginManager.register');
        throw error;
      }
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì œê±°
     * @param {string} pluginName - ì œê±°í•  í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean} - ì œê±° ì„±ê³µ ì—¬ë¶€
     */
    unregister(pluginName) {
      try {
        const plugin = this.plugins.get(pluginName);

        if (!plugin) {
          this.grid.warn('PLUGIN_NOT_FOUND', `í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
          return false;
        }

        // í”ŒëŸ¬ê·¸ì¸ uninstall í˜¸ì¶œ
        if (typeof plugin.uninstall === 'function') {
          plugin.uninstall();
        }

        // getter ì œê±°
        this._removePluginAccessor(pluginName);

        // Mapì—ì„œ ì œê±°
        this.plugins.delete(pluginName);

        // ì´ˆê¸°í™” ìˆœì„œì—ì„œ ì œê±°
        const orderIndex = this.initializationOrder.indexOf(pluginName);
        if (orderIndex !== -1) {
          this.initializationOrder.splice(orderIndex, 1);
        }

        this.grid.info(`í”ŒëŸ¬ê·¸ì¸ "${pluginName}" ì œê±° ì™„ë£Œ`);

        // ì´ë²¤íŠ¸ ë°œìƒ
        this.grid.emit('pluginUnregistered', { name: pluginName });

        return true;
      } catch (error) {
        this.grid.handleError(error, 'PluginManager.unregister');
        return false;
      }
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean}
     */
    has(pluginName) {
      return this.plugins.has(pluginName);
    }

    /**
     * íŠ¹ì • í”ŒëŸ¬ê·¸ì¸ ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {PluginBase|null}
     */
    get(pluginName) {
      return this.plugins.get(pluginName) || null;
    }

    /**
     * ë“±ë¡ëœ ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ì´ë¦„ ëª©ë¡
     * @returns {string[]}
     */
    getNames() {
      return Array.from(this.plugins.keys());
    }

    /**
     * ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ì¸ìŠ¤í„´ìŠ¤ ëª©ë¡
     * @returns {PluginBase[]}
     */
    getAll() {
      return Array.from(this.plugins.values());
    }

    /**
     * ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ì„ Map í˜•íƒœë¡œ ë°˜í™˜
     * @returns {Map<string, PluginBase>}
     */
    getAllAsMap() {
      return new Map(this.plugins);
    }

    /**
     * ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ì œê±°
     * @returns {void}
     */
    unregisterAll() {
      // ì—­ìˆœìœ¼ë¡œ ì œê±° (ë‚˜ì¤‘ì— ë“±ë¡ëœ ê²ƒë¶€í„° ì œê±°)
      const names = [...this.initializationOrder].reverse();
      names.forEach((name) => this.unregister(name));

      // ì•ˆì „ ì¥ì¹˜: Mapì´ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ê°•ì œ ì œê±°
      if (this.plugins.size > 0) {
        this.plugins.forEach((plugin, name) => {
          this.unregister(name);
        });
      }
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ê°œìˆ˜
     * @returns {number}
     */
    get count() {
      return this.plugins.size;
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™” ìƒíƒœ í™•ì¸
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean}
     */
    isInstalled(pluginName) {
      const plugin = this.get(pluginName);
      if (!plugin) return false;
      return typeof plugin.isInstalled === 'function' ? plugin.isInstalled() : plugin.initialized === true;
    }

    /**
     * íŠ¹ì • ì¡°ê±´ìœ¼ë¡œ í”ŒëŸ¬ê·¸ì¸ í•„í„°ë§
     * @param {Function} filterFn - í•„í„° í•¨ìˆ˜ (plugin => boolean)
     * @returns {PluginBase[]}
     */
    filter(filterFn) {
      if (typeof filterFn !== 'function') {
        throw new Error('filter requires a function');
      }
      return this.getAll().filter(filterFn);
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì •ë³´ë¥¼ ê°ì²´ ë°°ì—´ë¡œ ë°˜í™˜
     * @returns {Array<{name: string, version: string, installed: boolean}>}
     */
    getPluginInfoList() {
      return this.getAll().map((plugin) => ({
        name: plugin.name,
        version: plugin.version || '1.0.0',
        installed: this.isInstalled(plugin.name),
        options: plugin.options || {},
      }));
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™” ìˆœì„œ ì¡°íšŒ
     * @returns {string[]}
     */
    getInitializationOrder() {
      return [...this.initializationOrder];
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì˜ì¡´ì„± ê²€ì¦
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean}
     */
    validateDependencies(pluginName) {
      const plugin = this.get(pluginName);
      if (!plugin) return false;

      const dependencies = plugin.dependencies || [];
      if (dependencies.length === 0) return true;

      const missingDeps = dependencies.filter((dep) => !this.has(dep));

      if (missingDeps.length > 0) {
        this.grid.warn('PLUGIN_DEPENDENCY_MISSING', `í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì˜ ì˜ì¡´ì„±ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤: ${missingDeps.join(', ')}`);
        return false;
      }

      return true;
    }

    /**
     * ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ì˜ì¡´ì„± ê²€ì¦
     * @returns {boolean}
     */
    validateAllDependencies() {
      let allValid = true;
      this.getNames().forEach((name) => {
        if (!this.validateDependencies(name)) {
          allValid = false;
        }
      });
      return allValid;
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì§ì ‘ ì ‘ê·¼ì„ ìœ„í•œ getter ì •ì˜
     * @private
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     */
    _definePluginAccessor(pluginName) {
      if (this.grid[pluginName] !== undefined) {
        this.grid.warn('PLUGIN_NAME_CONFLICT', `í”ŒëŸ¬ê·¸ì¸ ì´ë¦„ "${pluginName}"ì´ ì´ë¯¸ SmartGridì˜ ì†ì„±/ë©”ì„œë“œì™€ ì¶©ëŒí•©ë‹ˆë‹¤.`);
        return;
      }

      Object.defineProperty(this.grid, pluginName, {
        get() {
          return this.pluginManager.plugins.get(pluginName);
        },
        configurable: true,
        enumerable: false,
      });
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ getter ì œê±°
     * @private
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     */
    _removePluginAccessor(pluginName) {
      if (this.grid[pluginName] !== undefined) {
        try {
          delete this.grid[pluginName];
        } catch (error) {
          this.grid.warn('PLUGIN_ACCESSOR_REMOVAL_FAILED', `í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì˜ ì ‘ê·¼ì ì œê±°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`);
        }
      }
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì •ë³´ ì¶œë ¥ (ë””ë²„ê¹…ìš©)
     * @param {boolean} detailed - ìƒì„¸ ì •ë³´ ì¶œë ¥ ì—¬ë¶€
     */
    debug(detailed = false) {
      if (!this.grid.debugMode) return;

      console.group(`ğŸ”Œ Plugin Manager [${this.grid.tableId}]`);
      console.log(`Total Plugins: ${this.count}`);
      console.log(`Initialization Order: ${this.initializationOrder.join(' â†’ ')}`);

      if (detailed) {
        this.plugins.forEach((plugin, name) => {
          console.group(`  ğŸ“¦ ${name}`);
          console.log(`    Version: ${plugin.version || '1.0.0'}`);
          console.log(`    Installed: ${this.isInstalled(name) ? 'âœ“' : 'âœ—'}`);
          console.log(`    Dependencies: ${plugin.dependencies?.join(', ') || 'None'}`);
          console.log(`    Options:`, plugin.options);
          console.groupEnd();
        });
      } else {
        this.plugins.forEach((plugin, name) => {
          const status = this.isInstalled(name) ? 'âœ“' : 'âœ—';
          console.log(`  ${status} ${name} (v${plugin.version || '1.0.0'})`);
        });
      }

      console.groupEnd();
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì„¤ì • ë‚´ë³´ë‚´ê¸° (ì €ì¥/ë³µì› ê¸°ëŠ¥)
     * @returns {Array<{Plugin: Class, options: Object}>}
     */
    exportConfigs() {
      return this.getAll().map((plugin) => ({
        name: plugin.name,
        version: plugin.version || '1.0.0',
        options: { ...plugin.options },
      }));
    }

    /**
     * ì—¬ëŸ¬ í”ŒëŸ¬ê·¸ì¸ ì¼ê´„ ë“±ë¡
     * @param {Array<{Plugin: Class, options?: Object}>} configs - í”ŒëŸ¬ê·¸ì¸ ì„¤ì • ë°°ì—´
     * @returns {Promise<SmartGrid>}
     */
    async batchRegister(configs) {
      if (!Array.isArray(configs)) {
        throw new Error('batchRegister requires an array of plugin configs');
      }

      for (const config of configs) {
        if (!config.Plugin) {
          this.grid.warn('INVALID_PLUGIN_CONFIG', 'Plugin ì†ì„±ì´ ëˆ„ë½ëœ ì„¤ì •ì´ ìˆìŠµë‹ˆë‹¤.');
          continue;
        }

        try {
          await this.register(config.Plugin, config.options || {});
        } catch (error) {
          this.grid.handleError(error, 'PluginManager.batchRegister');
        }
      }

      return this.grid;
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ í™œì„±í™” (ë¹„í™œì„±í™”ëœ í”ŒëŸ¬ê·¸ì¸ ì¬í™œì„±í™”)
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean}
     */
    enable(pluginName) {
      const plugin = this.get(pluginName);
      if (!plugin) {
        this.grid.warn('PLUGIN_NOT_FOUND', `í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return false;
      }

      if (this.isInstalled(pluginName)) {
        this.grid.info(`í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì€ ì´ë¯¸ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`);
        return true;
      }

      if (typeof plugin.install === 'function') {
        plugin.install();
        this.grid.info(`í”ŒëŸ¬ê·¸ì¸ "${pluginName}" í™œì„±í™”ë¨`);
        this.grid.emit('pluginEnabled', { name: pluginName });
        return true;
      }

      return false;
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ë¹„í™œì„±í™” (ì œê±°í•˜ì§€ ì•Šê³  ì¼ì‹œ ì¤‘ì§€)
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean}
     */
    disable(pluginName) {
      const plugin = this.get(pluginName);
      if (!plugin) {
        this.grid.warn('PLUGIN_NOT_FOUND', `í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return false;
      }

      if (!this.isInstalled(pluginName)) {
        this.grid.info(`í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì€ ì´ë¯¸ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`);
        return true;
      }

      if (typeof plugin.uninstall === 'function') {
        plugin.uninstall();
        this.grid.info(`í”ŒëŸ¬ê·¸ì¸ "${pluginName}" ë¹„í™œì„±í™”ë¨`);
        this.grid.emit('pluginDisabled', { name: pluginName });
        return true;
      }

      return false;
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì¬ì‹œì‘ (uninstall â†’ install)
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean}
     */
    restart(pluginName) {
      const plugin = this.get(pluginName);
      if (!plugin) {
        this.grid.warn('PLUGIN_NOT_FOUND', `í”ŒëŸ¬ê·¸ì¸ "${pluginName}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return false;
      }

      this.disable(pluginName);
      return this.enable(pluginName);
    }

    /**
     * ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ìƒíƒœ ì¡°íšŒ
     * @returns {Object} - {installed: [], uninstalled: []}
     */
    getStatus() {
      const installed = [];
      const uninstalled = [];

      this.plugins.forEach((plugin, name) => {
        if (this.isInstalled(name)) {
          installed.push(name);
        } else {
          uninstalled.push(name);
        }
      });

      return { installed, uninstalled };
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ í†µê³„
     * @returns {Object}
     */
    getStats() {
      const status = this.getStatus();
      return {
        total: this.count,
        installed: status.installed.length,
        uninstalled: status.uninstalled.length,
        names: this.getNames(),
        initOrder: this.getInitializationOrder(),
      };
    }
  }

  /**
   * SmartGrid Main Class with Plugin System
   * @version 1.0.0
   * @description í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œì´ ì¶”ê°€ëœ SmartGrid ë©”ì¸ í´ë˜ìŠ¤
   */

  class SmartGrid extends EventEmitter {
    // ========== ì •ì  ìƒìˆ˜ ==========
    static BUTTON_CONFIG = {
      Add: { text: 'ì¶”ê°€', action: 'addRow', icon: 'bi bi-plus-lg' },
      Edit: { text: 'ìˆ˜ì •', action: 'setEditMode', params: [true], icon: 'bi bi-pencil-square' },
      Save: { text: 'ì €ì¥', action: 'saveRow', icon: 'bi bi-save' },
      Cancel: { text: 'ì·¨ì†Œ', action: 'rejectRow', icon: 'bi bi-x-circle' },
      Delete: { text: 'ì‚­ì œ', action: 'deleteRow', icon: 'bi bi-trash' },
      Print: { text: 'ì¸ì‡„', action: 'printCurrentPage', icon: 'bi bi-printer' },
    };

    static PAGE_SIZE_OPTIONS = [
      { value: 10, text: '10ê°œì”©' },
      { value: 20, text: '20ê°œì”©' },
      { value: 50, text: '50ê°œì”©' },
      { value: 100, text: '100ê°œì”©' },
      { value: 'all', text: 'ì „ì²´ ë³´ê¸°' },
    ];

    static instances = new Set();
    static globalEventsInitialized = false;

    // ========== ì¸ìŠ¤í„´ìŠ¤ ì†ì„± ==========
    table;
    options;
    wrapper = null;
    dataHandler = null;
    renderer = null;
    eventHandler = null;
    uiComponents = null;
    pluginManager = null; // â­ ë³€ê²½: plugins â†’ pluginManager

    columns = [];
    originalData = [];
    originalDataBackup = [];
    currentPageData = [];
    totalRows = 0;
    pageSize = 10;
    currentPage = 1;
    pagingMode = 'client';
    isEditMode = false;
    changedRows = { newRows: [], updatedRows: [], deletedRows: [] };
    sortOrders = [];
    rowHeight = 35;
    isResizing = false;
    resizeStartX = 0;
    resizeStartWidth = 0;
    resizeField = null;
    hiddenColumns = new Set();
    inputFactory = null;
    filters = {};
    warnings = [];
    lastParams = {};

    // ========== ìƒì„±ì ==========
    constructor(tableId, options = {}) {
      super();
      try {
        this.tableId = tableId;
        this.instanceId = `sg_${tableId}`;
        this.debugMode = options.debug ?? false;
        this.table = document.getElementById(tableId);
        if (!this.table) {
          throw new SmartGridError(`í…Œì´ë¸”ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: "${tableId}"`, 'ELEMENT_NOT_FOUND', this.instanceId, { tableId });
        }
        SmartGrid.instances.add(this);

        this.columns = options.columns || [];
        this.options = {
          idField: 'id',
          pageSize: 10,
          page: 1,
          pagingMode: 'client',
          rowHeight: 35,
          enableCheckboxColumn: true,
          enableIndexColumn: true,
          enableEditMode: true,
          loadFilter: null,
          onLoadSuccess: null,
          onLoadError: null,
          enableToolbar: true,
          enablePagination: true,
          enableTotalRows: true,
          enablePageSizeSelect: true,
          toolbarButtons: Object.keys(SmartGrid.BUTTON_CONFIG),

          queryParams: {},
          ...options,
        };
        this.lastParams = this.options.queryParams || {};
        this.pageSize = this.options.pageSize;
        this.currentPage = this.options.page;
        this.rowHeight = this.options.rowHeight;

        // â­ PluginManager ì´ˆê¸°í™” ì¶”ê°€
        this.pluginManager = new PluginManager(this);

        // í•¸ë“¤ëŸ¬ ì´ˆê¸°í™”
        if (this.options.pagingMode === 'server' && this.options.url) {
          this.dataHandler = new ServerSideHandler(this);
        } else {
          this.dataHandler = new ClientSideHandler(this);
        }

        // ë Œë”ëŸ¬ ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì´ˆê¸°í™”
        this.renderer = new GridRenderer(this);
        this.eventHandler = new GridEvents(this);
        this.uiComponents = new UIComponents(this);

        this.initializeColumns();
        this.setRowHeight(this.rowHeight, false);
        this.createWrapper();
        this.createUIElements();
        this.initializeGlobalEvents();
        this.validateConfiguration();
        this.info('ê·¸ë¦¬ë“œ ì´ˆê¸°í™” ì™„ë£Œ');
      } catch (error) {
        this.handleError(error, 'constructor');
        throw error;
      }
    }

    // ========== Getter ==========
    get idField() {
      return this.options.idField;
    }
    get enableCheckboxColumn() {
      return this.options.enableCheckboxColumn;
    }
    get enableIndexColumn() {
      return this.options.enableIndexColumn;
    }
    get editModeEnabled() {
      return this.options.enableEditMode;
    }

    // ========== ì •ì  ë©”ì„œë“œ ==========
    static getInstance(instanceId) {
      for (const instance of SmartGrid.instances) {
        if (instance.instanceId === instanceId) return instance;
      }
      return null;
    }
    static findByTableId(tableId) {
      for (const instance of SmartGrid.instances) {
        if (instance.tableId === tableId) return instance;
      }
      return null;
    }
    static getAllInstances() {
      return Array.from(SmartGrid.instances);
    }

    // ========== í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ (ìœ„ì„ íŒ¨í„´) ==========

    /**
     * í”ŒëŸ¬ê·¸ì¸ ë“±ë¡
     * @param {Class} Plugin - í”ŒëŸ¬ê·¸ì¸ í´ë˜ìŠ¤
     * @param {Object} options - í”ŒëŸ¬ê·¸ì¸ ì˜µì…˜
     * @returns {SmartGrid} - ì²´ì´ë‹ì„ ìœ„í•œ this ë°˜í™˜
     */
    use(Plugin, options = {}) {
      return this.pluginManager.register(Plugin, options);
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì œê±°
     * @param {string} pluginName - ì œê±°í•  í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean} - ì œê±° ì„±ê³µ ì—¬ë¶€
     */
    removePlugin(pluginName) {
      return this.pluginManager.unregister(pluginName);
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {boolean}
     */
    hasPlugin(pluginName) {
      return this.pluginManager.has(pluginName);
    }

    /**
     * ë“±ë¡ëœ ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ëª©ë¡
     * @returns {string[]}
     */
    getPluginNames() {
      return this.pluginManager.getNames();
    }

    /**
     * íŠ¹ì • í”ŒëŸ¬ê·¸ì¸ ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
     * @param {string} pluginName - í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     * @returns {PluginBase|null}
     */
    getPlugin(pluginName) {
      return this.pluginManager.get(pluginName);
    }

    // ========== ì´ˆê¸°í™” ë©”ì„œë“œ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€) ==========

    initializeColumns() {
      this.columns.forEach((col, index) => {
        // í•„ë“œëª… ê¸°ë³¸ê°’ ì„¤ì •
        col.field ?? (col.field = col.hideColumn ? void 0 : `column_${index}`);

        // ì œëª© ê¸°ë³¸ê°’ ì„¤ì •
        col.title ?? (col.title = col.field || `ì»¬ëŸ¼ ${index + 1}`);

        // ë„ˆë¹„ ê¸°ë³¸ê°’ ì„¤ì •
        col.width ?? (col.width = 'auto');

        // í—¤ë” ì •ë ¬ ê¸°ë³¸ê°’ ì„¤ì •
        col.headAlign ?? (col.headAlign = 'center');

        // í”„ë¦°íŠ¸ ì¶œë ¥ ê¸°ë³¸ê°’ ì„¤ì •
        col.print ?? (col.print = true);

        // ì—‘ì…€ ì¶œë ¥ ê¸°ë³¸ê°’ ì„¤ì •
        col.exportExcel ?? (col.exportExcel = true);

        // ì—ë””í„° ê°ì²´ ì •ê·œí™”
        if (typeof col.editor !== 'object' || col.editor === null) {
          col.editor = { type: col.editor || 'textbox' };
        }

        // ì…€ ì •ë ¬ ê¸°ë³¸ê°’ ì„¤ì •
        col.cellAlign ?? (col.cellAlign = col.editor.type === 'numberbox' ? 'right' : 'left');
      });
    }

    // ========== [ì¶”ê°€] í–‰ í´ë¦­ ì´ë²¤íŠ¸ ë°”ì¸ë”© ==========
    _bindRowClick() {
      const tbody = this.table?.querySelector('tbody');
      if (!tbody) return;

      // ê¸°ì¡´ ì´ë²¤íŠ¸ ì œê±°
      if (this._rowClickHandler) {
        tbody.removeEventListener('click', this._rowClickHandler);
      }

      // ìƒˆ ì´ë²¤íŠ¸ ìƒì„±
      this._rowClickHandler = (e) => {
        const tr = e.target.closest('tr[data-row-id]');
        if (!tr) return;

        const rowId = tr.getAttribute('data-row-id');
        const rowData = this.findRowData(rowId);
        if (!rowData) return;

        // ì„ íƒ ê°•ì¡° (ì„ íƒ í‘œì‹œ)
        tbody.querySelectorAll('tr').forEach((r) => r.classList.remove('sg-row-selected'));
        tr.classList.add('sg-row-selected');

        // rowClick ì´ë²¤íŠ¸ ë°œìƒ
        this.emit('rowClick', rowData, e);
      };

      tbody.addEventListener('click', this._rowClickHandler);
    }

    createWrapper() {
      const container = document.createElement('div');
      container.className = 'smartgrid-container';
      this.table.parentNode.insertBefore(container, this.table);
      container.appendChild(this.table);

      const wrapper = document.createElement('div');
      wrapper.className = 'smartgrid-wrapper';
      wrapper.setAttribute('data-instance', this.instanceId);
      wrapper.setAttribute('data-grid-id', this.tableId);

      if (this.options.width !== undefined) {
        wrapper.style.width = typeof this.options.width === 'number' ? `${this.options.width}px` : this.options.width;
      }

      container.parentNode.insertBefore(wrapper, container);
      wrapper.appendChild(container);

      if (this.options.height !== undefined) {
        container.style.height = typeof this.options.height === 'number' ? `${this.options.height}px` : this.options.height;
      }
      // container.style.overflow = 'auto';
      container.setAttribute('data-instance', this.instanceId);
      container.setAttribute('data-grid-id', this.tableId);

      this.wrapper = wrapper;
    }

    createUIElements() {
      this.uiComponents.createAll();
      if (this.options.enableToolbar || this.options.enableTotalRows || this.options.enablePageSizeSelect) {
        this.createToolbar();
      }
    }

    createToolbar() {
      if (!this.options.enableToolbar && !this.options.enableTotalRows && !this.options.enablePageSizeSelect) return;

      const toolbarContainer = document.createElement('div');
      toolbarContainer.className = 'smartgrid-toolbar-container';
      toolbarContainer.setAttribute('data-grid-id', this.tableId);

      const section1 = document.createElement('div');
      section1.className = 'smartgrid-toolbar-section';

      if (this.options.enableToolbar) {
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'smartgrid-toolbar-group';
        section1.appendChild(buttonGroup);
        const toolbarButtons = this.options.toolbarButtons;
        const buttonEntries = Array.isArray(toolbarButtons) ? toolbarButtons.map((btn) => [null, btn]) : Object.entries(toolbarButtons);
        buttonEntries.forEach(([key, btnConfig]) => {
          let config;
          if (typeof btnConfig === 'string') {
            config = SmartGrid.BUTTON_CONFIG[btnConfig];
          } else {
            config = btnConfig[Object.keys(btnConfig)[0]];
          }

          const button = document.createElement('button');
          button.className = config.className ? config.className : 'smartgrid-btn smartgrid-btn-secondary';
          const iconHtml = config.icon ? `<i class="${config.icon}"></i>` : '';
          button.innerHTML = `${iconHtml}<span>${config.text}</span>`;
          button.addEventListener('click', (event) => {
            event.stopPropagation();
            if (typeof config.action === 'function') {
              config.action.call(this, event);
            } else if (typeof config.action === 'string') {
              const action = this[config.action];
              if (typeof action === 'function') {
                action.apply(this, config.params || []);
              }
            }
          });
          buttonGroup.appendChild(button);
        });
      }

      const section2 = document.createElement('div');
      section2.className = 'smartgrid-toolbar-section';

      if (this.options.enableTotalRows) {
        const totalRowsDiv = document.createElement('div');
        totalRowsDiv.id = `${this.instanceId}_totalRows`;
        totalRowsDiv.className = 'smartgrid-info-text';
        section2.appendChild(totalRowsDiv);
        this.totalRowsElement = totalRowsDiv;
      }

      if (this.options.enablePageSizeSelect) {
        const pageSizeSelect = document.createElement('select');
        pageSizeSelect.id = `${this.instanceId}_pageSize`;
        pageSizeSelect.className = 'smartgrid-select';

        pageSizeSelect.innerHTML = SmartGrid.PAGE_SIZE_OPTIONS.map((opt) => `<option value="${opt.value}">${opt.text}</option>`).join('');

        pageSizeSelect.value = this.pageSize;
        pageSizeSelect.addEventListener('change', (e) => {
          const newSize = e.target.value;
          if (newSize === 'all') {
            if (this.pagingMode === 'client') {
              this.setPageSize(this.getSortedData().length || 1);
              this.changePage();
            } else {
              //     this.showToast("ì„œë²„ì‚¬ì´ë“œ ëª¨ë“œì—ì„œëŠ” 'ì „ì²´ ë³´ê¸°'ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", 'warning');
              //     e.target.value = this.pageSize;
              //   }
              if (this.totalRows > 0) {
                this.setPageSize(this.totalRows); // í˜ì´ì§€ í¬ê¸°ë¥¼ ì „ì²´ í–‰ ìˆ˜ë¡œ ì„¤ì •
                this.changePage(); // 1í˜ì´ì§€ë¶€í„° ëª¨ë“  ë°ì´í„°ë¥¼ ë‹¤ì‹œ ë¡œë“œ
              } else {
                this.showToast("ì„œë²„ì‚¬ì´ë“œ ëª¨ë“œì—ì„œëŠ” 'ì „ì²´ ë³´ê¸°'ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", 'warning');
                e.target.value = this.pageSize; // 'ì „ì²´ ë³´ê¸°' ì„ íƒ ì·¨ì†Œ
              }
            }
          } else {
            this.setPageSize(parseInt(newSize, 10));
            this.changePage();
          }
        });
        section2.appendChild(pageSizeSelect);
        this.pageSizeSelectElement = pageSizeSelect;
      }

      if (section1.children.length > 0) toolbarContainer.appendChild(section1);
      if (section2.children.length > 0) toolbarContainer.appendChild(section2);
      if (toolbarContainer.children.length > 0) {
        this.wrapper.insertBefore(toolbarContainer, this.wrapper.firstChild);
        this.toolbarElement = toolbarContainer;
      }
    }

    initializeGlobalEvents() {
      if (SmartGrid.globalEventsInitialized) return;
      document.addEventListener('mousemove', (e) => {
        SmartGrid.instances.forEach((grid) => {
          if (grid.isResizing) grid.eventHandler.handleColumnResizeMove(e);
        });
      });
      document.addEventListener('mouseup', (e) => {
        SmartGrid.instances.forEach((grid) => {
          if (grid.isResizing) grid.eventHandler.handleColumnResizeEnd(e);
        });
      });
      document.addEventListener('click', (e) => {
        SmartGrid.instances.forEach((grid) => {
          const contextMenu = grid.uiComponents.contextMenuElement;
          if (contextMenu && !contextMenu.contains(e.target)) {
            const isContextMenuItem = e.target.closest('.smartgrid-context-menu-item');
            if (!isContextMenuItem || e.target.getAttribute('data-instance') !== grid.instanceId) {
              contextMenu.style.display = 'none';
            }
          }
          const columnPanel = grid.uiComponents.columnPanelElement;
          if (columnPanel && !columnPanel.contains(e.target)) {
            const toggleBtn = document.getElementById(`${grid.instanceId}_toggleColumnsBtn`);
            if (!toggleBtn || !toggleBtn.contains(e.target)) {
              columnPanel.classList.remove('active');
            }
          }
        });
      });
      SmartGrid.globalEventsInitialized = true;
    }

    validateConfiguration() {
      if (!this.columns || this.columns.length === 0) {
        this.warn('NO_COLUMNS', 'ì»¬ëŸ¼ì´ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¹ˆ í…Œì´ë¸”ì´ í‘œì‹œë©ë‹ˆë‹¤.');
      }
      const fieldIds = this.columns.map((col) => col.field).filter(Boolean);
      const duplicates = fieldIds.filter((field, index) => fieldIds.indexOf(field) !== index);
      if (duplicates.length > 0) {
        this.warn('DUPLICATE_FIELDS', `ì¤‘ë³µëœ í•„ë“œ IDê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤: ${duplicates.join(', ')}`);
      }
      if (this.options.pageSize > 100) {
        this.warn('LARGE_PAGE_SIZE', `í˜ì´ì§€ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤: ${this.options.pageSize}. ì„±ëŠ¥ ì €í•˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
      }
    }

    // ========== ë°ì´í„° ë¡œë“œ ë©”ì„œë“œ ==========
    async loadData(data) {
      if (this.dataHandler instanceof ClientSideHandler) {
        return this.dataHandler.load(data);
      } else {
        this.warn('INVALID_OPERATION', 'ì„œë²„ ëª¨ë“œì—ì„œëŠ” loadData ëŒ€ì‹  fetchDataë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.');
      }
    }

    // SmartGrid.js
    async fetchData(params) {
      // â—€ (params = {}) ê¸°ë³¸ê°’ ì œê±°
      if (params !== undefined) {
        // â—€ 'params'ê°€ ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬ëœ ê²½ìš°ì—ë§Œ lastParamsë¥¼ ë®ì–´ì”ë‹ˆë‹¤.
        this.lastParams = params;
      }
      // 'params'ê°€ undefinedì´ë©´(fetchData() í˜¸ì¶œ) ê¸°ì¡´ lastParamsë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
      return this.dataHandler.load();
    }

    // ========== ì •ë ¬/í˜ì´ì§• ë©”ì„œë“œ ==========
    async sortColumn(field) {
      this.emit('beforeSort', { field, sortOrders: [...this.sortOrders] });

      const existingIndex = this.sortOrders.findIndex((order) => order.field === field);
      if (existingIndex !== -1) {
        const currentOrder = this.sortOrders[existingIndex].order;
        if (currentOrder === 'asc') this.sortOrders[existingIndex].order = 'desc';
        else if (currentOrder === 'desc') this.sortOrders.splice(existingIndex, 1);
      } else {
        this.sortOrders.push({ field, order: 'asc' });
      }

      await this.dataHandler.sort();

      this.emit('afterSort', { field, sortOrders: [...this.sortOrders] });
    }

    async changePage() {
      const beforeEvent = { currentPage: this.currentPage, cancelled: false };
      this.emit('beforePageChange', beforeEvent);
      if (beforeEvent.cancelled) return;

      await this.dataHandler.page();

      this.emit('afterPageChange', { currentPage: this.currentPage });
    }

    setPageSize(newPageSize) {
      this.pageSize = parseInt(newPageSize, 10);
      this.currentPage = 1;
    }

    // ========== CRUD ë©”ì„œë“œ ==========
    addRow() {
      this.dataHandler.add();
    }

    saveRow() {
      this.dataHandler.save();
    }

    rejectRow() {
      this.dataHandler.reject();
    }

    deleteRow() {
      this.dataHandler.delete();
    }

    // ========== ë°ì´í„° ì¡°íšŒ ë©”ì„œë“œ ==========
    getData() {
      return this.getSortedData();
    }

    getSortedData() {
      return this.dataHandler.getSortedData();
    }

    getRows() {
      return [...this.currentPageData];
    }

    getCheckedRows() {
      if (!this.currentPageData || !Array.isArray(this.currentPageData)) {
        // ì´ ë¶€ë¶„ì´ í•œê¸€ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.
        this.warn('GET_CHECKED_ROWS_FAILED', 'í˜„ì¬ í˜ì´ì§€ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        return [];
      }
      return this.currentPageData.filter((row) => row.checked === true);
    }

    updateTotalRowsInfo() {
      this.dataHandler.updateTotalRowsInfo();
    }

    invalidateSortCache() {
      if (this.dataHandler instanceof ClientSideHandler) {
        this.dataHandler.invalidateSortCache();
      }
    }

    // ========== ë Œë”ë§ ë©”ì„œë“œ ==========
    renderGrid() {
      this.renderer.renderGrid();
      this.eventHandler.setupEventDelegation();
      this._bindRowClick();
    }

    renderPagination() {
      this.uiComponents.renderPagination();
    }

    updateSortIndicator(field) {
      const th = this.table.querySelector(`th[data-field="${field}"]`);
      if (!th) return;
      const sortSpan = th.querySelector('.sort-indicator');
      if (!sortSpan) return;

      const { order, index } = this.getSortOrder(field);
      let html = '';

      if (index !== null) {
        html += `<span class="smartgrid-badge">${index}</span>`;
      }

      if (order === 'asc') {
        html += `<i class="bi bi-caret-up-fill" style="font-size:12px; color: var(--sg-gray-900);"></i>`;
      } else if (order === 'desc') {
        html += `<i class="bi bi-caret-down-fill" style="font-size:12px; color: var(--sg-gray-900);"></i>`;
      } else {
        html += `<i class="bi bi-arrow-down-up" style="font-size:12px; color: var(--sg-gray-400);"></i>`;
      }

      sortSpan.innerHTML = html;
    }

    // ========== ì»¬ëŸ¼ ë¦¬ì‚¬ì´ì§• ==========
    startColumnResize(event, column) {
      this.eventHandler.startColumnResize(event, column);
    }

    // ========== ì…ë ¥ ìš”ì†Œ ìƒì„± ==========
    getInputFactory() {
      this.inputFactory ??= new InputFactory(this);
      return this.inputFactory;
    }

    createCellInput(column, rowData, value) {
      return this.getInputFactory().create(column, rowData, value);
    }

    // ========== í–‰ ë°ì´í„° ì—…ë°ì´íŠ¸ ==========
    updateRowData(rowData, field, value) {
      if (rowData[field] === value) return;
      const oldValue = rowData[field];
      const column = this.columns.find((col) => col.field === field);
      const beforeEvent = { rowData, field, oldValue, newValue: value, cancelled: false };
      this.emit('beforeCellChange', beforeEvent);
      if (beforeEvent.cancelled) return;

      if (column?.editor.type === 'numberbox') {
        if (value === '' || value === null || value === undefined) {
          value = null;
        } else {
          // ì½¤ë§ˆê°€ í¬í•¨ëœ ë¬¸ìì—´ì´ ë“¤ì–´ì˜¬ ê²½ìš° ì œê±°
          if (typeof value === 'string') {
            value = value.replace(/,/g, '');
          }
          value = parseFloat(value) || 0;
          if (column.editor.decimalPlaces !== undefined) {
            value = parseFloat(value.toFixed(column.editor.decimalPlaces));
          }
        }
      }

      rowData[field] = value;

      const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
      const formulaColumns = this.columns.filter((col) => typeof col.formula === 'function');

      if (formulaColumns.length > 0 && rowElement) {
        const cells = new Map(Array.from(rowElement.querySelectorAll('td[data-field]')).map((cell) => [cell.getAttribute('data-field'), cell]));

        formulaColumns.forEach((col, index) => {
          let formulaValue = this.evaluateFormula(col.formula, rowData, col, index);
          if (isNaN(formulaValue)) {
            formulaValue = 0;
          }

          // âœ… numberbox íƒ€ì…ì´ê³  decimalPlacesê°€ ìˆìœ¼ë©´ ë°˜ì˜¬ë¦¼ ì²˜ë¦¬
          if (col.editor.type === 'numberbox' && col.editor.decimalPlaces !== undefined) {
            formulaValue = parseFloat(formulaValue.toFixed(col.editor.decimalPlaces));
          }

          // âœ… ë°˜ì˜¬ë¦¼ëœ ê°’ì„ ë°ì´í„°ì— ì €ì¥
          rowData[col.field] = formulaValue;

          const cell = cells.get(col.field);
          if (cell) {
            let displayValue = formulaValue;

            // í‘œì‹œìš© í¬ë§·íŒ…
            if (col.editor.type === 'numberbox' && col.editor.decimalPlaces !== undefined) {
              const decimalPlaces = col.editor.decimalPlaces;
              displayValue = formatNumber(formulaValue, decimalPlaces);
            }

            this.renderer.updateCellDisplay(cell, col, displayValue);
          }
        });
      }

      if (!this.changedRows.newRows.includes(rowData) && !this.changedRows.updatedRows.includes(rowData)) {
        this.changedRows.updatedRows.push(rowData);
        rowElement?.classList.add('row-updated');
      }

      this.invalidateSortCache();
      this.renderer.updateTableFooter();
      this.emit('afterCellChange', { rowData, field, oldValue, newValue: value });
    }

    findRowData(rowId) {
      const findById = (row) => String(row[this.idField]) === String(rowId);
      return this.currentPageData.find(findById) || this.originalData.find(findById);
    }

    // ========== ìˆ˜ì‹/í•„í„° ==========
    applyFormula(row) {
      this.columns.forEach((col, index) => {
        if (col.formula) {
          row[col.field] = this.evaluateFormula(col.formula, row, col, index);
        }
      });
    }

    evaluateFormula(formula, row, column, index) {
      if (typeof formula !== 'function') return undefined;
      try {
        let result = formula(row, column, index); // ìˆ˜ì‹ ê³„ì‚° ê²°ê³¼ // â˜… [ì¶”ê°€ëœ ë¡œì§] ê²°ê³¼ê°€ NaNì¸ì§€ í™•ì¸í•˜ê³  0ìœ¼ë¡œ ëŒ€ì²´

        if (isNaN(result)) {
          return 0;
        }

        return result;
      } catch (err) {
        console.error(`Error executing formula for column "${column.field}":`, err);
        return 0; // ì˜ˆì™¸ ë°œìƒ ì‹œ ê¸°ì¡´ëŒ€ë¡œ 0 ë°˜í™˜
      }
    }

    compareRowsForSort(rowA, rowB) {
      for (const { field, order } of this.sortOrders) {
        const valueA = rowA[field] ?? '';
        const valueB = rowB[field] ?? '';
        if (valueA < valueB) return order === 'asc' ? -1 : 1;
        if (valueA > valueB) return order === 'asc' ? 1 : -1;
      }
      return 0;
    }

    applyFilters(data) {
      if (!this.filters || Object.keys(this.filters).length === 0) {
        return data;
      }
      return data.filter((row) => {
        if (this.filters.keyword) {
          const keyword = this.filters.keyword.toLowerCase();
          const matchFields = ['fCode', 'fName', 'fOrigin', 'comment'];
          const hasMatch = matchFields.some((field) =>
            String(row[field] || '')
              .toLowerCase()
              .includes(keyword)
          );
          if (!hasMatch) return false;
        }
        if (this.filters.startDate && row.expDate < this.filters.startDate) return false;
        if (this.filters.endDate && row.expDate > this.filters.endDate) return false;
        if (this.filters.status && this.filters.status.length > 0) {
          if (!this.filters.status.includes(row.stockStatus)) return false;
        }
        return true;
      });
    }

    getSortOrder(field) {
      const sortOrder = this.sortOrders.find((order) => order.field === field);
      const sortIndex = this.sortOrders.findIndex((order) => order.field === field);
      return {
        order: sortOrder?.order || null,
        index: sortIndex !== -1 ? sortIndex + 1 : null,
      };
    }

    // ========== í–‰ ë†’ì´ ì„¤ì • ==========
    setRowHeight(height, reRender = true) {
      this.rowHeight = parseInt(height, 10) || 30;
      if (this.table) {
        this.table.style.setProperty('--row-height', `${this.rowHeight}px`);
      } else {
        document.documentElement.style.setProperty('--row-height', `${this.rowHeight}px`);
      }
      if (reRender) {
        this.renderGrid();
        this.showToast(`í–‰ ë†’ì´ê°€ ${this.rowHeight}pxë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
      }
    }

    // ========== ìˆ˜ì • ëª¨ë“œ ==========
    setEditMode(enabled) {
      if (enabled && (this.changedRows.newRows.length > 0 || this.changedRows.updatedRows.length > 0 || this.changedRows.deletedRows.length > 0)) {
        this.showToast('ì €ì¥í•˜ì§€ ì•Šì€ ë³€ê²½ ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € ì €ì¥í•˜ê±°ë‚˜ ì·¨ì†Œí•´ì£¼ì„¸ìš”.', 'warning');
        return false;
      }
      if (!this.editModeEnabled) {
        this.showToast('ì´ ê·¸ë¦¬ë“œëŠ” ìˆ˜ì • ëª¨ë“œê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.', 'warning');
        return false;
      }
      if (this.isEditMode === enabled) return false;

      const beforeEvent = { previousMode: this.isEditMode, newMode: enabled, cancelled: false };
      this.emit('beforeEditModeChange', beforeEvent);
      if (beforeEvent.cancelled) return false;

      if (enabled && !this.isEditMode) {
        if (!this.originalDataBackup || this.originalDataBackup.length === 0) {
          this.originalDataBackup = deepClone(this.originalData);
        }
      }
      this.isEditMode = enabled;
      this.renderGrid();
      // ğŸŒŸ ì¶”ê°€: ì •ë ¬ í‘œì‹œ ë³µì›
      this.columns.forEach((col) => {
        if (col.sortable) {
          this.updateSortIndicator(col.field);
        }
      });
      const message = enabled ? 'ìˆ˜ì • ëª¨ë“œ í™œì„±í™”' : 'ìˆ˜ì • ëª¨ë“œ ë¹„í™œì„±í™”';
      this.showToast(message, 'success');
      this.emit('afterEditModeChange', { previousMode: beforeEvent.previousMode, currentMode: enabled });
      return true;
    }

    isEditModeEnabled() {
      return this.editModeEnabled;
    }

    getEditMode() {
      return this.isEditMode;
    }

    // ========== ìœ íš¨ì„± ê²€ì‚¬ ==========
    validateChanges() {
      // [ì¶”ê°€ëœ ë¡œì§ ì‹œì‘] 1. ìƒˆ í–‰ì´ ì™„ì „íˆ ë¹„ì–´ìˆëŠ”ì§€ ê²€ì‚¬
      if (this.changedRows.newRows.length > 0) {
        const hasEmptyNewRow = this.changedRows.newRows.some((row) => {
          // ì»¬ëŸ¼ ì •ì˜ì— ìˆëŠ” ëª¨ë“  í•„ë“œ ê°’ì„ í™•ì¸
          return this.columns.every((col) => {
            const val = row[col.field];
            // 0ì´ë‚˜ falseëŠ” ìœ íš¨í•œ ê°’ì´ë¯€ë¡œ ì œì™¸í•˜ê³ , null/undefined/ë¹ˆë¬¸ìì—´ë§Œ ì²´í¬
            return val === null || val === undefined || String(val).trim() === '';
          });
        });

        if (hasEmptyNewRow) {
          this.showToast('ë°ì´í„°ê°€ ì…ë ¥ë˜ì§€ ì•Šì€ í–‰ì´ ìˆìŠµë‹ˆë‹¤. ë‚´ìš©ì„ ì…ë ¥í•˜ê±°ë‚˜ ì‚­ì œ í›„ ì €ì¥í•´ì£¼ì„¸ìš”.', 'warning');
          return false;
        }
      }
      // [ì¶”ê°€ëœ ë¡œì§ ë]

      const rowsToValidate = [...this.changedRows.newRows, ...this.changedRows.updatedRows];
      const beforeEvent = { rowsToValidate, cancelled: false };
      this.emit('beforeValidate', beforeEvent);
      if (beforeEvent.cancelled) return false;

      const errors = [];

      for (const rowData of rowsToValidate) {
        for (const column of this.columns) {
          const value = rowData[column.field]; // â˜… ê°’ ê°€ì ¸ì˜¤ê¸°

          // 1. 'required' ê²€ì‚¬ (ì›ë³¸ ë¡œì§)
          if (column.editor?.required) {
            if (value === null || value === void 0 || String(value).trim() === '') {
              // â–¼â–¼â–¼ 'required' ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§ â–¼â–¼â–¼
              this.showToast(`'${column.title}' í•„ë“œëŠ” í•„ìˆ˜ ì…ë ¥ í•­ëª©ì…ë‹ˆë‹¤.`, 'error');
              const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
              const cellElement = rowElement?.querySelector(`td[data-field="${column.field}"]`);
              if (cellElement) {
                cellElement.classList.add('cell-invalid');
                cellElement.querySelector('input, select, textarea')?.focus();
                setTimeout(() => cellElement.classList.remove('cell-invalid'), 3e3);
              }
              const errorInfo = {
                rowData,
                column,
                value,
                message: `'${column.title}' í•„ë“œëŠ” í•„ìˆ˜ ì…ë ¥ í•­ëª©ì…ë‹ˆë‹¤.`,
              };
              errors.push(errorInfo);
              this.emit('validationError', errorInfo);
              this.emit('afterValidate', { isValid: false, errors });
              return false;
            }
          }

          // 2. â˜… 'validate' í•¨ìˆ˜ ê²€ì‚¬ (column.editor.validateë¡œ ìˆ˜ì •)
          if (typeof column.editor?.validate === 'function') {
            // <-- ê²½ë¡œ ìˆ˜ì •
            try {
              const validationResult = column.editor.validate(value, rowData, column); // <-- ê²½ë¡œ ìˆ˜ì •

              // 'true'ê°€ ì•„ë‹Œ ê°’ (ì˜¤ë¥˜ ë©”ì‹œì§€)ì´ ë°˜í™˜ë˜ë©´ ì‹¤íŒ¨
              if (validationResult !== true) {
                const message = typeof validationResult === 'string' ? validationResult : `'${column.title}' í•„ë“œì˜ ê°’ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`;

                // â–¼â–¼â–¼ ì»¤ìŠ¤í…€ 'validate' ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§ â–¼â–¼â–¼
                this.showToast(message, 'error');
                const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
                const cellElement = rowElement?.querySelector(`td[data-field="${column.field}"]`);
                if (cellElement) {
                  cellElement.classList.add('cell-invalid');
                  cellElement.querySelector('input, select, textarea')?.focus();
                  setTimeout(() => cellElement.classList.remove('cell-invalid'), 3e3);
                }
                const errorInfo = {
                  rowData,
                  column,
                  value,
                  message,
                };
                errors.push(errorInfo);
                this.emit('validationError', errorInfo);
                this.emit('afterValidate', { isValid: false, errors });
                return false;
              }
            } catch (e) {
              // ìœ íš¨ì„± ê²€ì‚¬ í•¨ìˆ˜ ìì²´ì—ì„œ ì˜¤ë¥˜ ë°œìƒ ì‹œ
              const message = `'${column.title}' ìœ íš¨ì„± ê²€ì‚¬ ì¤‘ ì˜¤ë¥˜: ${e.message}`;
              console.error(`Validation function error for ${column.field}:`, e);

              // â–¼â–¼â–¼ ì˜ˆì™¸ ë°œìƒ ì‹œ ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§ â–¼â–¼â–¼
              this.showToast(message, 'error');
              const rowElement = this.table.querySelector(`tr[data-row-id="${rowData[this.idField]}"]`);
              const cellElement = rowElement?.querySelector(`td[data-field="${column.field}"]`);
              if (cellElement) {
                cellElement.classList.add('cell-invalid');
                cellElement.querySelector('input, select, textarea')?.focus();
                setTimeout(() => cellElement.classList.remove('cell-invalid'), 3e3);
              }
              const errorInfo = {
                rowData,
                column,
                value,
                message,
              };
              errors.push(errorInfo);
              this.emit('validationError', errorInfo);
              this.emit('afterValidate', { isValid: false, errors });
              return false;
            }
          }
        } // end for(column)
      } // end for(rowData)

      // ëª¨ë“  ê²€ì‚¬ í†µê³¼
      this.emit('afterValidate', { isValid: true, errors: [] });
      return true;
    }

    printCurrentPage() {
      const data = this.getSortedData();
      if (!data.length) {
        this.showToast('ì¸ì‡„í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
        return;
      }
      this.showLoading();

      try {
        const visibleColumns = this.columns.filter((col) => !col.hideColumn && !this.hiddenColumns.has(col.field) && col.print !== false);
        const headerRow = visibleColumns.map((col) => `<th style="${col.width ? `width:${col.width};` : ''} text-align: ${col.headAlign || 'center'}; padding: 6px;">${col.title}</th>`).join('');
        const tableHTML = `<table border="1" style="width: 100%; border-collapse: collapse; text-align: center; font-size: 10pt;"><thead><tr style="background: #f0f0f0;"><th style="width: 50px;">ë²ˆí˜¸</th>${headerRow}</tr></thead><tbody>${data
        .map(
          (row, i) =>
            `<tr><td style="padding: 6px;">${i + 1}</td>${visibleColumns
              .map((col) => {
                const rawValue = row[col.field] ?? '';
                let cellContent = rawValue;

                // 1. 'numberbox' íƒ€ì…ì— ëŒ€í•´ì„œë§Œ formatNumber ì ìš© (ì²œ ë‹¨ìœ„ ì½¤ë§ˆ)
                if (col.editor && col.editor.type === 'numberbox') {
                  cellContent = formatNumber(rawValue, col.editor.decimalPlaces || 0);
                }
                // 2. ê·¸ ì™¸(ë‚ ì§œ, ê³„ì¢Œë²ˆí˜¸ ë“±)ëŠ” cellContentì— ì›ë³¸ ê°’(rawValue)ì´ ê·¸ëŒ€ë¡œ ìœ ì§€ë¨.

                // 3. ì…€ ì •ë ¬ ê²°ì • (numberboxë§Œ ì˜¤ë¥¸ìª½ ì •ë ¬)
                // col.editor?.type ì„ ì‚¬ìš©í•´ ì•ˆì „í•˜ê²Œ ì ‘ê·¼
                const align = col.cellAlign || (col.editor?.type === 'numberbox' ? 'right' : 'left');

                // 4. ìµœì¢… ì…€ HTML ë°˜í™˜
                return `<td style="text-align: ${align}; padding: 6px;">${cellContent}</td>`;
              })
              .join('')}</tr>`
        )
        .join('')}</tbody></table>`;
        this.openPrintWindow(tableHTML);
      } finally {
        this.hideLoading();
      }
    }
    openPrintWindow(html) {
      const win = window.open('', '_blank', 'width=800,height=600');
      const docTitle = document.title;
      const time = getCurrentDateTime();
      win.document.write(
        `<html><head><title>ì¸ì‡„</title><style>@media print{@page{margin:1cm}thead{display:table-header-group}}body{font-family:'Malgun Gothic','Arial',sans-serif}h1{text-align:center;margin-bottom:5px;font-size:18pt}.subtitle{text-align:center;color:#666;margin-bottom:20px;font-size:10pt}table{width:100%;border-collapse:collapse;table-layout:fixed}th,td{border:1px solid #ccc;padding:8px;font-size:9pt;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}th{background:#f5f5f5;font-weight:bold}</style></head><body><h1>${docTitle.replace(
        'V4',
        'ì¸ì‡„'
      )}</h1><div class="subtitle">ì¶œë ¥ì¼: ${time}</div>${html}</body></html>`
      );
      win.document.close();
      win.focus();
      setTimeout(() => win.print(), 250);
    }

    // ========== ì»¬ëŸ¼ í‘œì‹œ/ìˆ¨ê¹€ ==========
    hideColumn(field) {
      this.hiddenColumns.add(field);
      this.renderGrid();
      this.showToast(`"${this.columns.find((c) => c.field === field)?.title}" ì—´ì´ ìˆ¨ê²¨ì¡ŒìŠµë‹ˆë‹¤.`, 'info');
    }

    showColumn(field) {
      this.hiddenColumns.delete(field);
      this.renderGrid();
      this.showToast(`"${this.columns.find((c) => c.field === field)?.title}" ì—´ì´ í‘œì‹œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
    }

    // ========== UI ë©”ì„œë“œ (ìœ„ì„) ==========
    showLoading() {
      this.uiComponents.showLoading();
    }

    hideLoading() {
      this.uiComponents.hideLoading();
    }

    showToast(message, type = 'info') {
      this.uiComponents.showToast(message, type);
    }

    showConfirmModal(message, callback) {
      this.uiComponents.showConfirmModal(message, callback);
    }

    // ========== ì—ëŸ¬ ì²˜ë¦¬ ==========
    handleError(error, context = '') {
      const errorInfo = {
        message: error.message,
        code: error.code || 'UNKNOWN_ERROR',
        context,
        instanceId: this.instanceId,
        tableId: this.tableId,
        timestamp: new Date().toISOString(),
        stack: error.stack,
      };
      if (this.debugMode) {
        console.group(`âŒ SmartGrid Error [${this.tableId}]`);
        console.error('Error:', error.message);
        console.log('Context:', context);
        console.log('Instance:', this.instanceId);
        console.groupEnd();
      }
      this.emit('error', errorInfo);
      const userMessage = this.getUserFriendlyMessage(error);
      this.showToast(userMessage, 'error');
    }

    getUserFriendlyMessage(error) {
      const errorMessages = {
        INVALID_DATA: 'ì˜ëª»ëœ ë°ì´í„° í˜•ì‹ì…ë‹ˆë‹¤.',
        INVALID_COLUMN: 'ì˜ëª»ëœ ì»¬ëŸ¼ ì„¤ì •ì…ë‹ˆë‹¤.',
        RENDER_FAILED: 'ê·¸ë¦¬ë“œë¥¼ ë Œë”ë§í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
        VALIDATION_FAILED: 'ë°ì´í„° ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
        ELEMENT_NOT_FOUND: 'í•„ìˆ˜ HTML ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
        INITIALIZATION_FAILED: 'ê·¸ë¦¬ë“œ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
      };
      return errorMessages[error.code] || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    }

    warn(code, message, details = {}) {
      const warning = {
        code,
        message,
        details,
        instanceId: this.instanceId,
        tableId: this.tableId,
        timestamp: new Date().toISOString(),
      };
      this.warnings.push(warning);
      console.warn(`âš ï¸ SmartGrid Warning [${this.tableId}]`, `\n${message}`, details);
      this.emit('warning', warning);
      if (this.debugMode) {
        this.showToast(`[ê²½ê³ ] ${message}`, 'warning');
      }
    }

    info(message, details = {}) {
      if (this.debugMode) {
        console.info(`â„¹ï¸ SmartGrid Info [${this.tableId}]`, `\n${message}`, details);
      }
    }

    // ========== íŒŒê´´ ==========
    destroy() {
      this.emit('beforeDestroy');

      // â­ ë³€ê²½: pluginManagerë¥¼ í†µí•´ ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ì œê±°
      this.pluginManager?.unregisterAll();

      SmartGrid.instances.delete(this);
      this.removeAllListeners();
      this.uiComponents.destroyAll();
      this.wrapper?.remove();
      this.renderer.clearTable();

      // â­ ë³€ê²½: pluginManagerë„ null ì²˜ë¦¬
      this.table = this.columns = this.originalData = this.currentPageData = this.inputFactory = this.pluginManager = null;

      console.log(`âœ… SmartGrid ì¸ìŠ¤í„´ìŠ¤ "${this.tableId}" ì œê±° ì™„ë£Œ`);

      if (SmartGrid.instances.size === 0) {
        SmartGrid.globalEventsInitialized = false;
        console.log('âœ… ëª¨ë“  SmartGrid ì¸ìŠ¤í„´ìŠ¤ ì •ë¦¬ ì™„ë£Œ');
      }
    }
  }

  var SmartGrid$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SmartGrid: SmartGrid
  });

  /**
   * Plugin Base Class
   * @version 1.0.0
   * @description ëª¨ë“  SmartGrid í”ŒëŸ¬ê·¸ì¸ì˜ ë² ì´ìŠ¤ í´ë˜ìŠ¤
   */

  class PluginBase {
    constructor(grid, options = {}) {
      if (this.constructor === PluginBase) {
        throw new Error('PluginBaseëŠ” ì§ì ‘ ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
      }
      this.grid = grid;
      this.options = options;
      this.initialized = false;
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ê³ ìœ  ì´ë¦„ (í•„ìˆ˜ êµ¬í˜„)
     * @returns {string}
     */
    get name() {
      throw new Error('name getterëŠ” ë°˜ë“œì‹œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤');
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ë²„ì „
     * @returns {string}
     */
    get version() {
      return '1.0.0';
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™” (ì„ íƒì  êµ¬í˜„)
     */
    install() {
      this.initialized = true;
      this.grid.info(`Plugin "${this.name}" v${this.version} installed`);
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì œê±° (ì„ íƒì  êµ¬í˜„)
     */
    uninstall() {
      this.initialized = false;
      this.grid.info(`Plugin "${this.name}" uninstalled`);
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ í™œì„±í™” ì—¬ë¶€
     * @returns {boolean}
     */
    isInstalled() {
      return this.initialized;
    }

    /**
     * ì—ëŸ¬ ì²˜ë¦¬ í—¬í¼
     * @param {Error} error - ì—ëŸ¬ ê°ì²´
     * @param {string} context - ì—ëŸ¬ ë°œìƒ ì»¨í…ìŠ¤íŠ¸
     */
    handleError(error, context = '') {
      this.grid.handleError(error, `${this.name}:${context}`);
    }

    /**
     * ë¡œê¹… í—¬í¼
     * @param {string} message - ë¡œê·¸ ë©”ì‹œì§€
     * @param {string} type - ë¡œê·¸ íƒ€ì… (info, warn, error)
     */
    log(message, type = 'info') {
      const prefix = `[Plugin:${this.name}]`;
      switch (type) {
        case 'error':
          console.error(prefix, message);
          break;
        case 'warn':
          console.warn(prefix, message);
          break;
        default:
          console.log(prefix, message);
      }
    }

    /**
     * ì˜µì…˜ ë³‘í•© í—¬í¼
     * @param {Object} defaultOptions - ê¸°ë³¸ ì˜µì…˜
     * @param {Object} userOptions - ì‚¬ìš©ì ì˜µì…˜
     * @returns {Object}
     */
    mergeOptions(defaultOptions, userOptions) {
      return { ...defaultOptions, ...userOptions };
    }
  }

  /**
   * Excel Plugin for SmartGrid
   * @version 1.0.0
   * @description SmartGridì— ì—‘ì…€ ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” í”ŒëŸ¬ê·¸ì¸
   * @requires XLSX library (SheetJS)
   * @see https://github.com/sheetjs/sheetjs
   */

  // ========== Strategy Classes ==========
  class PreviewUploadStrategy {
    async handle(plugin, parsedData, options) {
      const { validData, errors } = plugin.validate(parsedData, options);
      if (errors.length > 0) {
        plugin.grid.showToast(errors[0], 'error');
        return;
      }
      const processedData = options.dataProcessor ? options.dataProcessor(validData) : validData;
      plugin.bind(processedData, options);
      plugin.grid.showToast('ì—‘ì…€ ë°ì´í„°ê°€ ê·¸ë¦¬ë“œì— ì„±ê³µì ìœ¼ë¡œ ë°”ì¸ë”©ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
    }
  }

  class DirectUploadStrategy {
    async handle(plugin, parsedData, options) {
      const { validData, errors } = plugin.validate(parsedData, options);
      if (errors.length > 0) {
        plugin.grid.showToast(errors[0], 'error');
        return;
      }

      // âœ… columnMap ì ìš© ì¶”ê°€!
      const processedData = options.dataProcessor ? options.dataProcessor(validData) : validData;

      // âœ… ë§¤í•‘ëœ ë°ì´í„° ìƒì„±
      const mappedData = plugin.mapData(processedData, options);

      plugin.grid.showConfirmModal(`ì´ ${mappedData.length}ê±´ì˜ ë°ì´í„°ë¥¼ ì„œë²„ë¡œ ì „ì†¡í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, async (confirmed) => {
        if (confirmed) {
          await plugin.sendToServer(mappedData, options);
        }
      });
    }
  }

  // ========== Main Plugin Class ==========
  class GridExcelPlugin extends PluginBase {
    constructor(grid, options = {}) {
      super(grid, options);

      // ê¸°ë³¸ ì˜µì…˜
      const defaultOptions = {
        columnMap: this.generateColumnMap(),
        validationRules: this.generateValidationRules(),
        dataProcessor: null,
      };

      this.options = this.mergeOptions(defaultOptions, options);
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì´ë¦„
     */
    get name() {
      return 'excel';
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ë²„ì „
     */
    get version() {
      return '1.0.0';
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì´ˆê¸°í™”
     */
    install() {
      super.install();

      // ê·¸ë¦¬ë“œ íŒŒê´´ ì‹œ ìë™ ì •ë¦¬
      this.grid.on('beforeDestroy', () => this.uninstall());
    }

    // ========== Public Methods ==========

    /**
     * ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ
     * @param {File} file - ì—‘ì…€ íŒŒì¼
     * @param {Object} options - ì—…ë¡œë“œ ì˜µì…˜
     * @param {string} options.mode - 'preview' | 'direct'
     * @param {string} options.url - ì„œë²„ URL (direct ëª¨ë“œìš©)
     * @param {Object} options.columnMap - ì»¬ëŸ¼ ë§¤í•‘
     * @param {Object} options.validationRules - ìœ íš¨ì„± ê·œì¹™
     * @param {Function} options.dataProcessor - ë°ì´í„° ì „ì²˜ë¦¬ í•¨ìˆ˜
     */
    async upload(file, options = {}) {
      try {
        this.log(`Uploading file: ${file.name}`);

        const uploadOptions = this.mergeOptions(this.options, options);
        const parsedData = await this.parse(file);

        const strategy = uploadOptions.mode === 'direct' ? new DirectUploadStrategy() : new PreviewUploadStrategy();

        await strategy.handle(this, parsedData, uploadOptions);

        this.log('Upload completed successfully');
      } catch (error) {
        this.handleError(error, 'upload');
        throw error;
      }
    }

    /**
     * ê·¸ë¦¬ë“œ ë°ì´í„°ë¥¼ ì—‘ì…€ë¡œ ë‹¤ìš´ë¡œë“œ
     * @param {string} fileName - íŒŒì¼ëª…
     */
    async download(fileName = 'grid_data.xlsx') {
      try {
        this.log(`Downloading file: ${fileName}`);

        const gridData = this.grid.getData();
        if (gridData.length === 0) {
          this.grid.showToast('ë‹¤ìš´ë¡œë“œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'info');
          return;
        }

        const dataToExport = this.prepareExportData(gridData);

        if (typeof XLSX === 'undefined') {
          throw new Error('XLSX ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        }

        const worksheet = XLSX.utils.json_to_sheet(dataToExport);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
        XLSX.writeFile(workbook, fileName);

        this.grid.showToast('ì—‘ì…€ íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        this.log('Download completed successfully');
      } catch (error) {
        this.handleError(error, 'download');
        throw error;
      }
    }

    /**
     * ê·¸ë¦¬ë“œ ë°ì´í„°ë¥¼ ì„œë²„ë¡œ ì „ì†¡
     * @param {Object} options - ì „ì†¡ ì˜µì…˜
     * @param {string} options.url - ì„œë²„ URL
     */
    // async send(options = {}) {
    //   const dataToSend = this.grid.getData();

    //   // ë°ì´í„° ì—†ì„ ê²½ìš° ì¡°ê¸° ë°˜í™˜
    //   if (!dataToSend || dataToSend.length === 0) {
    //     this.grid.showToast('ì „ì†¡í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
    //     return;
    //   }

    //   await this.sendToServer(dataToSend, options);
    // }

    async send(options = {}) {
      try {
        const dataToSend = this.grid.getData();

        if (!dataToSend || dataToSend.length === 0) {
          this.grid.showToast('\uC804\uC1A1\uD560 \uB370\uC774\uD130\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.', 'warning');
          return;
        }

        if (options.skipConfirm === true) {
          await this.sendToServer(dataToSend, options);
        } else {
          this.grid.showConfirmModal(`\uCD1D ${dataToSend.length}\uAC74\uC758 \uB370\uC774\uD130\uB97C \uC11C\uBC84\uB85C \uC804\uC1A1\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`, async (confirmed) => {
            if (confirmed) {
              await this.sendToServer(dataToSend, options);
            }
          });
        }
      } catch (error) {
        this.handleError(error, 'send');
        throw error;
      }
    }

    // ========== Internal Methods ==========

    /**
     * ì—‘ì…€ íŒŒì¼ íŒŒì‹±
     * @private
     */
    async parse(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          try {
            if (typeof XLSX === 'undefined') {
              throw new Error('XLSX ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            }

            const workbook = XLSX.read(reader.result, {
              type: 'array',
              cellDates: true,
              raw: false,
              dateNF: 'yyyy-mm-dd',
            });

            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];

            const headers = XLSX.utils.sheet_to_json(sheet, {
              header: 1,
              range: 0,
              raw: false,
            })[0];

            if (!headers || headers.length === 0) {
              throw new Error('ì—‘ì…€ íŒŒì¼ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.');
            }

            const data = XLSX.utils.sheet_to_json(sheet, {
              header: headers,
              defval: '',
              raw: false,
              range: 1,
            });

            this.log(`Parsed ${data.length} rows from Excel file`);
            resolve(data);
          } catch (err) {
            reject(err);
          }
        };

        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
      });
    }

    /**
     * ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
     * @private
     */
    validate(data, options) {
      const validData = [];
      const errors = [];
      const { validationRules } = options;

      for (const [index, row] of data.entries()) {
        const rowErrors = [];

        for (const excelHeader in validationRules) {
          if (validationRules[excelHeader].required) {
            const value = row[excelHeader];
            if (value === undefined || value === null || String(value).trim() === '') {
              rowErrors.push(`'${excelHeader}'`);
            }
          }
        }

        if (rowErrors.length > 0) {
          errors.push(`${index + 2}í–‰ì—ì„œ ${rowErrors.join(', ')} í•„ë“œì˜ ê°’ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.`);
          break;
        } else {
          validData.push(row);
        }
      }

      return { validData, errors };
    }

    /**
     * ë°ì´í„° ë§¤í•‘ (ì—‘ì…€ í—¤ë” â†’ ê·¸ë¦¬ë“œ í•„ë“œëª…)
     * @private
     */
    mapData(data, options) {
      const { columnMap } = options;

      return data.map((row) => {
        const newRow = {};
        for (const excelHeader in columnMap) {
          if (row[excelHeader] !== undefined) {
            newRow[columnMap[excelHeader]] = row[excelHeader];
          }
        }
        return newRow;
      });
    }

    /**
     * ì—‘ì…€ ë°ì´í„°ë¥¼ ê·¸ë¦¬ë“œì— ë°”ì¸ë”©
     * @private
     */
    bind(data, options) {
      // âœ… ë§¤í•‘ ë¡œì§ì„ mapDataë¡œ ë¶„ë¦¬
      const mappedData = this.mapData(data, options);

      // formula ê³„ì‚° ì ìš©
      if (typeof this.grid.applyFormula === 'function') {
        mappedData.forEach((row) => this.grid.applyFormula(row));
      }

      this.grid.invalidateSortCache();

      // ì„œë²„ì‚¬ì´ë“œ ëª¨ë“œì¸ ê²½ìš°
      if (this.grid.pagingMode === 'server') {
        this.grid.currentPageData = mappedData;
        this.grid.totalRows = mappedData.length;
        this.grid.currentPage = 1;
        this.grid.renderGrid();
        this.grid.renderPagination();
        this.grid.updateTotalRowsInfo();
      } else {
        // í´ë¼ì´ì–¸íŠ¸ ëª¨ë“œ
        this.grid.originalData = mappedData;
        this.grid.totalRows = mappedData.length;
        this.grid.currentPage = 1;
        this.grid.currentPageData = mappedData.slice(0, this.grid.pageSize);
        this.grid.renderGrid();
        this.grid.renderPagination();
        this.grid.updateTotalRowsInfo();
      }

      this.log(`Bound ${mappedData.length} rows to grid`);
    }

    /**
     * ì„œë²„ë¡œ ë°ì´í„° ì „ì†¡
     * @private
     */
    async sendToServer(data, options) {
      if (!data || data.length === 0) {
        this.grid.showToast('ì „ì†¡í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'info');
        return;
      }

      const url = options.url || '/';
      this.log(`Sending ${data.length} rows to ${url}`);

      this.grid.showLoading();

      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });

        if (!response.ok) {
          throw new Error(`Server response error: ${response.status}`);
        }

        const result = await response.json();
        this.grid.showToast('ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
        this.log('Data sent successfully');

        // âœ… ì˜µì…˜ì— ë”°ë¼ ê·¸ë¦¬ë“œ ì´ˆê¸°í™” (ê¸°ë³¸ê°’: false)
        if (options.clearAfterSend === true) {
          this.grid.loadData([]);
          this.log('Grid cleared after send');
        }

        return result;
      } catch (error) {
        this.log(`Send failed: ${error.message}`, 'error');
        this.grid.showToast('ì„œë²„ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
        throw error;
      } finally {
        this.grid.hideLoading();
      }
    }

    /**
     * ì»¬ëŸ¼ ë§¤í•‘ ìë™ ìƒì„±
     * @private
     */
    generateColumnMap() {
      return this.grid.columns.reduce((map, col) => {
        if (col.title && col.field) {
          map[col.title] = col.field;
        }
        return map;
      }, {});
    }

    /**
     * ìœ íš¨ì„± ê²€ì‚¬ ê·œì¹™ ìë™ ìƒì„±
     * @private
     */
    generateValidationRules() {
      return this.grid.columns.reduce((rules, col) => {
        if (col.title && col.editor?.required) {
          rules[col.title] = { required: true };
        }
        return rules;
      }, {});
    }

    /**
     * ë‚´ë³´ë‚´ê¸° ë°ì´í„° ì¤€ë¹„
     * @private
     */
    prepareExportData(gridData) {
      return gridData.map((row) => {
        const newRow = {};
        this.grid.columns.forEach((col) => {
          if (!col.hideColumn && col.exportExcel !== false) {
            // exportExcel ì†ì„± ì²´í¬
            newRow[col.title] = row[col.field];
          }
        });
        return newRow;
      });
    }
  }

  var excel = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GridExcelPlugin: GridExcelPlugin
  });

  /**
   * SmartGrid Chart Plugin
   * @version 1.2.1 (ìˆ˜ì •ë¨)
   * @description Chart.jsë¥¼ ì‚¬ìš©í•˜ì—¬ ê·¸ë¦¬ë“œ ë°ì´í„°ë¥¼ ì°¨íŠ¸ë¡œ ì‹œê°í™”í•˜ëŠ” í”ŒëŸ¬ê·¸ì¸
   * @requires Chart.js (window.Chart)
   */

  class GridChartPlugin extends PluginBase {
    /**
     * GridChartPlugin ìƒì„±ì
     * @param {SmartGrid} grid - SmartGrid ì¸ìŠ¤í„´ìŠ¤
     * @param {Object} options - í”ŒëŸ¬ê·¸ì¸ ì˜µì…˜
     */
    constructor(grid, options = {}) {
      super(grid, options);

      const defaultOptions = {
        defaultChartType: 'bar',
        modalTitle: 'ë°ì´í„° ì°¨íŠ¸',
        chartLibrary: window.Chart,
      };
      this.options = this.mergeOptions(defaultOptions, options);

      this.chartModalElement = null;
      this.chartInstance = null;
      this.boundHideModal = this._hideModal.bind(this);
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ê³ ìœ  ì´ë¦„
     */
    get name() {
      return 'chart';
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ë²„ì „
     */
    get version() {
      return '1.2.1'; // (ë²„ì „ ì—…ë°ì´íŠ¸)
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì„¤ì¹˜ (ì´ˆê¸°í™”)
     */
    install() {
      super.install();
      this.createChartModal();
      this.grid.on('beforeDestroy', () => this.uninstall());
    }

    /**
     * í”ŒëŸ¬ê·¸ì¸ ì œê±° (íŒŒê´´)
     */
    uninstall() {
      this.chartModalElement?.remove();
      this.chartModalElement = null;

      if (this.chartInstance) {
        this.chartInstance.destroy();
        this.chartInstance = null;
      }

      super.uninstall();
    }

    // ========== Public Methods (ê³µê°œ ë©”ì„œë“œ) ==========

    /**
     * ì°¨íŠ¸ë¥¼ ìƒì„±í•˜ê³  ëª¨ë‹¬ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
     * (index.phpì˜ í—¬í¼ ë¡œì§ í†µí•©)
     * @param {Object} options - ì°¨íŠ¸ ìƒì„± ì˜µì…˜
     * @param {string} options.type - ì°¨íŠ¸ íƒ€ì… (ì˜ˆ: 'bar', 'line', 'pie')
     * @param {string} [options.groupBy] - (NEW) ë°ì´í„°ë¥¼ ê·¸ë£¹í™”í•  í•„ë“œëª…. ì§€ì • ì‹œ labelFieldëŠ” ë¬´ì‹œë¨.
     * @param {string} options.labelField - (groupBy ë¯¸ì§€ì • ì‹œ) ë ˆì´ë¸”(Xì¶•)ë¡œ ì‚¬ìš©í•  ë°ì´í„° í•„ë“œëª…
     * @param {string|string[]} options.dataFields - ë°ì´í„°(Yì¶•)ë¡œ ì‚¬ìš©í•  í•„ë“œëª… (í•„ìˆ˜)
     * @param {string} [options.title] - ì°¨íŠ¸ ëª¨ë‹¬ì— í‘œì‹œë  ì œëª©
     * @param {Object} [options.chartOptions] - Chart.jsì— ì „ë‹¬í•  ì¶”ê°€ ì˜µì…˜
     */
    showChart(options = {}) {
      // 1. Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ì¸
      if (!this.options.chartLibrary) {
        const errorMsg = 'Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (window.Chartê°€ ì—†ìŠµë‹ˆë‹¤)';
        this.handleError(new Error(errorMsg), 'showChart');
        this.grid.showToast(errorMsg, 'error');
        return;
      }

      // ğŸ“ ì‚­ì œ: (ìš”ì²­ ì‚¬í•­)
      // ì„œë²„/í´ë¼ì´ì–¸íŠ¸ ëª¨ë“œ êµ¬ë¶„ ì—†ì´ í•­ìƒ í˜„ì¬ í˜ì´ì§€ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ,
      // ì„œë²„ ëª¨ë“œ ì „ìš© í† ìŠ¤íŠ¸ ë©”ì‹œì§€ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
      /*
      if (this.grid.pagingMode === 'server') {
        this.grid.showToast('ì„œë²„ ê·¸ë¦¬ë“œ ì°¨íŠ¸ëŠ” í˜„ì¬ ë¡œë“œëœ í˜ì´ì§€ë§Œì„ ê¸°ì¤€ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤.', 'info');
      }
      */

      // 2. ëª¨ë‹¬ ìš”ì†Œ í™•ì¸
      if (!this.chartModalElement) {
        this.handleError(new Error('ì°¨íŠ¸ ëª¨ë‹¬ì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'), 'showChart');
        return;
      }

      try {
        const chartType = options.type || this.options.defaultChartType;
        const modalTitle = options.title || this.options.modalTitle;

        // 3. ê·¸ë¦¬ë“œ ë°ì´í„° -> ì°¨íŠ¸ ë°ì´í„° ê°€ê³µ
        // (ë‚´ë¶€ì—ì„œ ë°ì´í„° ìœ ë¬´ë¥¼ í™•ì¸í•˜ê³  í† ìŠ¤íŠ¸ ë©”ì‹œì§€ë¥¼ ë„ì›€)
        const chartData = this.generateChartData(options);
        if (!chartData) {
          // generateChartDataì—ì„œ ì´ë¯¸ í† ìŠ¤íŠ¸ë¥¼ í‘œì‹œí–ˆìœ¼ë¯€ë¡œ ë°”ë¡œ ë¦¬í„´
          return;
        }

        // 4. ëª¨ë‹¬ ì œëª© ì„¤ì •
        const titleElement = this.chartModalElement.querySelector('.smartgrid-modal-title');
        if (titleElement) titleElement.textContent = modalTitle;

        // 5. ì°¨íŠ¸ ë Œë”ë§
        const canvas = this.chartModalElement.querySelector('canvas');
        if (!canvas) {
          this.handleError(new Error('ëª¨ë‹¬ì—ì„œ Canvas ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'), 'showChart');
          return;
        }

        this.renderChart(canvas, chartType, chartData, options.chartOptions || {});

        // 6. ëª¨ë‹¬ í‘œì‹œ
        this.chartModalElement.classList.add('show');
      } catch (error) {
        this.handleError(error, 'showChart');
        this.grid.showToast('ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
      }
    }

    /**
     * ì°¨íŠ¸ ëª¨ë‹¬ì„ ìˆ¨ê¹ë‹ˆë‹¤.
     */
    hideChart() {
      this._hideModal();
    }

    // ========== Internal Methods (ë‚´ë¶€ ë©”ì„œë“œ) ==========

    /**
     * ì°¨íŠ¸ë¥¼ í‘œì‹œí•  ëª¨ë‹¬ UIë¥¼ ìƒì„±í•©ë‹ˆë‹¤. (UIComponents.js ì°¸ê³ )
     * @private
     */
    createChartModal() {
      if (this.chartModalElement) return;

      const modal = document.createElement('div');
      modal.id = `${this.grid.instanceId}_chartModal`;
      modal.className = 'smartgrid-modal smartgrid-chart-modal';
      modal.setAttribute('data-instance', this.grid.instanceId);

      modal.innerHTML = `
      <div class="smartgrid-modal-backdrop" data-instance="${this.grid.instanceId}"></div>
      <div class="smartgrid-modal-content" data-instance="${this.grid.instanceId}" style="max-width: 800px; width: 90%;">
        <div class="smartgrid-modal-header">
          <h5 class="smartgrid-modal-title">${this.options.modalTitle}</h5>
          <button class="smartgrid-modal-close" data-instance="${this.grid.instanceId}">&times;</button>
        </div>
        <div class="smartgrid-modal-body" style="padding: 1rem; max-height: 70vh; overflow-y: auto;">
          <canvas id="${this.grid.instanceId}_chartCanvas"></canvas>
        </div>
        <div class="smartgrid-modal-footer">
          <button class="smartgrid-btn smartgrid-btn-secondary" data-dismiss="modal" data-instance="${this.grid.instanceId}">ë‹«ê¸°</button>
        </div>
      </div>
    `;
      document.body.appendChild(modal);
      this.chartModalElement = modal;

      const closeTriggers = modal.querySelectorAll(`
      [data-dismiss="modal"],
      .smartgrid-modal-close,
      .smartgrid-modal-backdrop
    `);
      closeTriggers.forEach((btn) => {
        btn.addEventListener('click', this.boundHideModal);
      });
    }

    /**
     * ëª¨ë‹¬ì„ ìˆ¨ê¸°ê³  ì°¨íŠ¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ íŒŒê´´í•˜ëŠ” ë‚´ë¶€ í•¨ìˆ˜
     * @private
     */
    _hideModal() {
      if (this.chartModalElement) {
        this.chartModalElement.classList.remove('show');
      }
      if (this.chartInstance) {
        this.chartInstance.destroy();
        this.chartInstance = null;
      }
    }

    /**
     * ê·¸ë¦¬ë“œ ë°ì´í„°ë¡œë¶€í„° Chart.js í˜•ì‹ì˜ ë°ì´í„°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
     * (groupBy ì˜µì…˜ ì¶”ê°€ë¨)
     * @private
     */
    generateChartData(options) {
      const { labelField, dataFields, groupBy } = options;

      if (!dataFields || (Array.isArray(dataFields) && dataFields.length === 0) || (typeof dataFields !== 'string' && !Array.isArray(dataFields))) {
        this.grid.showToast('ì°¨íŠ¸ ë°ì´í„° í•„ë“œ(dataFields)ê°€ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.', 'warning');
        return null;
      }

      // ğŸ“ ë³€ê²½: (ìš”ì²­ ì‚¬í•­)
      // this.grid.getData() ëŒ€ì‹  this.grid.getRows()ë¥¼ ì‚¬ìš©í•˜ì—¬
      // í•­ìƒ 'í˜„ì¬ í˜ì´ì§€'ì˜ ë°ì´í„°ë§Œ ê°€ì ¸ì˜µë‹ˆë‹¤.
      const gridData = this.grid.getRows();

      // ë°ì´í„° ìœ ë¬´ í™•ì¸
      if (gridData.length === 0) {
        this.grid.showToast('ì°¨íŠ¸ë¥¼ ìƒì„±í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'info');
        return null;
      }

      const fields = Array.isArray(dataFields) ? dataFields : [dataFields];
      let labels = [];
      let datasets = [];

      // ê·¸ë£¹í•‘ ë¡œì§
      if (groupBy) {
        // 1. ë°ì´í„° ê·¸ë£¹í•‘ ë° í•©ê³„ ê³„ì‚°
        const groups = new Map();
        gridData.forEach((row) => {
          const key = row[groupBy] || 'ë¯¸ë¶„ë¥˜'; // ê·¸ë£¹ í‚¤ (ì˜ˆ: 'ë¸ëª¬íŠ¸')

          if (!groups.has(key)) {
            // ìƒˆ ê·¸ë£¹ ì´ˆê¸°í™”
            const newGroup = {};
            fields.forEach((field) => {
              newGroup[field] = 0; // (ì˜ˆ: { quantity: 0, total_price: 0 })
            });
            groups.set(key, newGroup);
          }

          // ê·¸ë£¹ì— ê°’ ëˆ„ì 
          const group = groups.get(key);
          fields.forEach((field) => {
            group[field] += parseFloat(row[field]) || 0;
          });
        });

        // 2. Chart.js ë°ì´í„°ì…‹ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        labels = Array.from(groups.keys()); // Xì¶• ë ˆì´ë¸” (ì˜ˆ: ['ë¸ëª¬íŠ¸', 'ì²­ì •ì›', ...])

        datasets = fields.map((field) => {
          const column = this.grid.columns.find((c) => c.field === field);
          return {
            label: column ? column.title : field, // ë²”ë¡€ (ì˜ˆ: 'ìˆ˜ëŸ‰')
            data: labels.map((key) => groups.get(key)[field]), // (ì˜ˆ: [150, 200, ...])
          };
        });
      } else {
        // ê¸°ì¡´ ë¡œì§ (ì›ë³¸ ë°ì´í„°)
        labels = gridData.map((row) => (labelField ? row[labelField] : ''));
        datasets = fields.map((field) => {
          const column = this.grid.columns.find((c) => c.field === field);
          return {
            label: column ? column.title : field,
            data: gridData.map((row) => parseFloat(row[field]) || 0),
          };
        });
      }

      return {
        labels: labels,
        datasets: datasets,
      };
    }

    /**
     * Canvasì— Chart.js ì°¨íŠ¸ë¥¼ ë Œë”ë§í•©ë‹ˆë‹¤.
     * @private
     */
    renderChart(canvas, type, data, chartOptions = {}) {
      if (this.chartInstance) {
        this.chartInstance.destroy();
      }

      const Chart = this.options.chartLibrary;

      try {
        this.chartInstance = new Chart(canvas, {
          type: type,
          data: data,
          options: this.mergeOptions(
            {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: {
                  position: 'top',
                },
                title: {
                  display: false,
                },
              },
            },
            chartOptions
          ),
        });
      } catch (e) {
        this.handleError(e, 'renderChart');
        this.grid.showToast(`ì°¨íŠ¸ ë Œë”ë§ ì‹¤íŒ¨: ${e.message}`, 'error');
      }
    }
  }

  var chart = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GridChartPlugin: GridChartPlugin
  });

  /**
   * SmartGrid App Entry Point
   * @version 1.0.0
   * @description SmartGrid ëª¨ë“ˆí™” ì§„ì…ì  - ëª¨ë“  í´ë˜ìŠ¤ì™€ ìœ í‹¸ë¦¬í‹°ë¥¼ export
   */

  // ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œ ì „ì—­ì— ë°”ì¸ë”©
  if (typeof window !== 'undefined') {
    // default export
    Promise.resolve().then(function () { return SmartGrid$1; }).then((module) => {
      window.SmartGrid = module.SmartGrid;
    }); // named export

    Promise.resolve().then(function () { return excel; }).then((module) => {
      window.GridExcelPlugin = module.GridExcelPlugin;
    }); // [ë³€ê²½] ì°¨íŠ¸ í”ŒëŸ¬ê·¸ì¸ ì „ì—­ ë°”ì¸ë”© ì¶”ê°€

    Promise.resolve().then(function () { return chart; }).then((module) => {
      window.GridChartPlugin = module.GridChartPlugin;
    });
  }

  exports.ClientSideHandler = ClientSideHandler;
  exports.DataHandler = DataHandler;
  exports.EventEmitter = EventEmitter;
  exports.GridChartPlugin = GridChartPlugin;
  exports.GridEvents = GridEvents;
  exports.GridExcelPlugin = GridExcelPlugin;
  exports.GridRenderer = GridRenderer;
  exports.InputFactory = InputFactory;
  exports.PluginBase = PluginBase;
  exports.ServerSideHandler = ServerSideHandler;
  exports.SmartGrid = SmartGrid;
  exports.SmartGridError = SmartGridError;
  exports.UIComponents = UIComponents;
  exports.createSvgUse = createSvgUse;
  exports.deepClone = deepClone;
  exports["default"] = SmartGrid;
  exports.formatNumber = formatNumber;
  exports.getCurrentDateTime = getCurrentDateTime;
  exports.isEmpty = isEmpty;
  exports.sleep = sleep;
  exports.stripHtml = stripHtml;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
